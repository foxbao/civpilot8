// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message/drivers/gnss/proto/raw_gnss.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto;
namespace civ {
namespace drivers {
namespace rawgnss {
class BestVel;
class BestVelDefaultTypeInternal;
extern BestVelDefaultTypeInternal _BestVel_default_instance_;
class Bestpos;
class BestposDefaultTypeInternal;
extern BestposDefaultTypeInternal _Bestpos_default_instance_;
class GNGGA;
class GNGGADefaultTypeInternal;
extern GNGGADefaultTypeInternal _GNGGA_default_instance_;
class GNVTG;
class GNVTGDefaultTypeInternal;
extern GNVTGDefaultTypeInternal _GNVTG_default_instance_;
class GnssHeader;
class GnssHeaderDefaultTypeInternal;
extern GnssHeaderDefaultTypeInternal _GnssHeader_default_instance_;
class Heading2;
class Heading2DefaultTypeInternal;
extern Heading2DefaultTypeInternal _Heading2_default_instance_;
class InspVax;
class InspVaxDefaultTypeInternal;
extern InspVaxDefaultTypeInternal _InspVax_default_instance_;
class LogHeader;
class LogHeaderDefaultTypeInternal;
extern LogHeaderDefaultTypeInternal _LogHeader_default_instance_;
class RawImu;
class RawImuDefaultTypeInternal;
extern RawImuDefaultTypeInternal _RawImu_default_instance_;
}  // namespace rawgnss
}  // namespace drivers
}  // namespace civ
PROTOBUF_NAMESPACE_OPEN
template<> ::civ::drivers::rawgnss::BestVel* Arena::CreateMaybeMessage<::civ::drivers::rawgnss::BestVel>(Arena*);
template<> ::civ::drivers::rawgnss::Bestpos* Arena::CreateMaybeMessage<::civ::drivers::rawgnss::Bestpos>(Arena*);
template<> ::civ::drivers::rawgnss::GNGGA* Arena::CreateMaybeMessage<::civ::drivers::rawgnss::GNGGA>(Arena*);
template<> ::civ::drivers::rawgnss::GNVTG* Arena::CreateMaybeMessage<::civ::drivers::rawgnss::GNVTG>(Arena*);
template<> ::civ::drivers::rawgnss::GnssHeader* Arena::CreateMaybeMessage<::civ::drivers::rawgnss::GnssHeader>(Arena*);
template<> ::civ::drivers::rawgnss::Heading2* Arena::CreateMaybeMessage<::civ::drivers::rawgnss::Heading2>(Arena*);
template<> ::civ::drivers::rawgnss::InspVax* Arena::CreateMaybeMessage<::civ::drivers::rawgnss::InspVax>(Arena*);
template<> ::civ::drivers::rawgnss::LogHeader* Arena::CreateMaybeMessage<::civ::drivers::rawgnss::LogHeader>(Arena*);
template<> ::civ::drivers::rawgnss::RawImu* Arena::CreateMaybeMessage<::civ::drivers::rawgnss::RawImu>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace civ {
namespace drivers {
namespace rawgnss {

enum GNGGA_LatitudeDirection : int {
  GNGGA_LatitudeDirection_North = 0,
  GNGGA_LatitudeDirection_South = 1
};
bool GNGGA_LatitudeDirection_IsValid(int value);
constexpr GNGGA_LatitudeDirection GNGGA_LatitudeDirection_LatitudeDirection_MIN = GNGGA_LatitudeDirection_North;
constexpr GNGGA_LatitudeDirection GNGGA_LatitudeDirection_LatitudeDirection_MAX = GNGGA_LatitudeDirection_South;
constexpr int GNGGA_LatitudeDirection_LatitudeDirection_ARRAYSIZE = GNGGA_LatitudeDirection_LatitudeDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GNGGA_LatitudeDirection_descriptor();
template<typename T>
inline const std::string& GNGGA_LatitudeDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GNGGA_LatitudeDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GNGGA_LatitudeDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GNGGA_LatitudeDirection_descriptor(), enum_t_value);
}
inline bool GNGGA_LatitudeDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GNGGA_LatitudeDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GNGGA_LatitudeDirection>(
    GNGGA_LatitudeDirection_descriptor(), name, value);
}
enum GNGGA_LongitudeDirection : int {
  GNGGA_LongitudeDirection_East = 0,
  GNGGA_LongitudeDirection_West = 1
};
bool GNGGA_LongitudeDirection_IsValid(int value);
constexpr GNGGA_LongitudeDirection GNGGA_LongitudeDirection_LongitudeDirection_MIN = GNGGA_LongitudeDirection_East;
constexpr GNGGA_LongitudeDirection GNGGA_LongitudeDirection_LongitudeDirection_MAX = GNGGA_LongitudeDirection_West;
constexpr int GNGGA_LongitudeDirection_LongitudeDirection_ARRAYSIZE = GNGGA_LongitudeDirection_LongitudeDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GNGGA_LongitudeDirection_descriptor();
template<typename T>
inline const std::string& GNGGA_LongitudeDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GNGGA_LongitudeDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GNGGA_LongitudeDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GNGGA_LongitudeDirection_descriptor(), enum_t_value);
}
inline bool GNGGA_LongitudeDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GNGGA_LongitudeDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GNGGA_LongitudeDirection>(
    GNGGA_LongitudeDirection_descriptor(), name, value);
}
enum GNGGA_UnitTypes : int {
  GNGGA_UnitTypes_METRES = 0
};
bool GNGGA_UnitTypes_IsValid(int value);
constexpr GNGGA_UnitTypes GNGGA_UnitTypes_UnitTypes_MIN = GNGGA_UnitTypes_METRES;
constexpr GNGGA_UnitTypes GNGGA_UnitTypes_UnitTypes_MAX = GNGGA_UnitTypes_METRES;
constexpr int GNGGA_UnitTypes_UnitTypes_ARRAYSIZE = GNGGA_UnitTypes_UnitTypes_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GNGGA_UnitTypes_descriptor();
template<typename T>
inline const std::string& GNGGA_UnitTypes_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GNGGA_UnitTypes>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GNGGA_UnitTypes_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GNGGA_UnitTypes_descriptor(), enum_t_value);
}
inline bool GNGGA_UnitTypes_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GNGGA_UnitTypes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GNGGA_UnitTypes>(
    GNGGA_UnitTypes_descriptor(), name, value);
}
enum GNVTG_PositionSystemModeIndicator : int {
  GNVTG_PositionSystemModeIndicator_Autonomous = 1,
  GNVTG_PositionSystemModeIndicator_Differential = 2,
  GNVTG_PositionSystemModeIndicator_EstimatedMode = 3,
  GNVTG_PositionSystemModeIndicator_ManualInput = 4,
  GNVTG_PositionSystemModeIndicator_DataNotValid = 5
};
bool GNVTG_PositionSystemModeIndicator_IsValid(int value);
constexpr GNVTG_PositionSystemModeIndicator GNVTG_PositionSystemModeIndicator_PositionSystemModeIndicator_MIN = GNVTG_PositionSystemModeIndicator_Autonomous;
constexpr GNVTG_PositionSystemModeIndicator GNVTG_PositionSystemModeIndicator_PositionSystemModeIndicator_MAX = GNVTG_PositionSystemModeIndicator_DataNotValid;
constexpr int GNVTG_PositionSystemModeIndicator_PositionSystemModeIndicator_ARRAYSIZE = GNVTG_PositionSystemModeIndicator_PositionSystemModeIndicator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GNVTG_PositionSystemModeIndicator_descriptor();
template<typename T>
inline const std::string& GNVTG_PositionSystemModeIndicator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GNVTG_PositionSystemModeIndicator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GNVTG_PositionSystemModeIndicator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GNVTG_PositionSystemModeIndicator_descriptor(), enum_t_value);
}
inline bool GNVTG_PositionSystemModeIndicator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GNVTG_PositionSystemModeIndicator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GNVTG_PositionSystemModeIndicator>(
    GNVTG_PositionSystemModeIndicator_descriptor(), name, value);
}
enum TimeStatus : int {
  UNKNOWN = 20,
  APPROXIMATE = 60,
  COARSEADJUSTING = 80,
  COARSE = 100,
  COARSESTEERING = 120,
  FREEWHEELING = 130,
  FINEADJUSTING = 140,
  FINE = 160,
  FINEBACKUPSTEERING = 170,
  FINESTEERING = 180,
  SATTIME = 200
};
bool TimeStatus_IsValid(int value);
constexpr TimeStatus TimeStatus_MIN = UNKNOWN;
constexpr TimeStatus TimeStatus_MAX = SATTIME;
constexpr int TimeStatus_ARRAYSIZE = TimeStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeStatus_descriptor();
template<typename T>
inline const std::string& TimeStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimeStatus_descriptor(), enum_t_value);
}
inline bool TimeStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeStatus>(
    TimeStatus_descriptor(), name, value);
}
enum SolutionStatus : int {
  SOL_COMPUTED = 0,
  INSUFFICIENT_OBS = 1,
  NO_CONVERGENCE = 2,
  SINGULARITY = 3,
  COV_TRACE = 4,
  TEST_DIST = 5,
  COLD_START = 6,
  V_H_LIMIT = 7,
  VARIANCE = 8,
  RESIDUALS = 9,
  INTEGRITY_WARNING = 13,
  PENDING = 18,
  INVALID_FIX = 19,
  UNAUTHORIZED = 20,
  INVALID_RATE = 22
};
bool SolutionStatus_IsValid(int value);
constexpr SolutionStatus SolutionStatus_MIN = SOL_COMPUTED;
constexpr SolutionStatus SolutionStatus_MAX = INVALID_RATE;
constexpr int SolutionStatus_ARRAYSIZE = SolutionStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SolutionStatus_descriptor();
template<typename T>
inline const std::string& SolutionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SolutionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SolutionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SolutionStatus_descriptor(), enum_t_value);
}
inline bool SolutionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SolutionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SolutionStatus>(
    SolutionStatus_descriptor(), name, value);
}
enum PositonVelocityType : int {
  NONE = 0,
  FIXEDPOS = 1,
  FIXEDHEIGHT = 2,
  FLOATCONV = 4,
  WIDELANE = 5,
  NARROWLANE = 6,
  DOPPLER_VELOCITY = 8,
  SINGLE = 16,
  PSRDIFF = 17,
  WAAS = 18,
  PROPAGATED = 19,
  L1_FLOAT = 32,
  NARROW_FLOAT = 34,
  L1_INT = 48,
  WIDE_INT = 49,
  NARROW_INT = 50,
  RTK_DIRECT_INS = 51,
  INS_SBAS = 52,
  INS_PSRSP = 53,
  INS_PSRDIFF = 54,
  INS_RTKFLOAT = 55,
  INS_RTKFIXED = 56,
  PPP_CONVERGING = 68,
  PPP = 69,
  OPERATIONAL = 70,
  WARNING = 71,
  OUT_OF_BOUNDS = 72,
  INS_PPP_CONVERGING = 73,
  INS_PPP = 74,
  PPP_BASIC_CONVERGING = 77,
  PPP_BASIC = 78,
  INS_PPP_BASIC_CONVERGING = 79,
  INS_PPP_BASIC = 80
};
bool PositonVelocityType_IsValid(int value);
constexpr PositonVelocityType PositonVelocityType_MIN = NONE;
constexpr PositonVelocityType PositonVelocityType_MAX = INS_PPP_BASIC;
constexpr int PositonVelocityType_ARRAYSIZE = PositonVelocityType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PositonVelocityType_descriptor();
template<typename T>
inline const std::string& PositonVelocityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PositonVelocityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PositonVelocityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PositonVelocityType_descriptor(), enum_t_value);
}
inline bool PositonVelocityType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PositonVelocityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PositonVelocityType>(
    PositonVelocityType_descriptor(), name, value);
}
enum DatumID : int {
  WGS84 = 61,
  USER = 63
};
bool DatumID_IsValid(int value);
constexpr DatumID DatumID_MIN = WGS84;
constexpr DatumID DatumID_MAX = USER;
constexpr int DatumID_ARRAYSIZE = DatumID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DatumID_descriptor();
template<typename T>
inline const std::string& DatumID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DatumID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DatumID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DatumID_descriptor(), enum_t_value);
}
inline bool DatumID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DatumID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DatumID>(
    DatumID_descriptor(), name, value);
}
enum InsStatus : int {
  INS_INACTIVE = 0,
  INS_ALIGNING = 1,
  INS_HIGH_VARIANCE = 2,
  INS_SOLUTION_GOOD = 3,
  INS_SOLUTION_FREE = 6,
  INS_ALIGNMENT_COMPLETE = 7,
  DETERMINING_ORIENTATION = 8,
  WAITING_INITIALPOS = 9,
  WAITING_AZIMUTH = 10,
  INITIALIZING_BIASES = 11,
  MOTION_DETECT = 12,
  WAITING_ALIGNMENTORIENTATION = 14
};
bool InsStatus_IsValid(int value);
constexpr InsStatus InsStatus_MIN = INS_INACTIVE;
constexpr InsStatus InsStatus_MAX = WAITING_ALIGNMENTORIENTATION;
constexpr int InsStatus_ARRAYSIZE = InsStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InsStatus_descriptor();
template<typename T>
inline const std::string& InsStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InsStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InsStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InsStatus_descriptor(), enum_t_value);
}
inline bool InsStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InsStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InsStatus>(
    InsStatus_descriptor(), name, value);
}
// ===================================================================

class LogHeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.drivers.rawgnss.LogHeader) */ {
 public:
  inline LogHeader() : LogHeader(nullptr) {}
  virtual ~LogHeader();

  LogHeader(const LogHeader& from);
  LogHeader(LogHeader&& from) noexcept
    : LogHeader() {
    *this = ::std::move(from);
  }

  inline LogHeader& operator=(const LogHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogHeader& operator=(LogHeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogHeader& default_instance();

  static inline const LogHeader* internal_default_instance() {
    return reinterpret_cast<const LogHeader*>(
               &_LogHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LogHeader& a, LogHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(LogHeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogHeader* New() const final {
    return CreateMaybeMessage<LogHeader>(nullptr);
  }

  LogHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogHeader& from);
  void MergeFrom(const LogHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.drivers.rawgnss.LogHeader";
  }
  protected:
  explicit LogHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto);
    return ::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kSyncFieldNumber = 1,
  };
  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int32 sync = 1 [default = 35];
  bool has_sync() const;
  private:
  bool _internal_has_sync() const;
  public:
  void clear_sync();
  ::PROTOBUF_NAMESPACE_ID::int32 sync() const;
  void set_sync(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sync() const;
  void _internal_set_sync(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:civ.drivers.rawgnss.LogHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 sync_;
  friend struct ::TableStruct_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto;
};
// -------------------------------------------------------------------

class GnssHeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.drivers.rawgnss.GnssHeader) */ {
 public:
  inline GnssHeader() : GnssHeader(nullptr) {}
  virtual ~GnssHeader();

  GnssHeader(const GnssHeader& from);
  GnssHeader(GnssHeader&& from) noexcept
    : GnssHeader() {
    *this = ::std::move(from);
  }

  inline GnssHeader& operator=(const GnssHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline GnssHeader& operator=(GnssHeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GnssHeader& default_instance();

  static inline const GnssHeader* internal_default_instance() {
    return reinterpret_cast<const GnssHeader*>(
               &_GnssHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GnssHeader& a, GnssHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(GnssHeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GnssHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GnssHeader* New() const final {
    return CreateMaybeMessage<GnssHeader>(nullptr);
  }

  GnssHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GnssHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GnssHeader& from);
  void MergeFrom(const GnssHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GnssHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.drivers.rawgnss.GnssHeader";
  }
  protected:
  explicit GnssHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto);
    return ::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 2,
    kLogHeaderFieldNumber = 1,
    kSequenceFieldNumber = 3,
    kIdleTimeFieldNumber = 4,
    kGpsSecondsFieldNumber = 7,
    kWeekNumFieldNumber = 6,
    kReceiverStatusFieldNumber = 8,
    kReservedFieldNumber = 9,
    kReceiverSwVersionFieldNumber = 10,
    kReceivedTimestampFieldNumber = 11,
    kTimeStatusFieldNumber = 5,
  };
  // required string port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  const std::string& port() const;
  void set_port(const std::string& value);
  void set_port(std::string&& value);
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  std::string* mutable_port();
  std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // required .civ.drivers.rawgnss.LogHeader log_header = 1;
  bool has_log_header() const;
  private:
  bool _internal_has_log_header() const;
  public:
  void clear_log_header();
  const ::civ::drivers::rawgnss::LogHeader& log_header() const;
  ::civ::drivers::rawgnss::LogHeader* release_log_header();
  ::civ::drivers::rawgnss::LogHeader* mutable_log_header();
  void set_allocated_log_header(::civ::drivers::rawgnss::LogHeader* log_header);
  private:
  const ::civ::drivers::rawgnss::LogHeader& _internal_log_header() const;
  ::civ::drivers::rawgnss::LogHeader* _internal_mutable_log_header();
  public:
  void unsafe_arena_set_allocated_log_header(
      ::civ::drivers::rawgnss::LogHeader* log_header);
  ::civ::drivers::rawgnss::LogHeader* unsafe_arena_release_log_header();

  // required uint32 sequence = 3;
  bool has_sequence() const;
  private:
  bool _internal_has_sequence() const;
  public:
  void clear_sequence();
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence() const;
  void set_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sequence() const;
  void _internal_set_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required float idle_time = 4;
  bool has_idle_time() const;
  private:
  bool _internal_has_idle_time() const;
  public:
  void clear_idle_time();
  float idle_time() const;
  void set_idle_time(float value);
  private:
  float _internal_idle_time() const;
  void _internal_set_idle_time(float value);
  public:

  // required double gps_seconds = 7;
  bool has_gps_seconds() const;
  private:
  bool _internal_has_gps_seconds() const;
  public:
  void clear_gps_seconds();
  double gps_seconds() const;
  void set_gps_seconds(double value);
  private:
  double _internal_gps_seconds() const;
  void _internal_set_gps_seconds(double value);
  public:

  // required uint32 week_num = 6;
  bool has_week_num() const;
  private:
  bool _internal_has_week_num() const;
  public:
  void clear_week_num();
  ::PROTOBUF_NAMESPACE_ID::uint32 week_num() const;
  void set_week_num(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_week_num() const;
  void _internal_set_week_num(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 receiver_status = 8;
  bool has_receiver_status() const;
  private:
  bool _internal_has_receiver_status() const;
  public:
  void clear_receiver_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 receiver_status() const;
  void set_receiver_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_receiver_status() const;
  void _internal_set_receiver_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 reserved = 9 [default = 0];
  bool has_reserved() const;
  private:
  bool _internal_has_reserved() const;
  public:
  void clear_reserved();
  ::PROTOBUF_NAMESPACE_ID::uint32 reserved() const;
  void set_reserved(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_reserved() const;
  void _internal_set_reserved(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 receiver_sw_version = 10;
  bool has_receiver_sw_version() const;
  private:
  bool _internal_has_receiver_sw_version() const;
  public:
  void clear_receiver_sw_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 receiver_sw_version() const;
  void set_receiver_sw_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_receiver_sw_version() const;
  void _internal_set_receiver_sw_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional double received_timestamp = 11;
  bool has_received_timestamp() const;
  private:
  bool _internal_has_received_timestamp() const;
  public:
  void clear_received_timestamp();
  double received_timestamp() const;
  void set_received_timestamp(double value);
  private:
  double _internal_received_timestamp() const;
  void _internal_set_received_timestamp(double value);
  public:

  // required .civ.drivers.rawgnss.TimeStatus time_status = 5;
  bool has_time_status() const;
  private:
  bool _internal_has_time_status() const;
  public:
  void clear_time_status();
  ::civ::drivers::rawgnss::TimeStatus time_status() const;
  void set_time_status(::civ::drivers::rawgnss::TimeStatus value);
  private:
  ::civ::drivers::rawgnss::TimeStatus _internal_time_status() const;
  void _internal_set_time_status(::civ::drivers::rawgnss::TimeStatus value);
  public:

  // @@protoc_insertion_point(class_scope:civ.drivers.rawgnss.GnssHeader)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
  ::civ::drivers::rawgnss::LogHeader* log_header_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_;
  float idle_time_;
  double gps_seconds_;
  ::PROTOBUF_NAMESPACE_ID::uint32 week_num_;
  ::PROTOBUF_NAMESPACE_ID::uint32 receiver_status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 reserved_;
  ::PROTOBUF_NAMESPACE_ID::uint32 receiver_sw_version_;
  double received_timestamp_;
  int time_status_;
  friend struct ::TableStruct_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto;
};
// -------------------------------------------------------------------

class Bestpos PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.drivers.rawgnss.Bestpos) */ {
 public:
  inline Bestpos() : Bestpos(nullptr) {}
  virtual ~Bestpos();

  Bestpos(const Bestpos& from);
  Bestpos(Bestpos&& from) noexcept
    : Bestpos() {
    *this = ::std::move(from);
  }

  inline Bestpos& operator=(const Bestpos& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bestpos& operator=(Bestpos&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Bestpos& default_instance();

  static inline const Bestpos* internal_default_instance() {
    return reinterpret_cast<const Bestpos*>(
               &_Bestpos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Bestpos& a, Bestpos& b) {
    a.Swap(&b);
  }
  inline void Swap(Bestpos* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bestpos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bestpos* New() const final {
    return CreateMaybeMessage<Bestpos>(nullptr);
  }

  Bestpos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bestpos>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Bestpos& from);
  void MergeFrom(const Bestpos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bestpos* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.drivers.rawgnss.Bestpos";
  }
  protected:
  explicit Bestpos(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto);
    return ::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseStationIdFieldNumber = 12,
    kGnssHeaderFieldNumber = 1,
    kSolutionStatusFieldNumber = 2,
    kPosTypeFieldNumber = 3,
    kLatitudeInDegreeFieldNumber = 4,
    kLongitudeInDegreeFieldNumber = 5,
    kHeightInMetresFieldNumber = 6,
    kUndulationFieldNumber = 7,
    kLatitudeStdDevFieldNumber = 9,
    kLongitudeStdDevFieldNumber = 10,
    kHeightStdDevFieldNumber = 11,
    kDiffAgeInSecondsFieldNumber = 13,
    kSolutionAgeInSecondsFieldNumber = 14,
    kNumOfSatellitesTrackedFieldNumber = 15,
    kNumOfSatellitesUsedFieldNumber = 16,
    kNumOfSatellitesWithL1E1B1FieldNumber = 17,
    kNumOfSatellitesWithMultiFreqFieldNumber = 18,
    kReservedFieldNumber = 19,
    kExtendedSolutionStatusFieldNumber = 20,
    kGalileoBeidouSigMaskFieldNumber = 21,
    kGpsGlonassSigMaskFieldNumber = 22,
    kDatumIdFieldNumber = 8,
  };
  // required string base_station_id = 12;
  bool has_base_station_id() const;
  private:
  bool _internal_has_base_station_id() const;
  public:
  void clear_base_station_id();
  const std::string& base_station_id() const;
  void set_base_station_id(const std::string& value);
  void set_base_station_id(std::string&& value);
  void set_base_station_id(const char* value);
  void set_base_station_id(const char* value, size_t size);
  std::string* mutable_base_station_id();
  std::string* release_base_station_id();
  void set_allocated_base_station_id(std::string* base_station_id);
  private:
  const std::string& _internal_base_station_id() const;
  void _internal_set_base_station_id(const std::string& value);
  std::string* _internal_mutable_base_station_id();
  public:

  // required .civ.drivers.rawgnss.GnssHeader gnss_header = 1;
  bool has_gnss_header() const;
  private:
  bool _internal_has_gnss_header() const;
  public:
  void clear_gnss_header();
  const ::civ::drivers::rawgnss::GnssHeader& gnss_header() const;
  ::civ::drivers::rawgnss::GnssHeader* release_gnss_header();
  ::civ::drivers::rawgnss::GnssHeader* mutable_gnss_header();
  void set_allocated_gnss_header(::civ::drivers::rawgnss::GnssHeader* gnss_header);
  private:
  const ::civ::drivers::rawgnss::GnssHeader& _internal_gnss_header() const;
  ::civ::drivers::rawgnss::GnssHeader* _internal_mutable_gnss_header();
  public:
  void unsafe_arena_set_allocated_gnss_header(
      ::civ::drivers::rawgnss::GnssHeader* gnss_header);
  ::civ::drivers::rawgnss::GnssHeader* unsafe_arena_release_gnss_header();

  // optional .civ.drivers.rawgnss.SolutionStatus solution_status = 2;
  bool has_solution_status() const;
  private:
  bool _internal_has_solution_status() const;
  public:
  void clear_solution_status();
  ::civ::drivers::rawgnss::SolutionStatus solution_status() const;
  void set_solution_status(::civ::drivers::rawgnss::SolutionStatus value);
  private:
  ::civ::drivers::rawgnss::SolutionStatus _internal_solution_status() const;
  void _internal_set_solution_status(::civ::drivers::rawgnss::SolutionStatus value);
  public:

  // optional .civ.drivers.rawgnss.PositonVelocityType pos_type = 3;
  bool has_pos_type() const;
  private:
  bool _internal_has_pos_type() const;
  public:
  void clear_pos_type();
  ::civ::drivers::rawgnss::PositonVelocityType pos_type() const;
  void set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value);
  private:
  ::civ::drivers::rawgnss::PositonVelocityType _internal_pos_type() const;
  void _internal_set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value);
  public:

  // required double latitude_in_degree = 4;
  bool has_latitude_in_degree() const;
  private:
  bool _internal_has_latitude_in_degree() const;
  public:
  void clear_latitude_in_degree();
  double latitude_in_degree() const;
  void set_latitude_in_degree(double value);
  private:
  double _internal_latitude_in_degree() const;
  void _internal_set_latitude_in_degree(double value);
  public:

  // required double longitude_in_degree = 5;
  bool has_longitude_in_degree() const;
  private:
  bool _internal_has_longitude_in_degree() const;
  public:
  void clear_longitude_in_degree();
  double longitude_in_degree() const;
  void set_longitude_in_degree(double value);
  private:
  double _internal_longitude_in_degree() const;
  void _internal_set_longitude_in_degree(double value);
  public:

  // required double height_in_metres = 6;
  bool has_height_in_metres() const;
  private:
  bool _internal_has_height_in_metres() const;
  public:
  void clear_height_in_metres();
  double height_in_metres() const;
  void set_height_in_metres(double value);
  private:
  double _internal_height_in_metres() const;
  void _internal_set_height_in_metres(double value);
  public:

  // required float undulation = 7;
  bool has_undulation() const;
  private:
  bool _internal_has_undulation() const;
  public:
  void clear_undulation();
  float undulation() const;
  void set_undulation(float value);
  private:
  float _internal_undulation() const;
  void _internal_set_undulation(float value);
  public:

  // required float latitude_std_dev = 9;
  bool has_latitude_std_dev() const;
  private:
  bool _internal_has_latitude_std_dev() const;
  public:
  void clear_latitude_std_dev();
  float latitude_std_dev() const;
  void set_latitude_std_dev(float value);
  private:
  float _internal_latitude_std_dev() const;
  void _internal_set_latitude_std_dev(float value);
  public:

  // required float longitude_std_dev = 10;
  bool has_longitude_std_dev() const;
  private:
  bool _internal_has_longitude_std_dev() const;
  public:
  void clear_longitude_std_dev();
  float longitude_std_dev() const;
  void set_longitude_std_dev(float value);
  private:
  float _internal_longitude_std_dev() const;
  void _internal_set_longitude_std_dev(float value);
  public:

  // required float height_std_dev = 11;
  bool has_height_std_dev() const;
  private:
  bool _internal_has_height_std_dev() const;
  public:
  void clear_height_std_dev();
  float height_std_dev() const;
  void set_height_std_dev(float value);
  private:
  float _internal_height_std_dev() const;
  void _internal_set_height_std_dev(float value);
  public:

  // required float diff_age_in_seconds = 13;
  bool has_diff_age_in_seconds() const;
  private:
  bool _internal_has_diff_age_in_seconds() const;
  public:
  void clear_diff_age_in_seconds();
  float diff_age_in_seconds() const;
  void set_diff_age_in_seconds(float value);
  private:
  float _internal_diff_age_in_seconds() const;
  void _internal_set_diff_age_in_seconds(float value);
  public:

  // required float solution_age_in_seconds = 14;
  bool has_solution_age_in_seconds() const;
  private:
  bool _internal_has_solution_age_in_seconds() const;
  public:
  void clear_solution_age_in_seconds();
  float solution_age_in_seconds() const;
  void set_solution_age_in_seconds(float value);
  private:
  float _internal_solution_age_in_seconds() const;
  void _internal_set_solution_age_in_seconds(float value);
  public:

  // required int32 num_of_satellites_tracked = 15;
  bool has_num_of_satellites_tracked() const;
  private:
  bool _internal_has_num_of_satellites_tracked() const;
  public:
  void clear_num_of_satellites_tracked();
  ::PROTOBUF_NAMESPACE_ID::int32 num_of_satellites_tracked() const;
  void set_num_of_satellites_tracked(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_of_satellites_tracked() const;
  void _internal_set_num_of_satellites_tracked(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 num_of_satellites_used = 16;
  bool has_num_of_satellites_used() const;
  private:
  bool _internal_has_num_of_satellites_used() const;
  public:
  void clear_num_of_satellites_used();
  ::PROTOBUF_NAMESPACE_ID::int32 num_of_satellites_used() const;
  void set_num_of_satellites_used(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_of_satellites_used() const;
  void _internal_set_num_of_satellites_used(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 num_of_satellites_with_l1_e1_b1 = 17;
  bool has_num_of_satellites_with_l1_e1_b1() const;
  private:
  bool _internal_has_num_of_satellites_with_l1_e1_b1() const;
  public:
  void clear_num_of_satellites_with_l1_e1_b1();
  ::PROTOBUF_NAMESPACE_ID::int32 num_of_satellites_with_l1_e1_b1() const;
  void set_num_of_satellites_with_l1_e1_b1(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_of_satellites_with_l1_e1_b1() const;
  void _internal_set_num_of_satellites_with_l1_e1_b1(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 num_of_satellites_with_multi_freq = 18;
  bool has_num_of_satellites_with_multi_freq() const;
  private:
  bool _internal_has_num_of_satellites_with_multi_freq() const;
  public:
  void clear_num_of_satellites_with_multi_freq();
  ::PROTOBUF_NAMESPACE_ID::int32 num_of_satellites_with_multi_freq() const;
  void set_num_of_satellites_with_multi_freq(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_of_satellites_with_multi_freq() const;
  void _internal_set_num_of_satellites_with_multi_freq(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 reserved = 19 [default = 0];
  bool has_reserved() const;
  private:
  bool _internal_has_reserved() const;
  public:
  void clear_reserved();
  ::PROTOBUF_NAMESPACE_ID::int32 reserved() const;
  void set_reserved(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_reserved() const;
  void _internal_set_reserved(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 extended_solution_status = 20;
  bool has_extended_solution_status() const;
  private:
  bool _internal_has_extended_solution_status() const;
  public:
  void clear_extended_solution_status();
  ::PROTOBUF_NAMESPACE_ID::int32 extended_solution_status() const;
  void set_extended_solution_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_extended_solution_status() const;
  void _internal_set_extended_solution_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 galileo_beidou_sig_mask = 21;
  bool has_galileo_beidou_sig_mask() const;
  private:
  bool _internal_has_galileo_beidou_sig_mask() const;
  public:
  void clear_galileo_beidou_sig_mask();
  ::PROTOBUF_NAMESPACE_ID::int32 galileo_beidou_sig_mask() const;
  void set_galileo_beidou_sig_mask(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_galileo_beidou_sig_mask() const;
  void _internal_set_galileo_beidou_sig_mask(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 gps_glonass_sig_mask = 22;
  bool has_gps_glonass_sig_mask() const;
  private:
  bool _internal_has_gps_glonass_sig_mask() const;
  public:
  void clear_gps_glonass_sig_mask();
  ::PROTOBUF_NAMESPACE_ID::int32 gps_glonass_sig_mask() const;
  void set_gps_glonass_sig_mask(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gps_glonass_sig_mask() const;
  void _internal_set_gps_glonass_sig_mask(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required .civ.drivers.rawgnss.DatumID datum_id = 8;
  bool has_datum_id() const;
  private:
  bool _internal_has_datum_id() const;
  public:
  void clear_datum_id();
  ::civ::drivers::rawgnss::DatumID datum_id() const;
  void set_datum_id(::civ::drivers::rawgnss::DatumID value);
  private:
  ::civ::drivers::rawgnss::DatumID _internal_datum_id() const;
  void _internal_set_datum_id(::civ::drivers::rawgnss::DatumID value);
  public:

  // @@protoc_insertion_point(class_scope:civ.drivers.rawgnss.Bestpos)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_station_id_;
  ::civ::drivers::rawgnss::GnssHeader* gnss_header_;
  int solution_status_;
  int pos_type_;
  double latitude_in_degree_;
  double longitude_in_degree_;
  double height_in_metres_;
  float undulation_;
  float latitude_std_dev_;
  float longitude_std_dev_;
  float height_std_dev_;
  float diff_age_in_seconds_;
  float solution_age_in_seconds_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_of_satellites_tracked_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_of_satellites_used_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_of_satellites_with_l1_e1_b1_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_of_satellites_with_multi_freq_;
  ::PROTOBUF_NAMESPACE_ID::int32 reserved_;
  ::PROTOBUF_NAMESPACE_ID::int32 extended_solution_status_;
  ::PROTOBUF_NAMESPACE_ID::int32 galileo_beidou_sig_mask_;
  ::PROTOBUF_NAMESPACE_ID::int32 gps_glonass_sig_mask_;
  int datum_id_;
  friend struct ::TableStruct_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto;
};
// -------------------------------------------------------------------

class GNGGA PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.drivers.rawgnss.GNGGA) */ {
 public:
  inline GNGGA() : GNGGA(nullptr) {}
  virtual ~GNGGA();

  GNGGA(const GNGGA& from);
  GNGGA(GNGGA&& from) noexcept
    : GNGGA() {
    *this = ::std::move(from);
  }

  inline GNGGA& operator=(const GNGGA& from) {
    CopyFrom(from);
    return *this;
  }
  inline GNGGA& operator=(GNGGA&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GNGGA& default_instance();

  static inline const GNGGA* internal_default_instance() {
    return reinterpret_cast<const GNGGA*>(
               &_GNGGA_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GNGGA& a, GNGGA& b) {
    a.Swap(&b);
  }
  inline void Swap(GNGGA* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GNGGA* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GNGGA* New() const final {
    return CreateMaybeMessage<GNGGA>(nullptr);
  }

  GNGGA* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GNGGA>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GNGGA& from);
  void MergeFrom(const GNGGA& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GNGGA* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.drivers.rawgnss.GNGGA";
  }
  protected:
  explicit GNGGA(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto);
    return ::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GNGGA_LatitudeDirection LatitudeDirection;
  static constexpr LatitudeDirection North =
    GNGGA_LatitudeDirection_North;
  static constexpr LatitudeDirection South =
    GNGGA_LatitudeDirection_South;
  static inline bool LatitudeDirection_IsValid(int value) {
    return GNGGA_LatitudeDirection_IsValid(value);
  }
  static constexpr LatitudeDirection LatitudeDirection_MIN =
    GNGGA_LatitudeDirection_LatitudeDirection_MIN;
  static constexpr LatitudeDirection LatitudeDirection_MAX =
    GNGGA_LatitudeDirection_LatitudeDirection_MAX;
  static constexpr int LatitudeDirection_ARRAYSIZE =
    GNGGA_LatitudeDirection_LatitudeDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LatitudeDirection_descriptor() {
    return GNGGA_LatitudeDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& LatitudeDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LatitudeDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LatitudeDirection_Name.");
    return GNGGA_LatitudeDirection_Name(enum_t_value);
  }
  static inline bool LatitudeDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LatitudeDirection* value) {
    return GNGGA_LatitudeDirection_Parse(name, value);
  }

  typedef GNGGA_LongitudeDirection LongitudeDirection;
  static constexpr LongitudeDirection East =
    GNGGA_LongitudeDirection_East;
  static constexpr LongitudeDirection West =
    GNGGA_LongitudeDirection_West;
  static inline bool LongitudeDirection_IsValid(int value) {
    return GNGGA_LongitudeDirection_IsValid(value);
  }
  static constexpr LongitudeDirection LongitudeDirection_MIN =
    GNGGA_LongitudeDirection_LongitudeDirection_MIN;
  static constexpr LongitudeDirection LongitudeDirection_MAX =
    GNGGA_LongitudeDirection_LongitudeDirection_MAX;
  static constexpr int LongitudeDirection_ARRAYSIZE =
    GNGGA_LongitudeDirection_LongitudeDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LongitudeDirection_descriptor() {
    return GNGGA_LongitudeDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& LongitudeDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LongitudeDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LongitudeDirection_Name.");
    return GNGGA_LongitudeDirection_Name(enum_t_value);
  }
  static inline bool LongitudeDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LongitudeDirection* value) {
    return GNGGA_LongitudeDirection_Parse(name, value);
  }

  typedef GNGGA_UnitTypes UnitTypes;
  static constexpr UnitTypes METRES =
    GNGGA_UnitTypes_METRES;
  static inline bool UnitTypes_IsValid(int value) {
    return GNGGA_UnitTypes_IsValid(value);
  }
  static constexpr UnitTypes UnitTypes_MIN =
    GNGGA_UnitTypes_UnitTypes_MIN;
  static constexpr UnitTypes UnitTypes_MAX =
    GNGGA_UnitTypes_UnitTypes_MAX;
  static constexpr int UnitTypes_ARRAYSIZE =
    GNGGA_UnitTypes_UnitTypes_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UnitTypes_descriptor() {
    return GNGGA_UnitTypes_descriptor();
  }
  template<typename T>
  static inline const std::string& UnitTypes_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UnitTypes>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UnitTypes_Name.");
    return GNGGA_UnitTypes_Name(enum_t_value);
  }
  static inline bool UnitTypes_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UnitTypes* value) {
    return GNGGA_UnitTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUtcHhmmssFieldNumber = 11,
    kLogHeaderFieldNumber = 1,
    kUtcInSecondsFieldNumber = 2,
    kLatitudeFieldNumber = 3,
    kLatitudeDirFieldNumber = 4,
    kLongitudeFieldNumber = 5,
    kLongitudeDirFieldNumber = 6,
    kQualityFieldNumber = 7,
    kNumOfSatellitesUsedFieldNumber = 8,
    kHdopFieldNumber = 9,
    kAltFieldNumber = 10,
    kLatitudeDegFieldNumber = 12,
    kLongitudeDegFieldNumber = 13,
  };
  // optional string utc_hhmmss = 11;
  bool has_utc_hhmmss() const;
  private:
  bool _internal_has_utc_hhmmss() const;
  public:
  void clear_utc_hhmmss();
  const std::string& utc_hhmmss() const;
  void set_utc_hhmmss(const std::string& value);
  void set_utc_hhmmss(std::string&& value);
  void set_utc_hhmmss(const char* value);
  void set_utc_hhmmss(const char* value, size_t size);
  std::string* mutable_utc_hhmmss();
  std::string* release_utc_hhmmss();
  void set_allocated_utc_hhmmss(std::string* utc_hhmmss);
  private:
  const std::string& _internal_utc_hhmmss() const;
  void _internal_set_utc_hhmmss(const std::string& value);
  std::string* _internal_mutable_utc_hhmmss();
  public:

  // optional .civ.drivers.rawgnss.LogHeader log_header = 1;
  bool has_log_header() const;
  private:
  bool _internal_has_log_header() const;
  public:
  void clear_log_header();
  const ::civ::drivers::rawgnss::LogHeader& log_header() const;
  ::civ::drivers::rawgnss::LogHeader* release_log_header();
  ::civ::drivers::rawgnss::LogHeader* mutable_log_header();
  void set_allocated_log_header(::civ::drivers::rawgnss::LogHeader* log_header);
  private:
  const ::civ::drivers::rawgnss::LogHeader& _internal_log_header() const;
  ::civ::drivers::rawgnss::LogHeader* _internal_mutable_log_header();
  public:
  void unsafe_arena_set_allocated_log_header(
      ::civ::drivers::rawgnss::LogHeader* log_header);
  ::civ::drivers::rawgnss::LogHeader* unsafe_arena_release_log_header();

  // optional double utc_in_seconds = 2;
  bool has_utc_in_seconds() const;
  private:
  bool _internal_has_utc_in_seconds() const;
  public:
  void clear_utc_in_seconds();
  double utc_in_seconds() const;
  void set_utc_in_seconds(double value);
  private:
  double _internal_utc_in_seconds() const;
  void _internal_set_utc_in_seconds(double value);
  public:

  // optional float latitude = 3;
  bool has_latitude() const;
  private:
  bool _internal_has_latitude() const;
  public:
  void clear_latitude();
  float latitude() const;
  void set_latitude(float value);
  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);
  public:

  // optional .civ.drivers.rawgnss.GNGGA.LatitudeDirection latitude_dir = 4;
  bool has_latitude_dir() const;
  private:
  bool _internal_has_latitude_dir() const;
  public:
  void clear_latitude_dir();
  ::civ::drivers::rawgnss::GNGGA_LatitudeDirection latitude_dir() const;
  void set_latitude_dir(::civ::drivers::rawgnss::GNGGA_LatitudeDirection value);
  private:
  ::civ::drivers::rawgnss::GNGGA_LatitudeDirection _internal_latitude_dir() const;
  void _internal_set_latitude_dir(::civ::drivers::rawgnss::GNGGA_LatitudeDirection value);
  public:

  // optional float longitude = 5;
  bool has_longitude() const;
  private:
  bool _internal_has_longitude() const;
  public:
  void clear_longitude();
  float longitude() const;
  void set_longitude(float value);
  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);
  public:

  // optional .civ.drivers.rawgnss.GNGGA.LongitudeDirection longitude_dir = 6;
  bool has_longitude_dir() const;
  private:
  bool _internal_has_longitude_dir() const;
  public:
  void clear_longitude_dir();
  ::civ::drivers::rawgnss::GNGGA_LongitudeDirection longitude_dir() const;
  void set_longitude_dir(::civ::drivers::rawgnss::GNGGA_LongitudeDirection value);
  private:
  ::civ::drivers::rawgnss::GNGGA_LongitudeDirection _internal_longitude_dir() const;
  void _internal_set_longitude_dir(::civ::drivers::rawgnss::GNGGA_LongitudeDirection value);
  public:

  // optional int32 quality = 7;
  bool has_quality() const;
  private:
  bool _internal_has_quality() const;
  public:
  void clear_quality();
  ::PROTOBUF_NAMESPACE_ID::int32 quality() const;
  void set_quality(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_quality() const;
  void _internal_set_quality(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 num_of_satellites_used = 8;
  bool has_num_of_satellites_used() const;
  private:
  bool _internal_has_num_of_satellites_used() const;
  public:
  void clear_num_of_satellites_used();
  ::PROTOBUF_NAMESPACE_ID::int32 num_of_satellites_used() const;
  void set_num_of_satellites_used(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_of_satellites_used() const;
  void _internal_set_num_of_satellites_used(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float hdop = 9;
  bool has_hdop() const;
  private:
  bool _internal_has_hdop() const;
  public:
  void clear_hdop();
  float hdop() const;
  void set_hdop(float value);
  private:
  float _internal_hdop() const;
  void _internal_set_hdop(float value);
  public:

  // optional float alt = 10;
  bool has_alt() const;
  private:
  bool _internal_has_alt() const;
  public:
  void clear_alt();
  float alt() const;
  void set_alt(float value);
  private:
  float _internal_alt() const;
  void _internal_set_alt(float value);
  public:

  // optional float latitude_deg = 12;
  bool has_latitude_deg() const;
  private:
  bool _internal_has_latitude_deg() const;
  public:
  void clear_latitude_deg();
  float latitude_deg() const;
  void set_latitude_deg(float value);
  private:
  float _internal_latitude_deg() const;
  void _internal_set_latitude_deg(float value);
  public:

  // optional float longitude_deg = 13;
  bool has_longitude_deg() const;
  private:
  bool _internal_has_longitude_deg() const;
  public:
  void clear_longitude_deg();
  float longitude_deg() const;
  void set_longitude_deg(float value);
  private:
  float _internal_longitude_deg() const;
  void _internal_set_longitude_deg(float value);
  public:

  // @@protoc_insertion_point(class_scope:civ.drivers.rawgnss.GNGGA)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utc_hhmmss_;
  ::civ::drivers::rawgnss::LogHeader* log_header_;
  double utc_in_seconds_;
  float latitude_;
  int latitude_dir_;
  float longitude_;
  int longitude_dir_;
  ::PROTOBUF_NAMESPACE_ID::int32 quality_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_of_satellites_used_;
  float hdop_;
  float alt_;
  float latitude_deg_;
  float longitude_deg_;
  friend struct ::TableStruct_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto;
};
// -------------------------------------------------------------------

class GNVTG PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.drivers.rawgnss.GNVTG) */ {
 public:
  inline GNVTG() : GNVTG(nullptr) {}
  virtual ~GNVTG();

  GNVTG(const GNVTG& from);
  GNVTG(GNVTG&& from) noexcept
    : GNVTG() {
    *this = ::std::move(from);
  }

  inline GNVTG& operator=(const GNVTG& from) {
    CopyFrom(from);
    return *this;
  }
  inline GNVTG& operator=(GNVTG&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GNVTG& default_instance();

  static inline const GNVTG* internal_default_instance() {
    return reinterpret_cast<const GNVTG*>(
               &_GNVTG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GNVTG& a, GNVTG& b) {
    a.Swap(&b);
  }
  inline void Swap(GNVTG* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GNVTG* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GNVTG* New() const final {
    return CreateMaybeMessage<GNVTG>(nullptr);
  }

  GNVTG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GNVTG>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GNVTG& from);
  void MergeFrom(const GNVTG& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GNVTG* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.drivers.rawgnss.GNVTG";
  }
  protected:
  explicit GNVTG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto);
    return ::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GNVTG_PositionSystemModeIndicator PositionSystemModeIndicator;
  static constexpr PositionSystemModeIndicator Autonomous =
    GNVTG_PositionSystemModeIndicator_Autonomous;
  static constexpr PositionSystemModeIndicator Differential =
    GNVTG_PositionSystemModeIndicator_Differential;
  static constexpr PositionSystemModeIndicator EstimatedMode =
    GNVTG_PositionSystemModeIndicator_EstimatedMode;
  static constexpr PositionSystemModeIndicator ManualInput =
    GNVTG_PositionSystemModeIndicator_ManualInput;
  static constexpr PositionSystemModeIndicator DataNotValid =
    GNVTG_PositionSystemModeIndicator_DataNotValid;
  static inline bool PositionSystemModeIndicator_IsValid(int value) {
    return GNVTG_PositionSystemModeIndicator_IsValid(value);
  }
  static constexpr PositionSystemModeIndicator PositionSystemModeIndicator_MIN =
    GNVTG_PositionSystemModeIndicator_PositionSystemModeIndicator_MIN;
  static constexpr PositionSystemModeIndicator PositionSystemModeIndicator_MAX =
    GNVTG_PositionSystemModeIndicator_PositionSystemModeIndicator_MAX;
  static constexpr int PositionSystemModeIndicator_ARRAYSIZE =
    GNVTG_PositionSystemModeIndicator_PositionSystemModeIndicator_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PositionSystemModeIndicator_descriptor() {
    return GNVTG_PositionSystemModeIndicator_descriptor();
  }
  template<typename T>
  static inline const std::string& PositionSystemModeIndicator_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PositionSystemModeIndicator>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PositionSystemModeIndicator_Name.");
    return GNVTG_PositionSystemModeIndicator_Name(enum_t_value);
  }
  static inline bool PositionSystemModeIndicator_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PositionSystemModeIndicator* value) {
    return GNVTG_PositionSystemModeIndicator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLogHeaderFieldNumber = 1,
    kTrackTrueFieldNumber = 2,
    kTrackMagFieldNumber = 4,
    kSpeedKnFieldNumber = 6,
    kTrueTrackIndicatorFieldNumber = 3,
    kMagneticTrackIndicatorFieldNumber = 5,
    kNauticalSpeedIndicatorFieldNumber = 7,
    kSpeedIndicatorFieldNumber = 9,
    kSpeedKmFieldNumber = 8,
    kModeIndicatorFieldNumber = 10,
  };
  // required .civ.drivers.rawgnss.LogHeader log_header = 1;
  bool has_log_header() const;
  private:
  bool _internal_has_log_header() const;
  public:
  void clear_log_header();
  const ::civ::drivers::rawgnss::LogHeader& log_header() const;
  ::civ::drivers::rawgnss::LogHeader* release_log_header();
  ::civ::drivers::rawgnss::LogHeader* mutable_log_header();
  void set_allocated_log_header(::civ::drivers::rawgnss::LogHeader* log_header);
  private:
  const ::civ::drivers::rawgnss::LogHeader& _internal_log_header() const;
  ::civ::drivers::rawgnss::LogHeader* _internal_mutable_log_header();
  public:
  void unsafe_arena_set_allocated_log_header(
      ::civ::drivers::rawgnss::LogHeader* log_header);
  ::civ::drivers::rawgnss::LogHeader* unsafe_arena_release_log_header();

  // required float track_true = 2;
  bool has_track_true() const;
  private:
  bool _internal_has_track_true() const;
  public:
  void clear_track_true();
  float track_true() const;
  void set_track_true(float value);
  private:
  float _internal_track_true() const;
  void _internal_set_track_true(float value);
  public:

  // required float track_mag = 4;
  bool has_track_mag() const;
  private:
  bool _internal_has_track_mag() const;
  public:
  void clear_track_mag();
  float track_mag() const;
  void set_track_mag(float value);
  private:
  float _internal_track_mag() const;
  void _internal_set_track_mag(float value);
  public:

  // required float speed_kn = 6;
  bool has_speed_kn() const;
  private:
  bool _internal_has_speed_kn() const;
  public:
  void clear_speed_kn();
  float speed_kn() const;
  void set_speed_kn(float value);
  private:
  float _internal_speed_kn() const;
  void _internal_set_speed_kn(float value);
  public:

  // required bool true_track_indicator = 3;
  bool has_true_track_indicator() const;
  private:
  bool _internal_has_true_track_indicator() const;
  public:
  void clear_true_track_indicator();
  bool true_track_indicator() const;
  void set_true_track_indicator(bool value);
  private:
  bool _internal_true_track_indicator() const;
  void _internal_set_true_track_indicator(bool value);
  public:

  // required bool magnetic_track_indicator = 5;
  bool has_magnetic_track_indicator() const;
  private:
  bool _internal_has_magnetic_track_indicator() const;
  public:
  void clear_magnetic_track_indicator();
  bool magnetic_track_indicator() const;
  void set_magnetic_track_indicator(bool value);
  private:
  bool _internal_magnetic_track_indicator() const;
  void _internal_set_magnetic_track_indicator(bool value);
  public:

  // required bool nautical_speed_indicator = 7;
  bool has_nautical_speed_indicator() const;
  private:
  bool _internal_has_nautical_speed_indicator() const;
  public:
  void clear_nautical_speed_indicator();
  bool nautical_speed_indicator() const;
  void set_nautical_speed_indicator(bool value);
  private:
  bool _internal_nautical_speed_indicator() const;
  void _internal_set_nautical_speed_indicator(bool value);
  public:

  // required bool speed_indicator = 9;
  bool has_speed_indicator() const;
  private:
  bool _internal_has_speed_indicator() const;
  public:
  void clear_speed_indicator();
  bool speed_indicator() const;
  void set_speed_indicator(bool value);
  private:
  bool _internal_speed_indicator() const;
  void _internal_set_speed_indicator(bool value);
  public:

  // required float speed_km = 8;
  bool has_speed_km() const;
  private:
  bool _internal_has_speed_km() const;
  public:
  void clear_speed_km();
  float speed_km() const;
  void set_speed_km(float value);
  private:
  float _internal_speed_km() const;
  void _internal_set_speed_km(float value);
  public:

  // required .civ.drivers.rawgnss.GNVTG.PositionSystemModeIndicator mode_indicator = 10;
  bool has_mode_indicator() const;
  private:
  bool _internal_has_mode_indicator() const;
  public:
  void clear_mode_indicator();
  ::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator mode_indicator() const;
  void set_mode_indicator(::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator value);
  private:
  ::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator _internal_mode_indicator() const;
  void _internal_set_mode_indicator(::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator value);
  public:

  // @@protoc_insertion_point(class_scope:civ.drivers.rawgnss.GNVTG)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::civ::drivers::rawgnss::LogHeader* log_header_;
  float track_true_;
  float track_mag_;
  float speed_kn_;
  bool true_track_indicator_;
  bool magnetic_track_indicator_;
  bool nautical_speed_indicator_;
  bool speed_indicator_;
  float speed_km_;
  int mode_indicator_;
  friend struct ::TableStruct_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto;
};
// -------------------------------------------------------------------

class Heading2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.drivers.rawgnss.Heading2) */ {
 public:
  inline Heading2() : Heading2(nullptr) {}
  virtual ~Heading2();

  Heading2(const Heading2& from);
  Heading2(Heading2&& from) noexcept
    : Heading2() {
    *this = ::std::move(from);
  }

  inline Heading2& operator=(const Heading2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heading2& operator=(Heading2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Heading2& default_instance();

  static inline const Heading2* internal_default_instance() {
    return reinterpret_cast<const Heading2*>(
               &_Heading2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Heading2& a, Heading2& b) {
    a.Swap(&b);
  }
  inline void Swap(Heading2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heading2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Heading2* New() const final {
    return CreateMaybeMessage<Heading2>(nullptr);
  }

  Heading2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Heading2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Heading2& from);
  void MergeFrom(const Heading2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heading2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.drivers.rawgnss.Heading2";
  }
  protected:
  explicit Heading2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto);
    return ::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoverReceiverIdFieldNumber = 10,
    kMasterReceiverIdFieldNumber = 11,
    kGnssHeaderFieldNumber = 1,
    kSolutionStatusFieldNumber = 2,
    kPosTypeFieldNumber = 3,
    kBaselineLengthInMetresFieldNumber = 4,
    kHeadingInDegreesFieldNumber = 5,
    kPitchInDegreesFieldNumber = 6,
    kReservedFieldNumber = 7,
    kHeadingStdDevFieldNumber = 8,
    kPitchStdDevFieldNumber = 9,
    kNumOfSatellitesTrackedFieldNumber = 12,
    kNumOfSatellitesInSolutionFieldNumber = 13,
    kNumOfSatellitesAboveMaskAngleFieldNumber = 14,
    kNumOfSatellitesAboveMaskAngleL2FieldNumber = 15,
    kSolutionSourceFieldNumber = 16,
    kExtendedSolutionStatusFieldNumber = 17,
    kGalileoBeidouSigMaskFieldNumber = 18,
    kGpsGlonassSigMaskFieldNumber = 19,
  };
  // required string rover_receiver_id = 10;
  bool has_rover_receiver_id() const;
  private:
  bool _internal_has_rover_receiver_id() const;
  public:
  void clear_rover_receiver_id();
  const std::string& rover_receiver_id() const;
  void set_rover_receiver_id(const std::string& value);
  void set_rover_receiver_id(std::string&& value);
  void set_rover_receiver_id(const char* value);
  void set_rover_receiver_id(const char* value, size_t size);
  std::string* mutable_rover_receiver_id();
  std::string* release_rover_receiver_id();
  void set_allocated_rover_receiver_id(std::string* rover_receiver_id);
  private:
  const std::string& _internal_rover_receiver_id() const;
  void _internal_set_rover_receiver_id(const std::string& value);
  std::string* _internal_mutable_rover_receiver_id();
  public:

  // required string master_receiver_id = 11;
  bool has_master_receiver_id() const;
  private:
  bool _internal_has_master_receiver_id() const;
  public:
  void clear_master_receiver_id();
  const std::string& master_receiver_id() const;
  void set_master_receiver_id(const std::string& value);
  void set_master_receiver_id(std::string&& value);
  void set_master_receiver_id(const char* value);
  void set_master_receiver_id(const char* value, size_t size);
  std::string* mutable_master_receiver_id();
  std::string* release_master_receiver_id();
  void set_allocated_master_receiver_id(std::string* master_receiver_id);
  private:
  const std::string& _internal_master_receiver_id() const;
  void _internal_set_master_receiver_id(const std::string& value);
  std::string* _internal_mutable_master_receiver_id();
  public:

  // required .civ.drivers.rawgnss.GnssHeader gnss_header = 1;
  bool has_gnss_header() const;
  private:
  bool _internal_has_gnss_header() const;
  public:
  void clear_gnss_header();
  const ::civ::drivers::rawgnss::GnssHeader& gnss_header() const;
  ::civ::drivers::rawgnss::GnssHeader* release_gnss_header();
  ::civ::drivers::rawgnss::GnssHeader* mutable_gnss_header();
  void set_allocated_gnss_header(::civ::drivers::rawgnss::GnssHeader* gnss_header);
  private:
  const ::civ::drivers::rawgnss::GnssHeader& _internal_gnss_header() const;
  ::civ::drivers::rawgnss::GnssHeader* _internal_mutable_gnss_header();
  public:
  void unsafe_arena_set_allocated_gnss_header(
      ::civ::drivers::rawgnss::GnssHeader* gnss_header);
  ::civ::drivers::rawgnss::GnssHeader* unsafe_arena_release_gnss_header();

  // optional .civ.drivers.rawgnss.SolutionStatus solution_status = 2;
  bool has_solution_status() const;
  private:
  bool _internal_has_solution_status() const;
  public:
  void clear_solution_status();
  ::civ::drivers::rawgnss::SolutionStatus solution_status() const;
  void set_solution_status(::civ::drivers::rawgnss::SolutionStatus value);
  private:
  ::civ::drivers::rawgnss::SolutionStatus _internal_solution_status() const;
  void _internal_set_solution_status(::civ::drivers::rawgnss::SolutionStatus value);
  public:

  // optional .civ.drivers.rawgnss.PositonVelocityType pos_type = 3;
  bool has_pos_type() const;
  private:
  bool _internal_has_pos_type() const;
  public:
  void clear_pos_type();
  ::civ::drivers::rawgnss::PositonVelocityType pos_type() const;
  void set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value);
  private:
  ::civ::drivers::rawgnss::PositonVelocityType _internal_pos_type() const;
  void _internal_set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value);
  public:

  // required float baseline_length_in_metres = 4;
  bool has_baseline_length_in_metres() const;
  private:
  bool _internal_has_baseline_length_in_metres() const;
  public:
  void clear_baseline_length_in_metres();
  float baseline_length_in_metres() const;
  void set_baseline_length_in_metres(float value);
  private:
  float _internal_baseline_length_in_metres() const;
  void _internal_set_baseline_length_in_metres(float value);
  public:

  // required float heading_in_degrees = 5;
  bool has_heading_in_degrees() const;
  private:
  bool _internal_has_heading_in_degrees() const;
  public:
  void clear_heading_in_degrees();
  float heading_in_degrees() const;
  void set_heading_in_degrees(float value);
  private:
  float _internal_heading_in_degrees() const;
  void _internal_set_heading_in_degrees(float value);
  public:

  // required float pitch_in_degrees = 6;
  bool has_pitch_in_degrees() const;
  private:
  bool _internal_has_pitch_in_degrees() const;
  public:
  void clear_pitch_in_degrees();
  float pitch_in_degrees() const;
  void set_pitch_in_degrees(float value);
  private:
  float _internal_pitch_in_degrees() const;
  void _internal_set_pitch_in_degrees(float value);
  public:

  // required float reserved = 7 [default = 0];
  bool has_reserved() const;
  private:
  bool _internal_has_reserved() const;
  public:
  void clear_reserved();
  float reserved() const;
  void set_reserved(float value);
  private:
  float _internal_reserved() const;
  void _internal_set_reserved(float value);
  public:

  // required float heading_std_dev = 8;
  bool has_heading_std_dev() const;
  private:
  bool _internal_has_heading_std_dev() const;
  public:
  void clear_heading_std_dev();
  float heading_std_dev() const;
  void set_heading_std_dev(float value);
  private:
  float _internal_heading_std_dev() const;
  void _internal_set_heading_std_dev(float value);
  public:

  // required float pitch_std_dev = 9;
  bool has_pitch_std_dev() const;
  private:
  bool _internal_has_pitch_std_dev() const;
  public:
  void clear_pitch_std_dev();
  float pitch_std_dev() const;
  void set_pitch_std_dev(float value);
  private:
  float _internal_pitch_std_dev() const;
  void _internal_set_pitch_std_dev(float value);
  public:

  // required uint32 num_of_satellites_tracked = 12;
  bool has_num_of_satellites_tracked() const;
  private:
  bool _internal_has_num_of_satellites_tracked() const;
  public:
  void clear_num_of_satellites_tracked();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_of_satellites_tracked() const;
  void set_num_of_satellites_tracked(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_of_satellites_tracked() const;
  void _internal_set_num_of_satellites_tracked(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 num_of_satellites_in_solution = 13;
  bool has_num_of_satellites_in_solution() const;
  private:
  bool _internal_has_num_of_satellites_in_solution() const;
  public:
  void clear_num_of_satellites_in_solution();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_of_satellites_in_solution() const;
  void set_num_of_satellites_in_solution(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_of_satellites_in_solution() const;
  void _internal_set_num_of_satellites_in_solution(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 num_of_satellites_above_mask_angle = 14;
  bool has_num_of_satellites_above_mask_angle() const;
  private:
  bool _internal_has_num_of_satellites_above_mask_angle() const;
  public:
  void clear_num_of_satellites_above_mask_angle();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_of_satellites_above_mask_angle() const;
  void set_num_of_satellites_above_mask_angle(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_of_satellites_above_mask_angle() const;
  void _internal_set_num_of_satellites_above_mask_angle(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 num_of_satellites_above_mask_angle_l2 = 15;
  bool has_num_of_satellites_above_mask_angle_l2() const;
  private:
  bool _internal_has_num_of_satellites_above_mask_angle_l2() const;
  public:
  void clear_num_of_satellites_above_mask_angle_l2();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_of_satellites_above_mask_angle_l2() const;
  void set_num_of_satellites_above_mask_angle_l2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_of_satellites_above_mask_angle_l2() const;
  void _internal_set_num_of_satellites_above_mask_angle_l2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 solution_source = 16;
  bool has_solution_source() const;
  private:
  bool _internal_has_solution_source() const;
  public:
  void clear_solution_source();
  ::PROTOBUF_NAMESPACE_ID::uint32 solution_source() const;
  void set_solution_source(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_solution_source() const;
  void _internal_set_solution_source(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 extended_solution_status = 17;
  bool has_extended_solution_status() const;
  private:
  bool _internal_has_extended_solution_status() const;
  public:
  void clear_extended_solution_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 extended_solution_status() const;
  void set_extended_solution_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_extended_solution_status() const;
  void _internal_set_extended_solution_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 galileo_beidou_sig_mask = 18;
  bool has_galileo_beidou_sig_mask() const;
  private:
  bool _internal_has_galileo_beidou_sig_mask() const;
  public:
  void clear_galileo_beidou_sig_mask();
  ::PROTOBUF_NAMESPACE_ID::uint32 galileo_beidou_sig_mask() const;
  void set_galileo_beidou_sig_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_galileo_beidou_sig_mask() const;
  void _internal_set_galileo_beidou_sig_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 gps_glonass_sig_mask = 19;
  bool has_gps_glonass_sig_mask() const;
  private:
  bool _internal_has_gps_glonass_sig_mask() const;
  public:
  void clear_gps_glonass_sig_mask();
  ::PROTOBUF_NAMESPACE_ID::uint32 gps_glonass_sig_mask() const;
  void set_gps_glonass_sig_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_gps_glonass_sig_mask() const;
  void _internal_set_gps_glonass_sig_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:civ.drivers.rawgnss.Heading2)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rover_receiver_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr master_receiver_id_;
  ::civ::drivers::rawgnss::GnssHeader* gnss_header_;
  int solution_status_;
  int pos_type_;
  float baseline_length_in_metres_;
  float heading_in_degrees_;
  float pitch_in_degrees_;
  float reserved_;
  float heading_std_dev_;
  float pitch_std_dev_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_of_satellites_tracked_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_of_satellites_in_solution_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_of_satellites_above_mask_angle_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_of_satellites_above_mask_angle_l2_;
  ::PROTOBUF_NAMESPACE_ID::uint32 solution_source_;
  ::PROTOBUF_NAMESPACE_ID::uint32 extended_solution_status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 galileo_beidou_sig_mask_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gps_glonass_sig_mask_;
  friend struct ::TableStruct_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto;
};
// -------------------------------------------------------------------

class RawImu PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.drivers.rawgnss.RawImu) */ {
 public:
  inline RawImu() : RawImu(nullptr) {}
  virtual ~RawImu();

  RawImu(const RawImu& from);
  RawImu(RawImu&& from) noexcept
    : RawImu() {
    *this = ::std::move(from);
  }

  inline RawImu& operator=(const RawImu& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawImu& operator=(RawImu&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RawImu& default_instance();

  static inline const RawImu* internal_default_instance() {
    return reinterpret_cast<const RawImu*>(
               &_RawImu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RawImu& a, RawImu& b) {
    a.Swap(&b);
  }
  inline void Swap(RawImu* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RawImu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RawImu* New() const final {
    return CreateMaybeMessage<RawImu>(nullptr);
  }

  RawImu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RawImu>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RawImu& from);
  void MergeFrom(const RawImu& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawImu* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.drivers.rawgnss.RawImu";
  }
  protected:
  explicit RawImu(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto);
    return ::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnssHeaderFieldNumber = 1,
    kSecondsIntoWeekFieldNumber = 3,
    kGnssWeekFieldNumber = 2,
    kImuStatusFieldNumber = 4,
    kZAccelOutputFieldNumber = 5,
    kYAccelOutputFieldNumber = 6,
    kXAccelOutputFieldNumber = 7,
    kZGyroOutputFieldNumber = 8,
    kYGyroOutputFieldNumber = 9,
    kXGyroOutputFieldNumber = 10,
  };
  // required .civ.drivers.rawgnss.GnssHeader gnss_header = 1;
  bool has_gnss_header() const;
  private:
  bool _internal_has_gnss_header() const;
  public:
  void clear_gnss_header();
  const ::civ::drivers::rawgnss::GnssHeader& gnss_header() const;
  ::civ::drivers::rawgnss::GnssHeader* release_gnss_header();
  ::civ::drivers::rawgnss::GnssHeader* mutable_gnss_header();
  void set_allocated_gnss_header(::civ::drivers::rawgnss::GnssHeader* gnss_header);
  private:
  const ::civ::drivers::rawgnss::GnssHeader& _internal_gnss_header() const;
  ::civ::drivers::rawgnss::GnssHeader* _internal_mutable_gnss_header();
  public:
  void unsafe_arena_set_allocated_gnss_header(
      ::civ::drivers::rawgnss::GnssHeader* gnss_header);
  ::civ::drivers::rawgnss::GnssHeader* unsafe_arena_release_gnss_header();

  // required double seconds_into_week = 3;
  bool has_seconds_into_week() const;
  private:
  bool _internal_has_seconds_into_week() const;
  public:
  void clear_seconds_into_week();
  double seconds_into_week() const;
  void set_seconds_into_week(double value);
  private:
  double _internal_seconds_into_week() const;
  void _internal_set_seconds_into_week(double value);
  public:

  // required uint32 gnss_week = 2;
  bool has_gnss_week() const;
  private:
  bool _internal_has_gnss_week() const;
  public:
  void clear_gnss_week();
  ::PROTOBUF_NAMESPACE_ID::uint32 gnss_week() const;
  void set_gnss_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_gnss_week() const;
  void _internal_set_gnss_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 imu_status = 4;
  bool has_imu_status() const;
  private:
  bool _internal_has_imu_status() const;
  public:
  void clear_imu_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 imu_status() const;
  void set_imu_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_imu_status() const;
  void _internal_set_imu_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required double z_accel_output = 5;
  bool has_z_accel_output() const;
  private:
  bool _internal_has_z_accel_output() const;
  public:
  void clear_z_accel_output();
  double z_accel_output() const;
  void set_z_accel_output(double value);
  private:
  double _internal_z_accel_output() const;
  void _internal_set_z_accel_output(double value);
  public:

  // required double y_accel_output = 6;
  bool has_y_accel_output() const;
  private:
  bool _internal_has_y_accel_output() const;
  public:
  void clear_y_accel_output();
  double y_accel_output() const;
  void set_y_accel_output(double value);
  private:
  double _internal_y_accel_output() const;
  void _internal_set_y_accel_output(double value);
  public:

  // required double x_accel_output = 7;
  bool has_x_accel_output() const;
  private:
  bool _internal_has_x_accel_output() const;
  public:
  void clear_x_accel_output();
  double x_accel_output() const;
  void set_x_accel_output(double value);
  private:
  double _internal_x_accel_output() const;
  void _internal_set_x_accel_output(double value);
  public:

  // required double z_gyro_output = 8;
  bool has_z_gyro_output() const;
  private:
  bool _internal_has_z_gyro_output() const;
  public:
  void clear_z_gyro_output();
  double z_gyro_output() const;
  void set_z_gyro_output(double value);
  private:
  double _internal_z_gyro_output() const;
  void _internal_set_z_gyro_output(double value);
  public:

  // required double y_gyro_output = 9;
  bool has_y_gyro_output() const;
  private:
  bool _internal_has_y_gyro_output() const;
  public:
  void clear_y_gyro_output();
  double y_gyro_output() const;
  void set_y_gyro_output(double value);
  private:
  double _internal_y_gyro_output() const;
  void _internal_set_y_gyro_output(double value);
  public:

  // required double x_gyro_output = 10;
  bool has_x_gyro_output() const;
  private:
  bool _internal_has_x_gyro_output() const;
  public:
  void clear_x_gyro_output();
  double x_gyro_output() const;
  void set_x_gyro_output(double value);
  private:
  double _internal_x_gyro_output() const;
  void _internal_set_x_gyro_output(double value);
  public:

  // @@protoc_insertion_point(class_scope:civ.drivers.rawgnss.RawImu)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::civ::drivers::rawgnss::GnssHeader* gnss_header_;
  double seconds_into_week_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gnss_week_;
  ::PROTOBUF_NAMESPACE_ID::uint32 imu_status_;
  double z_accel_output_;
  double y_accel_output_;
  double x_accel_output_;
  double z_gyro_output_;
  double y_gyro_output_;
  double x_gyro_output_;
  friend struct ::TableStruct_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto;
};
// -------------------------------------------------------------------

class BestVel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.drivers.rawgnss.BestVel) */ {
 public:
  inline BestVel() : BestVel(nullptr) {}
  virtual ~BestVel();

  BestVel(const BestVel& from);
  BestVel(BestVel&& from) noexcept
    : BestVel() {
    *this = ::std::move(from);
  }

  inline BestVel& operator=(const BestVel& from) {
    CopyFrom(from);
    return *this;
  }
  inline BestVel& operator=(BestVel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BestVel& default_instance();

  static inline const BestVel* internal_default_instance() {
    return reinterpret_cast<const BestVel*>(
               &_BestVel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BestVel& a, BestVel& b) {
    a.Swap(&b);
  }
  inline void Swap(BestVel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BestVel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BestVel* New() const final {
    return CreateMaybeMessage<BestVel>(nullptr);
  }

  BestVel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BestVel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BestVel& from);
  void MergeFrom(const BestVel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BestVel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.drivers.rawgnss.BestVel";
  }
  protected:
  explicit BestVel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto);
    return ::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnssHeaderFieldNumber = 1,
    kSolutionStatusFieldNumber = 2,
    kVelTypeFieldNumber = 3,
    kLatencyFieldNumber = 4,
    kDiffAgeInSecondsFieldNumber = 5,
    kHorizontalSpeedOverGroundFieldNumber = 6,
    kTrackOverGroundFieldNumber = 7,
    kVerticalSpeedFieldNumber = 8,
    kReservedFieldNumber = 9,
  };
  // required .civ.drivers.rawgnss.GnssHeader gnss_header = 1;
  bool has_gnss_header() const;
  private:
  bool _internal_has_gnss_header() const;
  public:
  void clear_gnss_header();
  const ::civ::drivers::rawgnss::GnssHeader& gnss_header() const;
  ::civ::drivers::rawgnss::GnssHeader* release_gnss_header();
  ::civ::drivers::rawgnss::GnssHeader* mutable_gnss_header();
  void set_allocated_gnss_header(::civ::drivers::rawgnss::GnssHeader* gnss_header);
  private:
  const ::civ::drivers::rawgnss::GnssHeader& _internal_gnss_header() const;
  ::civ::drivers::rawgnss::GnssHeader* _internal_mutable_gnss_header();
  public:
  void unsafe_arena_set_allocated_gnss_header(
      ::civ::drivers::rawgnss::GnssHeader* gnss_header);
  ::civ::drivers::rawgnss::GnssHeader* unsafe_arena_release_gnss_header();

  // optional .civ.drivers.rawgnss.SolutionStatus solution_status = 2;
  bool has_solution_status() const;
  private:
  bool _internal_has_solution_status() const;
  public:
  void clear_solution_status();
  ::civ::drivers::rawgnss::SolutionStatus solution_status() const;
  void set_solution_status(::civ::drivers::rawgnss::SolutionStatus value);
  private:
  ::civ::drivers::rawgnss::SolutionStatus _internal_solution_status() const;
  void _internal_set_solution_status(::civ::drivers::rawgnss::SolutionStatus value);
  public:

  // optional .civ.drivers.rawgnss.PositonVelocityType vel_type = 3;
  bool has_vel_type() const;
  private:
  bool _internal_has_vel_type() const;
  public:
  void clear_vel_type();
  ::civ::drivers::rawgnss::PositonVelocityType vel_type() const;
  void set_vel_type(::civ::drivers::rawgnss::PositonVelocityType value);
  private:
  ::civ::drivers::rawgnss::PositonVelocityType _internal_vel_type() const;
  void _internal_set_vel_type(::civ::drivers::rawgnss::PositonVelocityType value);
  public:

  // required float latency = 4;
  bool has_latency() const;
  private:
  bool _internal_has_latency() const;
  public:
  void clear_latency();
  float latency() const;
  void set_latency(float value);
  private:
  float _internal_latency() const;
  void _internal_set_latency(float value);
  public:

  // required float diff_age_in_seconds = 5;
  bool has_diff_age_in_seconds() const;
  private:
  bool _internal_has_diff_age_in_seconds() const;
  public:
  void clear_diff_age_in_seconds();
  float diff_age_in_seconds() const;
  void set_diff_age_in_seconds(float value);
  private:
  float _internal_diff_age_in_seconds() const;
  void _internal_set_diff_age_in_seconds(float value);
  public:

  // required double horizontal_speed_over_ground = 6;
  bool has_horizontal_speed_over_ground() const;
  private:
  bool _internal_has_horizontal_speed_over_ground() const;
  public:
  void clear_horizontal_speed_over_ground();
  double horizontal_speed_over_ground() const;
  void set_horizontal_speed_over_ground(double value);
  private:
  double _internal_horizontal_speed_over_ground() const;
  void _internal_set_horizontal_speed_over_ground(double value);
  public:

  // required double track_over_ground = 7;
  bool has_track_over_ground() const;
  private:
  bool _internal_has_track_over_ground() const;
  public:
  void clear_track_over_ground();
  double track_over_ground() const;
  void set_track_over_ground(double value);
  private:
  double _internal_track_over_ground() const;
  void _internal_set_track_over_ground(double value);
  public:

  // required double vertical_speed = 8;
  bool has_vertical_speed() const;
  private:
  bool _internal_has_vertical_speed() const;
  public:
  void clear_vertical_speed();
  double vertical_speed() const;
  void set_vertical_speed(double value);
  private:
  double _internal_vertical_speed() const;
  void _internal_set_vertical_speed(double value);
  public:

  // required float reserved = 9;
  bool has_reserved() const;
  private:
  bool _internal_has_reserved() const;
  public:
  void clear_reserved();
  float reserved() const;
  void set_reserved(float value);
  private:
  float _internal_reserved() const;
  void _internal_set_reserved(float value);
  public:

  // @@protoc_insertion_point(class_scope:civ.drivers.rawgnss.BestVel)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::civ::drivers::rawgnss::GnssHeader* gnss_header_;
  int solution_status_;
  int vel_type_;
  float latency_;
  float diff_age_in_seconds_;
  double horizontal_speed_over_ground_;
  double track_over_ground_;
  double vertical_speed_;
  float reserved_;
  friend struct ::TableStruct_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto;
};
// -------------------------------------------------------------------

class InspVax PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.drivers.rawgnss.InspVax) */ {
 public:
  inline InspVax() : InspVax(nullptr) {}
  virtual ~InspVax();

  InspVax(const InspVax& from);
  InspVax(InspVax&& from) noexcept
    : InspVax() {
    *this = ::std::move(from);
  }

  inline InspVax& operator=(const InspVax& from) {
    CopyFrom(from);
    return *this;
  }
  inline InspVax& operator=(InspVax&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InspVax& default_instance();

  static inline const InspVax* internal_default_instance() {
    return reinterpret_cast<const InspVax*>(
               &_InspVax_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InspVax& a, InspVax& b) {
    a.Swap(&b);
  }
  inline void Swap(InspVax* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InspVax* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InspVax* New() const final {
    return CreateMaybeMessage<InspVax>(nullptr);
  }

  InspVax* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InspVax>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InspVax& from);
  void MergeFrom(const InspVax& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InspVax* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.drivers.rawgnss.InspVax";
  }
  protected:
  explicit InspVax(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto);
    return ::descriptor_table_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnssHeaderFieldNumber = 1,
    kInsStatusFieldNumber = 2,
    kPosTypeFieldNumber = 3,
    kLatitudeFieldNumber = 4,
    kLongitudeFieldNumber = 5,
    kHeightFieldNumber = 6,
    kNorthVelocityFieldNumber = 8,
    kEastVelocityFieldNumber = 9,
    kUpVelocityFieldNumber = 10,
    kUndulationFieldNumber = 7,
    kLatitudeStdDeviationFieldNumber = 14,
    kRollInLocalFieldNumber = 11,
    kPitchInLocalFieldNumber = 12,
    kAzimuthInLocalFieldNumber = 13,
    kLongitudeStdDeviationFieldNumber = 15,
    kHeightStdDeviationFieldNumber = 16,
    kNorthVelocityStdDeviationFieldNumber = 17,
    kEastVelocityStdDeviationFieldNumber = 18,
    kUpVelocityStdDeviationFieldNumber = 19,
    kRollStdDeviationFieldNumber = 20,
    kPitchStdDeviationFieldNumber = 21,
    kAzimuthStdDeviationFieldNumber = 22,
    kExtSolStatusFieldNumber = 23,
    kTimeSinceUpdateFieldNumber = 24,
  };
  // required .civ.drivers.rawgnss.GnssHeader gnss_header = 1;
  bool has_gnss_header() const;
  private:
  bool _internal_has_gnss_header() const;
  public:
  void clear_gnss_header();
  const ::civ::drivers::rawgnss::GnssHeader& gnss_header() const;
  ::civ::drivers::rawgnss::GnssHeader* release_gnss_header();
  ::civ::drivers::rawgnss::GnssHeader* mutable_gnss_header();
  void set_allocated_gnss_header(::civ::drivers::rawgnss::GnssHeader* gnss_header);
  private:
  const ::civ::drivers::rawgnss::GnssHeader& _internal_gnss_header() const;
  ::civ::drivers::rawgnss::GnssHeader* _internal_mutable_gnss_header();
  public:
  void unsafe_arena_set_allocated_gnss_header(
      ::civ::drivers::rawgnss::GnssHeader* gnss_header);
  ::civ::drivers::rawgnss::GnssHeader* unsafe_arena_release_gnss_header();

  // required .civ.drivers.rawgnss.InsStatus ins_status = 2;
  bool has_ins_status() const;
  private:
  bool _internal_has_ins_status() const;
  public:
  void clear_ins_status();
  ::civ::drivers::rawgnss::InsStatus ins_status() const;
  void set_ins_status(::civ::drivers::rawgnss::InsStatus value);
  private:
  ::civ::drivers::rawgnss::InsStatus _internal_ins_status() const;
  void _internal_set_ins_status(::civ::drivers::rawgnss::InsStatus value);
  public:

  // optional .civ.drivers.rawgnss.PositonVelocityType pos_type = 3;
  bool has_pos_type() const;
  private:
  bool _internal_has_pos_type() const;
  public:
  void clear_pos_type();
  ::civ::drivers::rawgnss::PositonVelocityType pos_type() const;
  void set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value);
  private:
  ::civ::drivers::rawgnss::PositonVelocityType _internal_pos_type() const;
  void _internal_set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value);
  public:

  // required double latitude = 4;
  bool has_latitude() const;
  private:
  bool _internal_has_latitude() const;
  public:
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // required double longitude = 5;
  bool has_longitude() const;
  private:
  bool _internal_has_longitude() const;
  public:
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // required double height = 6;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  double height() const;
  void set_height(double value);
  private:
  double _internal_height() const;
  void _internal_set_height(double value);
  public:

  // required double north_velocity = 8;
  bool has_north_velocity() const;
  private:
  bool _internal_has_north_velocity() const;
  public:
  void clear_north_velocity();
  double north_velocity() const;
  void set_north_velocity(double value);
  private:
  double _internal_north_velocity() const;
  void _internal_set_north_velocity(double value);
  public:

  // required double east_velocity = 9;
  bool has_east_velocity() const;
  private:
  bool _internal_has_east_velocity() const;
  public:
  void clear_east_velocity();
  double east_velocity() const;
  void set_east_velocity(double value);
  private:
  double _internal_east_velocity() const;
  void _internal_set_east_velocity(double value);
  public:

  // required double up_velocity = 10;
  bool has_up_velocity() const;
  private:
  bool _internal_has_up_velocity() const;
  public:
  void clear_up_velocity();
  double up_velocity() const;
  void set_up_velocity(double value);
  private:
  double _internal_up_velocity() const;
  void _internal_set_up_velocity(double value);
  public:

  // required float undulation = 7;
  bool has_undulation() const;
  private:
  bool _internal_has_undulation() const;
  public:
  void clear_undulation();
  float undulation() const;
  void set_undulation(float value);
  private:
  float _internal_undulation() const;
  void _internal_set_undulation(float value);
  public:

  // required float latitude_std_deviation = 14;
  bool has_latitude_std_deviation() const;
  private:
  bool _internal_has_latitude_std_deviation() const;
  public:
  void clear_latitude_std_deviation();
  float latitude_std_deviation() const;
  void set_latitude_std_deviation(float value);
  private:
  float _internal_latitude_std_deviation() const;
  void _internal_set_latitude_std_deviation(float value);
  public:

  // required double roll_in_local = 11;
  bool has_roll_in_local() const;
  private:
  bool _internal_has_roll_in_local() const;
  public:
  void clear_roll_in_local();
  double roll_in_local() const;
  void set_roll_in_local(double value);
  private:
  double _internal_roll_in_local() const;
  void _internal_set_roll_in_local(double value);
  public:

  // required double pitch_in_local = 12;
  bool has_pitch_in_local() const;
  private:
  bool _internal_has_pitch_in_local() const;
  public:
  void clear_pitch_in_local();
  double pitch_in_local() const;
  void set_pitch_in_local(double value);
  private:
  double _internal_pitch_in_local() const;
  void _internal_set_pitch_in_local(double value);
  public:

  // required double azimuth_in_local = 13;
  bool has_azimuth_in_local() const;
  private:
  bool _internal_has_azimuth_in_local() const;
  public:
  void clear_azimuth_in_local();
  double azimuth_in_local() const;
  void set_azimuth_in_local(double value);
  private:
  double _internal_azimuth_in_local() const;
  void _internal_set_azimuth_in_local(double value);
  public:

  // required float longitude_std_deviation = 15;
  bool has_longitude_std_deviation() const;
  private:
  bool _internal_has_longitude_std_deviation() const;
  public:
  void clear_longitude_std_deviation();
  float longitude_std_deviation() const;
  void set_longitude_std_deviation(float value);
  private:
  float _internal_longitude_std_deviation() const;
  void _internal_set_longitude_std_deviation(float value);
  public:

  // required float height_std_deviation = 16;
  bool has_height_std_deviation() const;
  private:
  bool _internal_has_height_std_deviation() const;
  public:
  void clear_height_std_deviation();
  float height_std_deviation() const;
  void set_height_std_deviation(float value);
  private:
  float _internal_height_std_deviation() const;
  void _internal_set_height_std_deviation(float value);
  public:

  // required float north_velocity_std_deviation = 17;
  bool has_north_velocity_std_deviation() const;
  private:
  bool _internal_has_north_velocity_std_deviation() const;
  public:
  void clear_north_velocity_std_deviation();
  float north_velocity_std_deviation() const;
  void set_north_velocity_std_deviation(float value);
  private:
  float _internal_north_velocity_std_deviation() const;
  void _internal_set_north_velocity_std_deviation(float value);
  public:

  // required float east_velocity_std_deviation = 18;
  bool has_east_velocity_std_deviation() const;
  private:
  bool _internal_has_east_velocity_std_deviation() const;
  public:
  void clear_east_velocity_std_deviation();
  float east_velocity_std_deviation() const;
  void set_east_velocity_std_deviation(float value);
  private:
  float _internal_east_velocity_std_deviation() const;
  void _internal_set_east_velocity_std_deviation(float value);
  public:

  // required float up_velocity_std_deviation = 19;
  bool has_up_velocity_std_deviation() const;
  private:
  bool _internal_has_up_velocity_std_deviation() const;
  public:
  void clear_up_velocity_std_deviation();
  float up_velocity_std_deviation() const;
  void set_up_velocity_std_deviation(float value);
  private:
  float _internal_up_velocity_std_deviation() const;
  void _internal_set_up_velocity_std_deviation(float value);
  public:

  // required float roll_std_deviation = 20;
  bool has_roll_std_deviation() const;
  private:
  bool _internal_has_roll_std_deviation() const;
  public:
  void clear_roll_std_deviation();
  float roll_std_deviation() const;
  void set_roll_std_deviation(float value);
  private:
  float _internal_roll_std_deviation() const;
  void _internal_set_roll_std_deviation(float value);
  public:

  // required float pitch_std_deviation = 21;
  bool has_pitch_std_deviation() const;
  private:
  bool _internal_has_pitch_std_deviation() const;
  public:
  void clear_pitch_std_deviation();
  float pitch_std_deviation() const;
  void set_pitch_std_deviation(float value);
  private:
  float _internal_pitch_std_deviation() const;
  void _internal_set_pitch_std_deviation(float value);
  public:

  // required float azimuth_std_deviation = 22;
  bool has_azimuth_std_deviation() const;
  private:
  bool _internal_has_azimuth_std_deviation() const;
  public:
  void clear_azimuth_std_deviation();
  float azimuth_std_deviation() const;
  void set_azimuth_std_deviation(float value);
  private:
  float _internal_azimuth_std_deviation() const;
  void _internal_set_azimuth_std_deviation(float value);
  public:

  // required uint32 ext_sol_status = 23;
  bool has_ext_sol_status() const;
  private:
  bool _internal_has_ext_sol_status() const;
  public:
  void clear_ext_sol_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 ext_sol_status() const;
  void set_ext_sol_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ext_sol_status() const;
  void _internal_set_ext_sol_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 time_since_update = 24;
  bool has_time_since_update() const;
  private:
  bool _internal_has_time_since_update() const;
  public:
  void clear_time_since_update();
  ::PROTOBUF_NAMESPACE_ID::uint32 time_since_update() const;
  void set_time_since_update(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_time_since_update() const;
  void _internal_set_time_since_update(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:civ.drivers.rawgnss.InspVax)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::civ::drivers::rawgnss::GnssHeader* gnss_header_;
  int ins_status_;
  int pos_type_;
  double latitude_;
  double longitude_;
  double height_;
  double north_velocity_;
  double east_velocity_;
  double up_velocity_;
  float undulation_;
  float latitude_std_deviation_;
  double roll_in_local_;
  double pitch_in_local_;
  double azimuth_in_local_;
  float longitude_std_deviation_;
  float height_std_deviation_;
  float north_velocity_std_deviation_;
  float east_velocity_std_deviation_;
  float up_velocity_std_deviation_;
  float roll_std_deviation_;
  float pitch_std_deviation_;
  float azimuth_std_deviation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ext_sol_status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 time_since_update_;
  friend struct ::TableStruct_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogHeader

// optional int32 sync = 1 [default = 35];
inline bool LogHeader::_internal_has_sync() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LogHeader::has_sync() const {
  return _internal_has_sync();
}
inline void LogHeader::clear_sync() {
  sync_ = 35;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LogHeader::_internal_sync() const {
  return sync_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LogHeader::sync() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.LogHeader.sync)
  return _internal_sync();
}
inline void LogHeader::_internal_set_sync(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  sync_ = value;
}
inline void LogHeader::set_sync(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sync(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.LogHeader.sync)
}

// required string name = 2;
inline bool LogHeader::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogHeader::has_name() const {
  return _internal_has_name();
}
inline void LogHeader::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogHeader::name() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.LogHeader.name)
  return _internal_name();
}
inline void LogHeader::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.LogHeader.name)
}
inline std::string* LogHeader::mutable_name() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.LogHeader.name)
  return _internal_mutable_name();
}
inline const std::string& LogHeader::_internal_name() const {
  return name_.Get();
}
inline void LogHeader::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LogHeader::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.drivers.rawgnss.LogHeader.name)
}
inline void LogHeader::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.drivers.rawgnss.LogHeader.name)
}
inline void LogHeader::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.drivers.rawgnss.LogHeader.name)
}
inline std::string* LogHeader::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LogHeader::release_name() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.LogHeader.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LogHeader::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.LogHeader.name)
}

// -------------------------------------------------------------------

// GnssHeader

// required .civ.drivers.rawgnss.LogHeader log_header = 1;
inline bool GnssHeader::_internal_has_log_header() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || log_header_ != nullptr);
  return value;
}
inline bool GnssHeader::has_log_header() const {
  return _internal_has_log_header();
}
inline void GnssHeader::clear_log_header() {
  if (log_header_ != nullptr) log_header_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::civ::drivers::rawgnss::LogHeader& GnssHeader::_internal_log_header() const {
  const ::civ::drivers::rawgnss::LogHeader* p = log_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::drivers::rawgnss::LogHeader&>(
      ::civ::drivers::rawgnss::_LogHeader_default_instance_);
}
inline const ::civ::drivers::rawgnss::LogHeader& GnssHeader::log_header() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GnssHeader.log_header)
  return _internal_log_header();
}
inline void GnssHeader::unsafe_arena_set_allocated_log_header(
    ::civ::drivers::rawgnss::LogHeader* log_header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_header_);
  }
  log_header_ = log_header;
  if (log_header) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.drivers.rawgnss.GnssHeader.log_header)
}
inline ::civ::drivers::rawgnss::LogHeader* GnssHeader::release_log_header() {
  _has_bits_[0] &= ~0x00000002u;
  ::civ::drivers::rawgnss::LogHeader* temp = log_header_;
  log_header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::drivers::rawgnss::LogHeader* GnssHeader::unsafe_arena_release_log_header() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.GnssHeader.log_header)
  _has_bits_[0] &= ~0x00000002u;
  ::civ::drivers::rawgnss::LogHeader* temp = log_header_;
  log_header_ = nullptr;
  return temp;
}
inline ::civ::drivers::rawgnss::LogHeader* GnssHeader::_internal_mutable_log_header() {
  _has_bits_[0] |= 0x00000002u;
  if (log_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::drivers::rawgnss::LogHeader>(GetArena());
    log_header_ = p;
  }
  return log_header_;
}
inline ::civ::drivers::rawgnss::LogHeader* GnssHeader::mutable_log_header() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.GnssHeader.log_header)
  return _internal_mutable_log_header();
}
inline void GnssHeader::set_allocated_log_header(::civ::drivers::rawgnss::LogHeader* log_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete log_header_;
  }
  if (log_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(log_header);
    if (message_arena != submessage_arena) {
      log_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  log_header_ = log_header;
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.GnssHeader.log_header)
}

// required string port = 2;
inline bool GnssHeader::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GnssHeader::has_port() const {
  return _internal_has_port();
}
inline void GnssHeader::clear_port() {
  port_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GnssHeader::port() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GnssHeader.port)
  return _internal_port();
}
inline void GnssHeader::set_port(const std::string& value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GnssHeader.port)
}
inline std::string* GnssHeader::mutable_port() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.GnssHeader.port)
  return _internal_mutable_port();
}
inline const std::string& GnssHeader::_internal_port() const {
  return port_.Get();
}
inline void GnssHeader::_internal_set_port(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GnssHeader::set_port(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  port_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.drivers.rawgnss.GnssHeader.port)
}
inline void GnssHeader::set_port(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.drivers.rawgnss.GnssHeader.port)
}
inline void GnssHeader::set_port(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.drivers.rawgnss.GnssHeader.port)
}
inline std::string* GnssHeader::_internal_mutable_port() {
  _has_bits_[0] |= 0x00000001u;
  return port_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GnssHeader::release_port() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.GnssHeader.port)
  if (!_internal_has_port()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return port_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GnssHeader::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), port,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.GnssHeader.port)
}

// required uint32 sequence = 3;
inline bool GnssHeader::_internal_has_sequence() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GnssHeader::has_sequence() const {
  return _internal_has_sequence();
}
inline void GnssHeader::clear_sequence() {
  sequence_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GnssHeader::_internal_sequence() const {
  return sequence_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GnssHeader::sequence() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GnssHeader.sequence)
  return _internal_sequence();
}
inline void GnssHeader::_internal_set_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  sequence_ = value;
}
inline void GnssHeader::set_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GnssHeader.sequence)
}

// required float idle_time = 4;
inline bool GnssHeader::_internal_has_idle_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GnssHeader::has_idle_time() const {
  return _internal_has_idle_time();
}
inline void GnssHeader::clear_idle_time() {
  idle_time_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float GnssHeader::_internal_idle_time() const {
  return idle_time_;
}
inline float GnssHeader::idle_time() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GnssHeader.idle_time)
  return _internal_idle_time();
}
inline void GnssHeader::_internal_set_idle_time(float value) {
  _has_bits_[0] |= 0x00000008u;
  idle_time_ = value;
}
inline void GnssHeader::set_idle_time(float value) {
  _internal_set_idle_time(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GnssHeader.idle_time)
}

// required .civ.drivers.rawgnss.TimeStatus time_status = 5;
inline bool GnssHeader::_internal_has_time_status() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool GnssHeader::has_time_status() const {
  return _internal_has_time_status();
}
inline void GnssHeader::clear_time_status() {
  time_status_ = 20;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::civ::drivers::rawgnss::TimeStatus GnssHeader::_internal_time_status() const {
  return static_cast< ::civ::drivers::rawgnss::TimeStatus >(time_status_);
}
inline ::civ::drivers::rawgnss::TimeStatus GnssHeader::time_status() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GnssHeader.time_status)
  return _internal_time_status();
}
inline void GnssHeader::_internal_set_time_status(::civ::drivers::rawgnss::TimeStatus value) {
  assert(::civ::drivers::rawgnss::TimeStatus_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  time_status_ = value;
}
inline void GnssHeader::set_time_status(::civ::drivers::rawgnss::TimeStatus value) {
  _internal_set_time_status(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GnssHeader.time_status)
}

// required uint32 week_num = 6;
inline bool GnssHeader::_internal_has_week_num() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GnssHeader::has_week_num() const {
  return _internal_has_week_num();
}
inline void GnssHeader::clear_week_num() {
  week_num_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GnssHeader::_internal_week_num() const {
  return week_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GnssHeader::week_num() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GnssHeader.week_num)
  return _internal_week_num();
}
inline void GnssHeader::_internal_set_week_num(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  week_num_ = value;
}
inline void GnssHeader::set_week_num(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_week_num(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GnssHeader.week_num)
}

// required double gps_seconds = 7;
inline bool GnssHeader::_internal_has_gps_seconds() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GnssHeader::has_gps_seconds() const {
  return _internal_has_gps_seconds();
}
inline void GnssHeader::clear_gps_seconds() {
  gps_seconds_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double GnssHeader::_internal_gps_seconds() const {
  return gps_seconds_;
}
inline double GnssHeader::gps_seconds() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GnssHeader.gps_seconds)
  return _internal_gps_seconds();
}
inline void GnssHeader::_internal_set_gps_seconds(double value) {
  _has_bits_[0] |= 0x00000010u;
  gps_seconds_ = value;
}
inline void GnssHeader::set_gps_seconds(double value) {
  _internal_set_gps_seconds(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GnssHeader.gps_seconds)
}

// required uint32 receiver_status = 8;
inline bool GnssHeader::_internal_has_receiver_status() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GnssHeader::has_receiver_status() const {
  return _internal_has_receiver_status();
}
inline void GnssHeader::clear_receiver_status() {
  receiver_status_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GnssHeader::_internal_receiver_status() const {
  return receiver_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GnssHeader::receiver_status() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GnssHeader.receiver_status)
  return _internal_receiver_status();
}
inline void GnssHeader::_internal_set_receiver_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  receiver_status_ = value;
}
inline void GnssHeader::set_receiver_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_receiver_status(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GnssHeader.receiver_status)
}

// required uint32 reserved = 9 [default = 0];
inline bool GnssHeader::_internal_has_reserved() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool GnssHeader::has_reserved() const {
  return _internal_has_reserved();
}
inline void GnssHeader::clear_reserved() {
  reserved_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GnssHeader::_internal_reserved() const {
  return reserved_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GnssHeader::reserved() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GnssHeader.reserved)
  return _internal_reserved();
}
inline void GnssHeader::_internal_set_reserved(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  reserved_ = value;
}
inline void GnssHeader::set_reserved(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_reserved(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GnssHeader.reserved)
}

// required uint32 receiver_sw_version = 10;
inline bool GnssHeader::_internal_has_receiver_sw_version() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool GnssHeader::has_receiver_sw_version() const {
  return _internal_has_receiver_sw_version();
}
inline void GnssHeader::clear_receiver_sw_version() {
  receiver_sw_version_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GnssHeader::_internal_receiver_sw_version() const {
  return receiver_sw_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GnssHeader::receiver_sw_version() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GnssHeader.receiver_sw_version)
  return _internal_receiver_sw_version();
}
inline void GnssHeader::_internal_set_receiver_sw_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  receiver_sw_version_ = value;
}
inline void GnssHeader::set_receiver_sw_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_receiver_sw_version(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GnssHeader.receiver_sw_version)
}

// optional double received_timestamp = 11;
inline bool GnssHeader::_internal_has_received_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool GnssHeader::has_received_timestamp() const {
  return _internal_has_received_timestamp();
}
inline void GnssHeader::clear_received_timestamp() {
  received_timestamp_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double GnssHeader::_internal_received_timestamp() const {
  return received_timestamp_;
}
inline double GnssHeader::received_timestamp() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GnssHeader.received_timestamp)
  return _internal_received_timestamp();
}
inline void GnssHeader::_internal_set_received_timestamp(double value) {
  _has_bits_[0] |= 0x00000200u;
  received_timestamp_ = value;
}
inline void GnssHeader::set_received_timestamp(double value) {
  _internal_set_received_timestamp(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GnssHeader.received_timestamp)
}

// -------------------------------------------------------------------

// Bestpos

// required .civ.drivers.rawgnss.GnssHeader gnss_header = 1;
inline bool Bestpos::_internal_has_gnss_header() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || gnss_header_ != nullptr);
  return value;
}
inline bool Bestpos::has_gnss_header() const {
  return _internal_has_gnss_header();
}
inline void Bestpos::clear_gnss_header() {
  if (gnss_header_ != nullptr) gnss_header_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::civ::drivers::rawgnss::GnssHeader& Bestpos::_internal_gnss_header() const {
  const ::civ::drivers::rawgnss::GnssHeader* p = gnss_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::drivers::rawgnss::GnssHeader&>(
      ::civ::drivers::rawgnss::_GnssHeader_default_instance_);
}
inline const ::civ::drivers::rawgnss::GnssHeader& Bestpos::gnss_header() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.gnss_header)
  return _internal_gnss_header();
}
inline void Bestpos::unsafe_arena_set_allocated_gnss_header(
    ::civ::drivers::rawgnss::GnssHeader* gnss_header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gnss_header_);
  }
  gnss_header_ = gnss_header;
  if (gnss_header) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.drivers.rawgnss.Bestpos.gnss_header)
}
inline ::civ::drivers::rawgnss::GnssHeader* Bestpos::release_gnss_header() {
  _has_bits_[0] &= ~0x00000002u;
  ::civ::drivers::rawgnss::GnssHeader* temp = gnss_header_;
  gnss_header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::drivers::rawgnss::GnssHeader* Bestpos::unsafe_arena_release_gnss_header() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.Bestpos.gnss_header)
  _has_bits_[0] &= ~0x00000002u;
  ::civ::drivers::rawgnss::GnssHeader* temp = gnss_header_;
  gnss_header_ = nullptr;
  return temp;
}
inline ::civ::drivers::rawgnss::GnssHeader* Bestpos::_internal_mutable_gnss_header() {
  _has_bits_[0] |= 0x00000002u;
  if (gnss_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::drivers::rawgnss::GnssHeader>(GetArena());
    gnss_header_ = p;
  }
  return gnss_header_;
}
inline ::civ::drivers::rawgnss::GnssHeader* Bestpos::mutable_gnss_header() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.Bestpos.gnss_header)
  return _internal_mutable_gnss_header();
}
inline void Bestpos::set_allocated_gnss_header(::civ::drivers::rawgnss::GnssHeader* gnss_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gnss_header_;
  }
  if (gnss_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gnss_header);
    if (message_arena != submessage_arena) {
      gnss_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gnss_header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  gnss_header_ = gnss_header;
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.Bestpos.gnss_header)
}

// optional .civ.drivers.rawgnss.SolutionStatus solution_status = 2;
inline bool Bestpos::_internal_has_solution_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Bestpos::has_solution_status() const {
  return _internal_has_solution_status();
}
inline void Bestpos::clear_solution_status() {
  solution_status_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::civ::drivers::rawgnss::SolutionStatus Bestpos::_internal_solution_status() const {
  return static_cast< ::civ::drivers::rawgnss::SolutionStatus >(solution_status_);
}
inline ::civ::drivers::rawgnss::SolutionStatus Bestpos::solution_status() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.solution_status)
  return _internal_solution_status();
}
inline void Bestpos::_internal_set_solution_status(::civ::drivers::rawgnss::SolutionStatus value) {
  assert(::civ::drivers::rawgnss::SolutionStatus_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  solution_status_ = value;
}
inline void Bestpos::set_solution_status(::civ::drivers::rawgnss::SolutionStatus value) {
  _internal_set_solution_status(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.solution_status)
}

// optional .civ.drivers.rawgnss.PositonVelocityType pos_type = 3;
inline bool Bestpos::_internal_has_pos_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Bestpos::has_pos_type() const {
  return _internal_has_pos_type();
}
inline void Bestpos::clear_pos_type() {
  pos_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::civ::drivers::rawgnss::PositonVelocityType Bestpos::_internal_pos_type() const {
  return static_cast< ::civ::drivers::rawgnss::PositonVelocityType >(pos_type_);
}
inline ::civ::drivers::rawgnss::PositonVelocityType Bestpos::pos_type() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.pos_type)
  return _internal_pos_type();
}
inline void Bestpos::_internal_set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value) {
  assert(::civ::drivers::rawgnss::PositonVelocityType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  pos_type_ = value;
}
inline void Bestpos::set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value) {
  _internal_set_pos_type(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.pos_type)
}

// required double latitude_in_degree = 4;
inline bool Bestpos::_internal_has_latitude_in_degree() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Bestpos::has_latitude_in_degree() const {
  return _internal_has_latitude_in_degree();
}
inline void Bestpos::clear_latitude_in_degree() {
  latitude_in_degree_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double Bestpos::_internal_latitude_in_degree() const {
  return latitude_in_degree_;
}
inline double Bestpos::latitude_in_degree() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.latitude_in_degree)
  return _internal_latitude_in_degree();
}
inline void Bestpos::_internal_set_latitude_in_degree(double value) {
  _has_bits_[0] |= 0x00000010u;
  latitude_in_degree_ = value;
}
inline void Bestpos::set_latitude_in_degree(double value) {
  _internal_set_latitude_in_degree(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.latitude_in_degree)
}

// required double longitude_in_degree = 5;
inline bool Bestpos::_internal_has_longitude_in_degree() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Bestpos::has_longitude_in_degree() const {
  return _internal_has_longitude_in_degree();
}
inline void Bestpos::clear_longitude_in_degree() {
  longitude_in_degree_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double Bestpos::_internal_longitude_in_degree() const {
  return longitude_in_degree_;
}
inline double Bestpos::longitude_in_degree() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.longitude_in_degree)
  return _internal_longitude_in_degree();
}
inline void Bestpos::_internal_set_longitude_in_degree(double value) {
  _has_bits_[0] |= 0x00000020u;
  longitude_in_degree_ = value;
}
inline void Bestpos::set_longitude_in_degree(double value) {
  _internal_set_longitude_in_degree(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.longitude_in_degree)
}

// required double height_in_metres = 6;
inline bool Bestpos::_internal_has_height_in_metres() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Bestpos::has_height_in_metres() const {
  return _internal_has_height_in_metres();
}
inline void Bestpos::clear_height_in_metres() {
  height_in_metres_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double Bestpos::_internal_height_in_metres() const {
  return height_in_metres_;
}
inline double Bestpos::height_in_metres() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.height_in_metres)
  return _internal_height_in_metres();
}
inline void Bestpos::_internal_set_height_in_metres(double value) {
  _has_bits_[0] |= 0x00000040u;
  height_in_metres_ = value;
}
inline void Bestpos::set_height_in_metres(double value) {
  _internal_set_height_in_metres(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.height_in_metres)
}

// required float undulation = 7;
inline bool Bestpos::_internal_has_undulation() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Bestpos::has_undulation() const {
  return _internal_has_undulation();
}
inline void Bestpos::clear_undulation() {
  undulation_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Bestpos::_internal_undulation() const {
  return undulation_;
}
inline float Bestpos::undulation() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.undulation)
  return _internal_undulation();
}
inline void Bestpos::_internal_set_undulation(float value) {
  _has_bits_[0] |= 0x00000080u;
  undulation_ = value;
}
inline void Bestpos::set_undulation(float value) {
  _internal_set_undulation(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.undulation)
}

// required .civ.drivers.rawgnss.DatumID datum_id = 8;
inline bool Bestpos::_internal_has_datum_id() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Bestpos::has_datum_id() const {
  return _internal_has_datum_id();
}
inline void Bestpos::clear_datum_id() {
  datum_id_ = 61;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::civ::drivers::rawgnss::DatumID Bestpos::_internal_datum_id() const {
  return static_cast< ::civ::drivers::rawgnss::DatumID >(datum_id_);
}
inline ::civ::drivers::rawgnss::DatumID Bestpos::datum_id() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.datum_id)
  return _internal_datum_id();
}
inline void Bestpos::_internal_set_datum_id(::civ::drivers::rawgnss::DatumID value) {
  assert(::civ::drivers::rawgnss::DatumID_IsValid(value));
  _has_bits_[0] |= 0x00200000u;
  datum_id_ = value;
}
inline void Bestpos::set_datum_id(::civ::drivers::rawgnss::DatumID value) {
  _internal_set_datum_id(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.datum_id)
}

// required float latitude_std_dev = 9;
inline bool Bestpos::_internal_has_latitude_std_dev() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Bestpos::has_latitude_std_dev() const {
  return _internal_has_latitude_std_dev();
}
inline void Bestpos::clear_latitude_std_dev() {
  latitude_std_dev_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float Bestpos::_internal_latitude_std_dev() const {
  return latitude_std_dev_;
}
inline float Bestpos::latitude_std_dev() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.latitude_std_dev)
  return _internal_latitude_std_dev();
}
inline void Bestpos::_internal_set_latitude_std_dev(float value) {
  _has_bits_[0] |= 0x00000100u;
  latitude_std_dev_ = value;
}
inline void Bestpos::set_latitude_std_dev(float value) {
  _internal_set_latitude_std_dev(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.latitude_std_dev)
}

// required float longitude_std_dev = 10;
inline bool Bestpos::_internal_has_longitude_std_dev() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Bestpos::has_longitude_std_dev() const {
  return _internal_has_longitude_std_dev();
}
inline void Bestpos::clear_longitude_std_dev() {
  longitude_std_dev_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float Bestpos::_internal_longitude_std_dev() const {
  return longitude_std_dev_;
}
inline float Bestpos::longitude_std_dev() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.longitude_std_dev)
  return _internal_longitude_std_dev();
}
inline void Bestpos::_internal_set_longitude_std_dev(float value) {
  _has_bits_[0] |= 0x00000200u;
  longitude_std_dev_ = value;
}
inline void Bestpos::set_longitude_std_dev(float value) {
  _internal_set_longitude_std_dev(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.longitude_std_dev)
}

// required float height_std_dev = 11;
inline bool Bestpos::_internal_has_height_std_dev() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Bestpos::has_height_std_dev() const {
  return _internal_has_height_std_dev();
}
inline void Bestpos::clear_height_std_dev() {
  height_std_dev_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float Bestpos::_internal_height_std_dev() const {
  return height_std_dev_;
}
inline float Bestpos::height_std_dev() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.height_std_dev)
  return _internal_height_std_dev();
}
inline void Bestpos::_internal_set_height_std_dev(float value) {
  _has_bits_[0] |= 0x00000400u;
  height_std_dev_ = value;
}
inline void Bestpos::set_height_std_dev(float value) {
  _internal_set_height_std_dev(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.height_std_dev)
}

// required string base_station_id = 12;
inline bool Bestpos::_internal_has_base_station_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Bestpos::has_base_station_id() const {
  return _internal_has_base_station_id();
}
inline void Bestpos::clear_base_station_id() {
  base_station_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Bestpos::base_station_id() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.base_station_id)
  return _internal_base_station_id();
}
inline void Bestpos::set_base_station_id(const std::string& value) {
  _internal_set_base_station_id(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.base_station_id)
}
inline std::string* Bestpos::mutable_base_station_id() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.Bestpos.base_station_id)
  return _internal_mutable_base_station_id();
}
inline const std::string& Bestpos::_internal_base_station_id() const {
  return base_station_id_.Get();
}
inline void Bestpos::_internal_set_base_station_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  base_station_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Bestpos::set_base_station_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  base_station_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.drivers.rawgnss.Bestpos.base_station_id)
}
inline void Bestpos::set_base_station_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  base_station_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.drivers.rawgnss.Bestpos.base_station_id)
}
inline void Bestpos::set_base_station_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  base_station_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.drivers.rawgnss.Bestpos.base_station_id)
}
inline std::string* Bestpos::_internal_mutable_base_station_id() {
  _has_bits_[0] |= 0x00000001u;
  return base_station_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Bestpos::release_base_station_id() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.Bestpos.base_station_id)
  if (!_internal_has_base_station_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return base_station_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Bestpos::set_allocated_base_station_id(std::string* base_station_id) {
  if (base_station_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  base_station_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), base_station_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.Bestpos.base_station_id)
}

// required float diff_age_in_seconds = 13;
inline bool Bestpos::_internal_has_diff_age_in_seconds() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Bestpos::has_diff_age_in_seconds() const {
  return _internal_has_diff_age_in_seconds();
}
inline void Bestpos::clear_diff_age_in_seconds() {
  diff_age_in_seconds_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float Bestpos::_internal_diff_age_in_seconds() const {
  return diff_age_in_seconds_;
}
inline float Bestpos::diff_age_in_seconds() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.diff_age_in_seconds)
  return _internal_diff_age_in_seconds();
}
inline void Bestpos::_internal_set_diff_age_in_seconds(float value) {
  _has_bits_[0] |= 0x00000800u;
  diff_age_in_seconds_ = value;
}
inline void Bestpos::set_diff_age_in_seconds(float value) {
  _internal_set_diff_age_in_seconds(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.diff_age_in_seconds)
}

// required float solution_age_in_seconds = 14;
inline bool Bestpos::_internal_has_solution_age_in_seconds() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Bestpos::has_solution_age_in_seconds() const {
  return _internal_has_solution_age_in_seconds();
}
inline void Bestpos::clear_solution_age_in_seconds() {
  solution_age_in_seconds_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float Bestpos::_internal_solution_age_in_seconds() const {
  return solution_age_in_seconds_;
}
inline float Bestpos::solution_age_in_seconds() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.solution_age_in_seconds)
  return _internal_solution_age_in_seconds();
}
inline void Bestpos::_internal_set_solution_age_in_seconds(float value) {
  _has_bits_[0] |= 0x00001000u;
  solution_age_in_seconds_ = value;
}
inline void Bestpos::set_solution_age_in_seconds(float value) {
  _internal_set_solution_age_in_seconds(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.solution_age_in_seconds)
}

// required int32 num_of_satellites_tracked = 15;
inline bool Bestpos::_internal_has_num_of_satellites_tracked() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Bestpos::has_num_of_satellites_tracked() const {
  return _internal_has_num_of_satellites_tracked();
}
inline void Bestpos::clear_num_of_satellites_tracked() {
  num_of_satellites_tracked_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::_internal_num_of_satellites_tracked() const {
  return num_of_satellites_tracked_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::num_of_satellites_tracked() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.num_of_satellites_tracked)
  return _internal_num_of_satellites_tracked();
}
inline void Bestpos::_internal_set_num_of_satellites_tracked(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00002000u;
  num_of_satellites_tracked_ = value;
}
inline void Bestpos::set_num_of_satellites_tracked(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_of_satellites_tracked(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.num_of_satellites_tracked)
}

// required int32 num_of_satellites_used = 16;
inline bool Bestpos::_internal_has_num_of_satellites_used() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Bestpos::has_num_of_satellites_used() const {
  return _internal_has_num_of_satellites_used();
}
inline void Bestpos::clear_num_of_satellites_used() {
  num_of_satellites_used_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::_internal_num_of_satellites_used() const {
  return num_of_satellites_used_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::num_of_satellites_used() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.num_of_satellites_used)
  return _internal_num_of_satellites_used();
}
inline void Bestpos::_internal_set_num_of_satellites_used(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00004000u;
  num_of_satellites_used_ = value;
}
inline void Bestpos::set_num_of_satellites_used(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_of_satellites_used(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.num_of_satellites_used)
}

// required int32 num_of_satellites_with_l1_e1_b1 = 17;
inline bool Bestpos::_internal_has_num_of_satellites_with_l1_e1_b1() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Bestpos::has_num_of_satellites_with_l1_e1_b1() const {
  return _internal_has_num_of_satellites_with_l1_e1_b1();
}
inline void Bestpos::clear_num_of_satellites_with_l1_e1_b1() {
  num_of_satellites_with_l1_e1_b1_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::_internal_num_of_satellites_with_l1_e1_b1() const {
  return num_of_satellites_with_l1_e1_b1_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::num_of_satellites_with_l1_e1_b1() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.num_of_satellites_with_l1_e1_b1)
  return _internal_num_of_satellites_with_l1_e1_b1();
}
inline void Bestpos::_internal_set_num_of_satellites_with_l1_e1_b1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00008000u;
  num_of_satellites_with_l1_e1_b1_ = value;
}
inline void Bestpos::set_num_of_satellites_with_l1_e1_b1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_of_satellites_with_l1_e1_b1(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.num_of_satellites_with_l1_e1_b1)
}

// required int32 num_of_satellites_with_multi_freq = 18;
inline bool Bestpos::_internal_has_num_of_satellites_with_multi_freq() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Bestpos::has_num_of_satellites_with_multi_freq() const {
  return _internal_has_num_of_satellites_with_multi_freq();
}
inline void Bestpos::clear_num_of_satellites_with_multi_freq() {
  num_of_satellites_with_multi_freq_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::_internal_num_of_satellites_with_multi_freq() const {
  return num_of_satellites_with_multi_freq_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::num_of_satellites_with_multi_freq() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.num_of_satellites_with_multi_freq)
  return _internal_num_of_satellites_with_multi_freq();
}
inline void Bestpos::_internal_set_num_of_satellites_with_multi_freq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00010000u;
  num_of_satellites_with_multi_freq_ = value;
}
inline void Bestpos::set_num_of_satellites_with_multi_freq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_of_satellites_with_multi_freq(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.num_of_satellites_with_multi_freq)
}

// required int32 reserved = 19 [default = 0];
inline bool Bestpos::_internal_has_reserved() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Bestpos::has_reserved() const {
  return _internal_has_reserved();
}
inline void Bestpos::clear_reserved() {
  reserved_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::_internal_reserved() const {
  return reserved_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::reserved() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.reserved)
  return _internal_reserved();
}
inline void Bestpos::_internal_set_reserved(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00020000u;
  reserved_ = value;
}
inline void Bestpos::set_reserved(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_reserved(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.reserved)
}

// required int32 extended_solution_status = 20;
inline bool Bestpos::_internal_has_extended_solution_status() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Bestpos::has_extended_solution_status() const {
  return _internal_has_extended_solution_status();
}
inline void Bestpos::clear_extended_solution_status() {
  extended_solution_status_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::_internal_extended_solution_status() const {
  return extended_solution_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::extended_solution_status() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.extended_solution_status)
  return _internal_extended_solution_status();
}
inline void Bestpos::_internal_set_extended_solution_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00040000u;
  extended_solution_status_ = value;
}
inline void Bestpos::set_extended_solution_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_extended_solution_status(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.extended_solution_status)
}

// required int32 galileo_beidou_sig_mask = 21;
inline bool Bestpos::_internal_has_galileo_beidou_sig_mask() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Bestpos::has_galileo_beidou_sig_mask() const {
  return _internal_has_galileo_beidou_sig_mask();
}
inline void Bestpos::clear_galileo_beidou_sig_mask() {
  galileo_beidou_sig_mask_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::_internal_galileo_beidou_sig_mask() const {
  return galileo_beidou_sig_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::galileo_beidou_sig_mask() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.galileo_beidou_sig_mask)
  return _internal_galileo_beidou_sig_mask();
}
inline void Bestpos::_internal_set_galileo_beidou_sig_mask(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00080000u;
  galileo_beidou_sig_mask_ = value;
}
inline void Bestpos::set_galileo_beidou_sig_mask(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_galileo_beidou_sig_mask(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.galileo_beidou_sig_mask)
}

// required int32 gps_glonass_sig_mask = 22;
inline bool Bestpos::_internal_has_gps_glonass_sig_mask() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Bestpos::has_gps_glonass_sig_mask() const {
  return _internal_has_gps_glonass_sig_mask();
}
inline void Bestpos::clear_gps_glonass_sig_mask() {
  gps_glonass_sig_mask_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::_internal_gps_glonass_sig_mask() const {
  return gps_glonass_sig_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bestpos::gps_glonass_sig_mask() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Bestpos.gps_glonass_sig_mask)
  return _internal_gps_glonass_sig_mask();
}
inline void Bestpos::_internal_set_gps_glonass_sig_mask(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00100000u;
  gps_glonass_sig_mask_ = value;
}
inline void Bestpos::set_gps_glonass_sig_mask(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gps_glonass_sig_mask(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Bestpos.gps_glonass_sig_mask)
}

// -------------------------------------------------------------------

// GNGGA

// optional .civ.drivers.rawgnss.LogHeader log_header = 1;
inline bool GNGGA::_internal_has_log_header() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || log_header_ != nullptr);
  return value;
}
inline bool GNGGA::has_log_header() const {
  return _internal_has_log_header();
}
inline void GNGGA::clear_log_header() {
  if (log_header_ != nullptr) log_header_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::civ::drivers::rawgnss::LogHeader& GNGGA::_internal_log_header() const {
  const ::civ::drivers::rawgnss::LogHeader* p = log_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::drivers::rawgnss::LogHeader&>(
      ::civ::drivers::rawgnss::_LogHeader_default_instance_);
}
inline const ::civ::drivers::rawgnss::LogHeader& GNGGA::log_header() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.log_header)
  return _internal_log_header();
}
inline void GNGGA::unsafe_arena_set_allocated_log_header(
    ::civ::drivers::rawgnss::LogHeader* log_header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_header_);
  }
  log_header_ = log_header;
  if (log_header) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.drivers.rawgnss.GNGGA.log_header)
}
inline ::civ::drivers::rawgnss::LogHeader* GNGGA::release_log_header() {
  _has_bits_[0] &= ~0x00000002u;
  ::civ::drivers::rawgnss::LogHeader* temp = log_header_;
  log_header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::drivers::rawgnss::LogHeader* GNGGA::unsafe_arena_release_log_header() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.GNGGA.log_header)
  _has_bits_[0] &= ~0x00000002u;
  ::civ::drivers::rawgnss::LogHeader* temp = log_header_;
  log_header_ = nullptr;
  return temp;
}
inline ::civ::drivers::rawgnss::LogHeader* GNGGA::_internal_mutable_log_header() {
  _has_bits_[0] |= 0x00000002u;
  if (log_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::drivers::rawgnss::LogHeader>(GetArena());
    log_header_ = p;
  }
  return log_header_;
}
inline ::civ::drivers::rawgnss::LogHeader* GNGGA::mutable_log_header() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.GNGGA.log_header)
  return _internal_mutable_log_header();
}
inline void GNGGA::set_allocated_log_header(::civ::drivers::rawgnss::LogHeader* log_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete log_header_;
  }
  if (log_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(log_header);
    if (message_arena != submessage_arena) {
      log_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  log_header_ = log_header;
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.GNGGA.log_header)
}

// optional double utc_in_seconds = 2;
inline bool GNGGA::_internal_has_utc_in_seconds() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GNGGA::has_utc_in_seconds() const {
  return _internal_has_utc_in_seconds();
}
inline void GNGGA::clear_utc_in_seconds() {
  utc_in_seconds_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double GNGGA::_internal_utc_in_seconds() const {
  return utc_in_seconds_;
}
inline double GNGGA::utc_in_seconds() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.utc_in_seconds)
  return _internal_utc_in_seconds();
}
inline void GNGGA::_internal_set_utc_in_seconds(double value) {
  _has_bits_[0] |= 0x00000004u;
  utc_in_seconds_ = value;
}
inline void GNGGA::set_utc_in_seconds(double value) {
  _internal_set_utc_in_seconds(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.utc_in_seconds)
}

// optional float latitude = 3;
inline bool GNGGA::_internal_has_latitude() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GNGGA::has_latitude() const {
  return _internal_has_latitude();
}
inline void GNGGA::clear_latitude() {
  latitude_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float GNGGA::_internal_latitude() const {
  return latitude_;
}
inline float GNGGA::latitude() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.latitude)
  return _internal_latitude();
}
inline void GNGGA::_internal_set_latitude(float value) {
  _has_bits_[0] |= 0x00000008u;
  latitude_ = value;
}
inline void GNGGA::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.latitude)
}

// optional .civ.drivers.rawgnss.GNGGA.LatitudeDirection latitude_dir = 4;
inline bool GNGGA::_internal_has_latitude_dir() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GNGGA::has_latitude_dir() const {
  return _internal_has_latitude_dir();
}
inline void GNGGA::clear_latitude_dir() {
  latitude_dir_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::civ::drivers::rawgnss::GNGGA_LatitudeDirection GNGGA::_internal_latitude_dir() const {
  return static_cast< ::civ::drivers::rawgnss::GNGGA_LatitudeDirection >(latitude_dir_);
}
inline ::civ::drivers::rawgnss::GNGGA_LatitudeDirection GNGGA::latitude_dir() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.latitude_dir)
  return _internal_latitude_dir();
}
inline void GNGGA::_internal_set_latitude_dir(::civ::drivers::rawgnss::GNGGA_LatitudeDirection value) {
  assert(::civ::drivers::rawgnss::GNGGA_LatitudeDirection_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  latitude_dir_ = value;
}
inline void GNGGA::set_latitude_dir(::civ::drivers::rawgnss::GNGGA_LatitudeDirection value) {
  _internal_set_latitude_dir(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.latitude_dir)
}

// optional float longitude = 5;
inline bool GNGGA::_internal_has_longitude() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GNGGA::has_longitude() const {
  return _internal_has_longitude();
}
inline void GNGGA::clear_longitude() {
  longitude_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float GNGGA::_internal_longitude() const {
  return longitude_;
}
inline float GNGGA::longitude() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.longitude)
  return _internal_longitude();
}
inline void GNGGA::_internal_set_longitude(float value) {
  _has_bits_[0] |= 0x00000020u;
  longitude_ = value;
}
inline void GNGGA::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.longitude)
}

// optional .civ.drivers.rawgnss.GNGGA.LongitudeDirection longitude_dir = 6;
inline bool GNGGA::_internal_has_longitude_dir() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GNGGA::has_longitude_dir() const {
  return _internal_has_longitude_dir();
}
inline void GNGGA::clear_longitude_dir() {
  longitude_dir_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::civ::drivers::rawgnss::GNGGA_LongitudeDirection GNGGA::_internal_longitude_dir() const {
  return static_cast< ::civ::drivers::rawgnss::GNGGA_LongitudeDirection >(longitude_dir_);
}
inline ::civ::drivers::rawgnss::GNGGA_LongitudeDirection GNGGA::longitude_dir() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.longitude_dir)
  return _internal_longitude_dir();
}
inline void GNGGA::_internal_set_longitude_dir(::civ::drivers::rawgnss::GNGGA_LongitudeDirection value) {
  assert(::civ::drivers::rawgnss::GNGGA_LongitudeDirection_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  longitude_dir_ = value;
}
inline void GNGGA::set_longitude_dir(::civ::drivers::rawgnss::GNGGA_LongitudeDirection value) {
  _internal_set_longitude_dir(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.longitude_dir)
}

// optional int32 quality = 7;
inline bool GNGGA::_internal_has_quality() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool GNGGA::has_quality() const {
  return _internal_has_quality();
}
inline void GNGGA::clear_quality() {
  quality_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GNGGA::_internal_quality() const {
  return quality_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GNGGA::quality() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.quality)
  return _internal_quality();
}
inline void GNGGA::_internal_set_quality(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  quality_ = value;
}
inline void GNGGA::set_quality(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.quality)
}

// optional int32 num_of_satellites_used = 8;
inline bool GNGGA::_internal_has_num_of_satellites_used() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool GNGGA::has_num_of_satellites_used() const {
  return _internal_has_num_of_satellites_used();
}
inline void GNGGA::clear_num_of_satellites_used() {
  num_of_satellites_used_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GNGGA::_internal_num_of_satellites_used() const {
  return num_of_satellites_used_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GNGGA::num_of_satellites_used() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.num_of_satellites_used)
  return _internal_num_of_satellites_used();
}
inline void GNGGA::_internal_set_num_of_satellites_used(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  num_of_satellites_used_ = value;
}
inline void GNGGA::set_num_of_satellites_used(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_of_satellites_used(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.num_of_satellites_used)
}

// optional float hdop = 9;
inline bool GNGGA::_internal_has_hdop() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool GNGGA::has_hdop() const {
  return _internal_has_hdop();
}
inline void GNGGA::clear_hdop() {
  hdop_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float GNGGA::_internal_hdop() const {
  return hdop_;
}
inline float GNGGA::hdop() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.hdop)
  return _internal_hdop();
}
inline void GNGGA::_internal_set_hdop(float value) {
  _has_bits_[0] |= 0x00000200u;
  hdop_ = value;
}
inline void GNGGA::set_hdop(float value) {
  _internal_set_hdop(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.hdop)
}

// optional float alt = 10;
inline bool GNGGA::_internal_has_alt() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool GNGGA::has_alt() const {
  return _internal_has_alt();
}
inline void GNGGA::clear_alt() {
  alt_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float GNGGA::_internal_alt() const {
  return alt_;
}
inline float GNGGA::alt() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.alt)
  return _internal_alt();
}
inline void GNGGA::_internal_set_alt(float value) {
  _has_bits_[0] |= 0x00000400u;
  alt_ = value;
}
inline void GNGGA::set_alt(float value) {
  _internal_set_alt(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.alt)
}

// optional string utc_hhmmss = 11;
inline bool GNGGA::_internal_has_utc_hhmmss() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GNGGA::has_utc_hhmmss() const {
  return _internal_has_utc_hhmmss();
}
inline void GNGGA::clear_utc_hhmmss() {
  utc_hhmmss_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GNGGA::utc_hhmmss() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.utc_hhmmss)
  return _internal_utc_hhmmss();
}
inline void GNGGA::set_utc_hhmmss(const std::string& value) {
  _internal_set_utc_hhmmss(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.utc_hhmmss)
}
inline std::string* GNGGA::mutable_utc_hhmmss() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.GNGGA.utc_hhmmss)
  return _internal_mutable_utc_hhmmss();
}
inline const std::string& GNGGA::_internal_utc_hhmmss() const {
  return utc_hhmmss_.Get();
}
inline void GNGGA::_internal_set_utc_hhmmss(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  utc_hhmmss_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GNGGA::set_utc_hhmmss(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  utc_hhmmss_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.drivers.rawgnss.GNGGA.utc_hhmmss)
}
inline void GNGGA::set_utc_hhmmss(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  utc_hhmmss_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.drivers.rawgnss.GNGGA.utc_hhmmss)
}
inline void GNGGA::set_utc_hhmmss(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  utc_hhmmss_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.drivers.rawgnss.GNGGA.utc_hhmmss)
}
inline std::string* GNGGA::_internal_mutable_utc_hhmmss() {
  _has_bits_[0] |= 0x00000001u;
  return utc_hhmmss_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GNGGA::release_utc_hhmmss() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.GNGGA.utc_hhmmss)
  if (!_internal_has_utc_hhmmss()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return utc_hhmmss_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GNGGA::set_allocated_utc_hhmmss(std::string* utc_hhmmss) {
  if (utc_hhmmss != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  utc_hhmmss_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), utc_hhmmss,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.GNGGA.utc_hhmmss)
}

// optional float latitude_deg = 12;
inline bool GNGGA::_internal_has_latitude_deg() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool GNGGA::has_latitude_deg() const {
  return _internal_has_latitude_deg();
}
inline void GNGGA::clear_latitude_deg() {
  latitude_deg_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float GNGGA::_internal_latitude_deg() const {
  return latitude_deg_;
}
inline float GNGGA::latitude_deg() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.latitude_deg)
  return _internal_latitude_deg();
}
inline void GNGGA::_internal_set_latitude_deg(float value) {
  _has_bits_[0] |= 0x00000800u;
  latitude_deg_ = value;
}
inline void GNGGA::set_latitude_deg(float value) {
  _internal_set_latitude_deg(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.latitude_deg)
}

// optional float longitude_deg = 13;
inline bool GNGGA::_internal_has_longitude_deg() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool GNGGA::has_longitude_deg() const {
  return _internal_has_longitude_deg();
}
inline void GNGGA::clear_longitude_deg() {
  longitude_deg_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float GNGGA::_internal_longitude_deg() const {
  return longitude_deg_;
}
inline float GNGGA::longitude_deg() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNGGA.longitude_deg)
  return _internal_longitude_deg();
}
inline void GNGGA::_internal_set_longitude_deg(float value) {
  _has_bits_[0] |= 0x00001000u;
  longitude_deg_ = value;
}
inline void GNGGA::set_longitude_deg(float value) {
  _internal_set_longitude_deg(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNGGA.longitude_deg)
}

// -------------------------------------------------------------------

// GNVTG

// required .civ.drivers.rawgnss.LogHeader log_header = 1;
inline bool GNVTG::_internal_has_log_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || log_header_ != nullptr);
  return value;
}
inline bool GNVTG::has_log_header() const {
  return _internal_has_log_header();
}
inline void GNVTG::clear_log_header() {
  if (log_header_ != nullptr) log_header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::civ::drivers::rawgnss::LogHeader& GNVTG::_internal_log_header() const {
  const ::civ::drivers::rawgnss::LogHeader* p = log_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::drivers::rawgnss::LogHeader&>(
      ::civ::drivers::rawgnss::_LogHeader_default_instance_);
}
inline const ::civ::drivers::rawgnss::LogHeader& GNVTG::log_header() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNVTG.log_header)
  return _internal_log_header();
}
inline void GNVTG::unsafe_arena_set_allocated_log_header(
    ::civ::drivers::rawgnss::LogHeader* log_header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_header_);
  }
  log_header_ = log_header;
  if (log_header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.drivers.rawgnss.GNVTG.log_header)
}
inline ::civ::drivers::rawgnss::LogHeader* GNVTG::release_log_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::civ::drivers::rawgnss::LogHeader* temp = log_header_;
  log_header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::drivers::rawgnss::LogHeader* GNVTG::unsafe_arena_release_log_header() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.GNVTG.log_header)
  _has_bits_[0] &= ~0x00000001u;
  ::civ::drivers::rawgnss::LogHeader* temp = log_header_;
  log_header_ = nullptr;
  return temp;
}
inline ::civ::drivers::rawgnss::LogHeader* GNVTG::_internal_mutable_log_header() {
  _has_bits_[0] |= 0x00000001u;
  if (log_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::drivers::rawgnss::LogHeader>(GetArena());
    log_header_ = p;
  }
  return log_header_;
}
inline ::civ::drivers::rawgnss::LogHeader* GNVTG::mutable_log_header() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.GNVTG.log_header)
  return _internal_mutable_log_header();
}
inline void GNVTG::set_allocated_log_header(::civ::drivers::rawgnss::LogHeader* log_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete log_header_;
  }
  if (log_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(log_header);
    if (message_arena != submessage_arena) {
      log_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  log_header_ = log_header;
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.GNVTG.log_header)
}

// required float track_true = 2;
inline bool GNVTG::_internal_has_track_true() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GNVTG::has_track_true() const {
  return _internal_has_track_true();
}
inline void GNVTG::clear_track_true() {
  track_true_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float GNVTG::_internal_track_true() const {
  return track_true_;
}
inline float GNVTG::track_true() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNVTG.track_true)
  return _internal_track_true();
}
inline void GNVTG::_internal_set_track_true(float value) {
  _has_bits_[0] |= 0x00000002u;
  track_true_ = value;
}
inline void GNVTG::set_track_true(float value) {
  _internal_set_track_true(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNVTG.track_true)
}

// required bool true_track_indicator = 3;
inline bool GNVTG::_internal_has_true_track_indicator() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GNVTG::has_true_track_indicator() const {
  return _internal_has_true_track_indicator();
}
inline void GNVTG::clear_true_track_indicator() {
  true_track_indicator_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool GNVTG::_internal_true_track_indicator() const {
  return true_track_indicator_;
}
inline bool GNVTG::true_track_indicator() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNVTG.true_track_indicator)
  return _internal_true_track_indicator();
}
inline void GNVTG::_internal_set_true_track_indicator(bool value) {
  _has_bits_[0] |= 0x00000010u;
  true_track_indicator_ = value;
}
inline void GNVTG::set_true_track_indicator(bool value) {
  _internal_set_true_track_indicator(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNVTG.true_track_indicator)
}

// required float track_mag = 4;
inline bool GNVTG::_internal_has_track_mag() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GNVTG::has_track_mag() const {
  return _internal_has_track_mag();
}
inline void GNVTG::clear_track_mag() {
  track_mag_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float GNVTG::_internal_track_mag() const {
  return track_mag_;
}
inline float GNVTG::track_mag() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNVTG.track_mag)
  return _internal_track_mag();
}
inline void GNVTG::_internal_set_track_mag(float value) {
  _has_bits_[0] |= 0x00000004u;
  track_mag_ = value;
}
inline void GNVTG::set_track_mag(float value) {
  _internal_set_track_mag(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNVTG.track_mag)
}

// required bool magnetic_track_indicator = 5;
inline bool GNVTG::_internal_has_magnetic_track_indicator() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GNVTG::has_magnetic_track_indicator() const {
  return _internal_has_magnetic_track_indicator();
}
inline void GNVTG::clear_magnetic_track_indicator() {
  magnetic_track_indicator_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool GNVTG::_internal_magnetic_track_indicator() const {
  return magnetic_track_indicator_;
}
inline bool GNVTG::magnetic_track_indicator() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNVTG.magnetic_track_indicator)
  return _internal_magnetic_track_indicator();
}
inline void GNVTG::_internal_set_magnetic_track_indicator(bool value) {
  _has_bits_[0] |= 0x00000020u;
  magnetic_track_indicator_ = value;
}
inline void GNVTG::set_magnetic_track_indicator(bool value) {
  _internal_set_magnetic_track_indicator(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNVTG.magnetic_track_indicator)
}

// required float speed_kn = 6;
inline bool GNVTG::_internal_has_speed_kn() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GNVTG::has_speed_kn() const {
  return _internal_has_speed_kn();
}
inline void GNVTG::clear_speed_kn() {
  speed_kn_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float GNVTG::_internal_speed_kn() const {
  return speed_kn_;
}
inline float GNVTG::speed_kn() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNVTG.speed_kn)
  return _internal_speed_kn();
}
inline void GNVTG::_internal_set_speed_kn(float value) {
  _has_bits_[0] |= 0x00000008u;
  speed_kn_ = value;
}
inline void GNVTG::set_speed_kn(float value) {
  _internal_set_speed_kn(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNVTG.speed_kn)
}

// required bool nautical_speed_indicator = 7;
inline bool GNVTG::_internal_has_nautical_speed_indicator() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GNVTG::has_nautical_speed_indicator() const {
  return _internal_has_nautical_speed_indicator();
}
inline void GNVTG::clear_nautical_speed_indicator() {
  nautical_speed_indicator_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool GNVTG::_internal_nautical_speed_indicator() const {
  return nautical_speed_indicator_;
}
inline bool GNVTG::nautical_speed_indicator() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNVTG.nautical_speed_indicator)
  return _internal_nautical_speed_indicator();
}
inline void GNVTG::_internal_set_nautical_speed_indicator(bool value) {
  _has_bits_[0] |= 0x00000040u;
  nautical_speed_indicator_ = value;
}
inline void GNVTG::set_nautical_speed_indicator(bool value) {
  _internal_set_nautical_speed_indicator(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNVTG.nautical_speed_indicator)
}

// required float speed_km = 8;
inline bool GNVTG::_internal_has_speed_km() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool GNVTG::has_speed_km() const {
  return _internal_has_speed_km();
}
inline void GNVTG::clear_speed_km() {
  speed_km_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float GNVTG::_internal_speed_km() const {
  return speed_km_;
}
inline float GNVTG::speed_km() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNVTG.speed_km)
  return _internal_speed_km();
}
inline void GNVTG::_internal_set_speed_km(float value) {
  _has_bits_[0] |= 0x00000100u;
  speed_km_ = value;
}
inline void GNVTG::set_speed_km(float value) {
  _internal_set_speed_km(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNVTG.speed_km)
}

// required bool speed_indicator = 9;
inline bool GNVTG::_internal_has_speed_indicator() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool GNVTG::has_speed_indicator() const {
  return _internal_has_speed_indicator();
}
inline void GNVTG::clear_speed_indicator() {
  speed_indicator_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool GNVTG::_internal_speed_indicator() const {
  return speed_indicator_;
}
inline bool GNVTG::speed_indicator() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNVTG.speed_indicator)
  return _internal_speed_indicator();
}
inline void GNVTG::_internal_set_speed_indicator(bool value) {
  _has_bits_[0] |= 0x00000080u;
  speed_indicator_ = value;
}
inline void GNVTG::set_speed_indicator(bool value) {
  _internal_set_speed_indicator(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNVTG.speed_indicator)
}

// required .civ.drivers.rawgnss.GNVTG.PositionSystemModeIndicator mode_indicator = 10;
inline bool GNVTG::_internal_has_mode_indicator() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool GNVTG::has_mode_indicator() const {
  return _internal_has_mode_indicator();
}
inline void GNVTG::clear_mode_indicator() {
  mode_indicator_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator GNVTG::_internal_mode_indicator() const {
  return static_cast< ::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator >(mode_indicator_);
}
inline ::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator GNVTG::mode_indicator() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.GNVTG.mode_indicator)
  return _internal_mode_indicator();
}
inline void GNVTG::_internal_set_mode_indicator(::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator value) {
  assert(::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  mode_indicator_ = value;
}
inline void GNVTG::set_mode_indicator(::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator value) {
  _internal_set_mode_indicator(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.GNVTG.mode_indicator)
}

// -------------------------------------------------------------------

// Heading2

// required .civ.drivers.rawgnss.GnssHeader gnss_header = 1;
inline bool Heading2::_internal_has_gnss_header() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || gnss_header_ != nullptr);
  return value;
}
inline bool Heading2::has_gnss_header() const {
  return _internal_has_gnss_header();
}
inline void Heading2::clear_gnss_header() {
  if (gnss_header_ != nullptr) gnss_header_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::civ::drivers::rawgnss::GnssHeader& Heading2::_internal_gnss_header() const {
  const ::civ::drivers::rawgnss::GnssHeader* p = gnss_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::drivers::rawgnss::GnssHeader&>(
      ::civ::drivers::rawgnss::_GnssHeader_default_instance_);
}
inline const ::civ::drivers::rawgnss::GnssHeader& Heading2::gnss_header() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.gnss_header)
  return _internal_gnss_header();
}
inline void Heading2::unsafe_arena_set_allocated_gnss_header(
    ::civ::drivers::rawgnss::GnssHeader* gnss_header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gnss_header_);
  }
  gnss_header_ = gnss_header;
  if (gnss_header) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.drivers.rawgnss.Heading2.gnss_header)
}
inline ::civ::drivers::rawgnss::GnssHeader* Heading2::release_gnss_header() {
  _has_bits_[0] &= ~0x00000004u;
  ::civ::drivers::rawgnss::GnssHeader* temp = gnss_header_;
  gnss_header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::drivers::rawgnss::GnssHeader* Heading2::unsafe_arena_release_gnss_header() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.Heading2.gnss_header)
  _has_bits_[0] &= ~0x00000004u;
  ::civ::drivers::rawgnss::GnssHeader* temp = gnss_header_;
  gnss_header_ = nullptr;
  return temp;
}
inline ::civ::drivers::rawgnss::GnssHeader* Heading2::_internal_mutable_gnss_header() {
  _has_bits_[0] |= 0x00000004u;
  if (gnss_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::drivers::rawgnss::GnssHeader>(GetArena());
    gnss_header_ = p;
  }
  return gnss_header_;
}
inline ::civ::drivers::rawgnss::GnssHeader* Heading2::mutable_gnss_header() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.Heading2.gnss_header)
  return _internal_mutable_gnss_header();
}
inline void Heading2::set_allocated_gnss_header(::civ::drivers::rawgnss::GnssHeader* gnss_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gnss_header_;
  }
  if (gnss_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gnss_header);
    if (message_arena != submessage_arena) {
      gnss_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gnss_header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gnss_header_ = gnss_header;
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.Heading2.gnss_header)
}

// optional .civ.drivers.rawgnss.SolutionStatus solution_status = 2;
inline bool Heading2::_internal_has_solution_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Heading2::has_solution_status() const {
  return _internal_has_solution_status();
}
inline void Heading2::clear_solution_status() {
  solution_status_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::civ::drivers::rawgnss::SolutionStatus Heading2::_internal_solution_status() const {
  return static_cast< ::civ::drivers::rawgnss::SolutionStatus >(solution_status_);
}
inline ::civ::drivers::rawgnss::SolutionStatus Heading2::solution_status() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.solution_status)
  return _internal_solution_status();
}
inline void Heading2::_internal_set_solution_status(::civ::drivers::rawgnss::SolutionStatus value) {
  assert(::civ::drivers::rawgnss::SolutionStatus_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  solution_status_ = value;
}
inline void Heading2::set_solution_status(::civ::drivers::rawgnss::SolutionStatus value) {
  _internal_set_solution_status(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.solution_status)
}

// optional .civ.drivers.rawgnss.PositonVelocityType pos_type = 3;
inline bool Heading2::_internal_has_pos_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Heading2::has_pos_type() const {
  return _internal_has_pos_type();
}
inline void Heading2::clear_pos_type() {
  pos_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::civ::drivers::rawgnss::PositonVelocityType Heading2::_internal_pos_type() const {
  return static_cast< ::civ::drivers::rawgnss::PositonVelocityType >(pos_type_);
}
inline ::civ::drivers::rawgnss::PositonVelocityType Heading2::pos_type() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.pos_type)
  return _internal_pos_type();
}
inline void Heading2::_internal_set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value) {
  assert(::civ::drivers::rawgnss::PositonVelocityType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  pos_type_ = value;
}
inline void Heading2::set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value) {
  _internal_set_pos_type(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.pos_type)
}

// required float baseline_length_in_metres = 4;
inline bool Heading2::_internal_has_baseline_length_in_metres() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Heading2::has_baseline_length_in_metres() const {
  return _internal_has_baseline_length_in_metres();
}
inline void Heading2::clear_baseline_length_in_metres() {
  baseline_length_in_metres_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Heading2::_internal_baseline_length_in_metres() const {
  return baseline_length_in_metres_;
}
inline float Heading2::baseline_length_in_metres() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.baseline_length_in_metres)
  return _internal_baseline_length_in_metres();
}
inline void Heading2::_internal_set_baseline_length_in_metres(float value) {
  _has_bits_[0] |= 0x00000020u;
  baseline_length_in_metres_ = value;
}
inline void Heading2::set_baseline_length_in_metres(float value) {
  _internal_set_baseline_length_in_metres(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.baseline_length_in_metres)
}

// required float heading_in_degrees = 5;
inline bool Heading2::_internal_has_heading_in_degrees() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Heading2::has_heading_in_degrees() const {
  return _internal_has_heading_in_degrees();
}
inline void Heading2::clear_heading_in_degrees() {
  heading_in_degrees_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float Heading2::_internal_heading_in_degrees() const {
  return heading_in_degrees_;
}
inline float Heading2::heading_in_degrees() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.heading_in_degrees)
  return _internal_heading_in_degrees();
}
inline void Heading2::_internal_set_heading_in_degrees(float value) {
  _has_bits_[0] |= 0x00000040u;
  heading_in_degrees_ = value;
}
inline void Heading2::set_heading_in_degrees(float value) {
  _internal_set_heading_in_degrees(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.heading_in_degrees)
}

// required float pitch_in_degrees = 6;
inline bool Heading2::_internal_has_pitch_in_degrees() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Heading2::has_pitch_in_degrees() const {
  return _internal_has_pitch_in_degrees();
}
inline void Heading2::clear_pitch_in_degrees() {
  pitch_in_degrees_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Heading2::_internal_pitch_in_degrees() const {
  return pitch_in_degrees_;
}
inline float Heading2::pitch_in_degrees() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.pitch_in_degrees)
  return _internal_pitch_in_degrees();
}
inline void Heading2::_internal_set_pitch_in_degrees(float value) {
  _has_bits_[0] |= 0x00000080u;
  pitch_in_degrees_ = value;
}
inline void Heading2::set_pitch_in_degrees(float value) {
  _internal_set_pitch_in_degrees(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.pitch_in_degrees)
}

// required float reserved = 7 [default = 0];
inline bool Heading2::_internal_has_reserved() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Heading2::has_reserved() const {
  return _internal_has_reserved();
}
inline void Heading2::clear_reserved() {
  reserved_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float Heading2::_internal_reserved() const {
  return reserved_;
}
inline float Heading2::reserved() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.reserved)
  return _internal_reserved();
}
inline void Heading2::_internal_set_reserved(float value) {
  _has_bits_[0] |= 0x00000100u;
  reserved_ = value;
}
inline void Heading2::set_reserved(float value) {
  _internal_set_reserved(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.reserved)
}

// required float heading_std_dev = 8;
inline bool Heading2::_internal_has_heading_std_dev() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Heading2::has_heading_std_dev() const {
  return _internal_has_heading_std_dev();
}
inline void Heading2::clear_heading_std_dev() {
  heading_std_dev_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float Heading2::_internal_heading_std_dev() const {
  return heading_std_dev_;
}
inline float Heading2::heading_std_dev() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.heading_std_dev)
  return _internal_heading_std_dev();
}
inline void Heading2::_internal_set_heading_std_dev(float value) {
  _has_bits_[0] |= 0x00000200u;
  heading_std_dev_ = value;
}
inline void Heading2::set_heading_std_dev(float value) {
  _internal_set_heading_std_dev(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.heading_std_dev)
}

// required float pitch_std_dev = 9;
inline bool Heading2::_internal_has_pitch_std_dev() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Heading2::has_pitch_std_dev() const {
  return _internal_has_pitch_std_dev();
}
inline void Heading2::clear_pitch_std_dev() {
  pitch_std_dev_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float Heading2::_internal_pitch_std_dev() const {
  return pitch_std_dev_;
}
inline float Heading2::pitch_std_dev() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.pitch_std_dev)
  return _internal_pitch_std_dev();
}
inline void Heading2::_internal_set_pitch_std_dev(float value) {
  _has_bits_[0] |= 0x00000400u;
  pitch_std_dev_ = value;
}
inline void Heading2::set_pitch_std_dev(float value) {
  _internal_set_pitch_std_dev(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.pitch_std_dev)
}

// required string rover_receiver_id = 10;
inline bool Heading2::_internal_has_rover_receiver_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Heading2::has_rover_receiver_id() const {
  return _internal_has_rover_receiver_id();
}
inline void Heading2::clear_rover_receiver_id() {
  rover_receiver_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Heading2::rover_receiver_id() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.rover_receiver_id)
  return _internal_rover_receiver_id();
}
inline void Heading2::set_rover_receiver_id(const std::string& value) {
  _internal_set_rover_receiver_id(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.rover_receiver_id)
}
inline std::string* Heading2::mutable_rover_receiver_id() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.Heading2.rover_receiver_id)
  return _internal_mutable_rover_receiver_id();
}
inline const std::string& Heading2::_internal_rover_receiver_id() const {
  return rover_receiver_id_.Get();
}
inline void Heading2::_internal_set_rover_receiver_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  rover_receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Heading2::set_rover_receiver_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  rover_receiver_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.drivers.rawgnss.Heading2.rover_receiver_id)
}
inline void Heading2::set_rover_receiver_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  rover_receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.drivers.rawgnss.Heading2.rover_receiver_id)
}
inline void Heading2::set_rover_receiver_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  rover_receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.drivers.rawgnss.Heading2.rover_receiver_id)
}
inline std::string* Heading2::_internal_mutable_rover_receiver_id() {
  _has_bits_[0] |= 0x00000001u;
  return rover_receiver_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Heading2::release_rover_receiver_id() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.Heading2.rover_receiver_id)
  if (!_internal_has_rover_receiver_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return rover_receiver_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Heading2::set_allocated_rover_receiver_id(std::string* rover_receiver_id) {
  if (rover_receiver_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rover_receiver_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rover_receiver_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.Heading2.rover_receiver_id)
}

// required string master_receiver_id = 11;
inline bool Heading2::_internal_has_master_receiver_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Heading2::has_master_receiver_id() const {
  return _internal_has_master_receiver_id();
}
inline void Heading2::clear_master_receiver_id() {
  master_receiver_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Heading2::master_receiver_id() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.master_receiver_id)
  return _internal_master_receiver_id();
}
inline void Heading2::set_master_receiver_id(const std::string& value) {
  _internal_set_master_receiver_id(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.master_receiver_id)
}
inline std::string* Heading2::mutable_master_receiver_id() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.Heading2.master_receiver_id)
  return _internal_mutable_master_receiver_id();
}
inline const std::string& Heading2::_internal_master_receiver_id() const {
  return master_receiver_id_.Get();
}
inline void Heading2::_internal_set_master_receiver_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  master_receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Heading2::set_master_receiver_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  master_receiver_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.drivers.rawgnss.Heading2.master_receiver_id)
}
inline void Heading2::set_master_receiver_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  master_receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.drivers.rawgnss.Heading2.master_receiver_id)
}
inline void Heading2::set_master_receiver_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  master_receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.drivers.rawgnss.Heading2.master_receiver_id)
}
inline std::string* Heading2::_internal_mutable_master_receiver_id() {
  _has_bits_[0] |= 0x00000002u;
  return master_receiver_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Heading2::release_master_receiver_id() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.Heading2.master_receiver_id)
  if (!_internal_has_master_receiver_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return master_receiver_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Heading2::set_allocated_master_receiver_id(std::string* master_receiver_id) {
  if (master_receiver_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  master_receiver_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), master_receiver_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.Heading2.master_receiver_id)
}

// required uint32 num_of_satellites_tracked = 12;
inline bool Heading2::_internal_has_num_of_satellites_tracked() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Heading2::has_num_of_satellites_tracked() const {
  return _internal_has_num_of_satellites_tracked();
}
inline void Heading2::clear_num_of_satellites_tracked() {
  num_of_satellites_tracked_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::_internal_num_of_satellites_tracked() const {
  return num_of_satellites_tracked_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::num_of_satellites_tracked() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.num_of_satellites_tracked)
  return _internal_num_of_satellites_tracked();
}
inline void Heading2::_internal_set_num_of_satellites_tracked(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  num_of_satellites_tracked_ = value;
}
inline void Heading2::set_num_of_satellites_tracked(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_of_satellites_tracked(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.num_of_satellites_tracked)
}

// required uint32 num_of_satellites_in_solution = 13;
inline bool Heading2::_internal_has_num_of_satellites_in_solution() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Heading2::has_num_of_satellites_in_solution() const {
  return _internal_has_num_of_satellites_in_solution();
}
inline void Heading2::clear_num_of_satellites_in_solution() {
  num_of_satellites_in_solution_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::_internal_num_of_satellites_in_solution() const {
  return num_of_satellites_in_solution_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::num_of_satellites_in_solution() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.num_of_satellites_in_solution)
  return _internal_num_of_satellites_in_solution();
}
inline void Heading2::_internal_set_num_of_satellites_in_solution(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  num_of_satellites_in_solution_ = value;
}
inline void Heading2::set_num_of_satellites_in_solution(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_of_satellites_in_solution(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.num_of_satellites_in_solution)
}

// required uint32 num_of_satellites_above_mask_angle = 14;
inline bool Heading2::_internal_has_num_of_satellites_above_mask_angle() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Heading2::has_num_of_satellites_above_mask_angle() const {
  return _internal_has_num_of_satellites_above_mask_angle();
}
inline void Heading2::clear_num_of_satellites_above_mask_angle() {
  num_of_satellites_above_mask_angle_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::_internal_num_of_satellites_above_mask_angle() const {
  return num_of_satellites_above_mask_angle_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::num_of_satellites_above_mask_angle() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.num_of_satellites_above_mask_angle)
  return _internal_num_of_satellites_above_mask_angle();
}
inline void Heading2::_internal_set_num_of_satellites_above_mask_angle(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  num_of_satellites_above_mask_angle_ = value;
}
inline void Heading2::set_num_of_satellites_above_mask_angle(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_of_satellites_above_mask_angle(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.num_of_satellites_above_mask_angle)
}

// required uint32 num_of_satellites_above_mask_angle_l2 = 15;
inline bool Heading2::_internal_has_num_of_satellites_above_mask_angle_l2() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Heading2::has_num_of_satellites_above_mask_angle_l2() const {
  return _internal_has_num_of_satellites_above_mask_angle_l2();
}
inline void Heading2::clear_num_of_satellites_above_mask_angle_l2() {
  num_of_satellites_above_mask_angle_l2_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::_internal_num_of_satellites_above_mask_angle_l2() const {
  return num_of_satellites_above_mask_angle_l2_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::num_of_satellites_above_mask_angle_l2() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.num_of_satellites_above_mask_angle_l2)
  return _internal_num_of_satellites_above_mask_angle_l2();
}
inline void Heading2::_internal_set_num_of_satellites_above_mask_angle_l2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  num_of_satellites_above_mask_angle_l2_ = value;
}
inline void Heading2::set_num_of_satellites_above_mask_angle_l2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_of_satellites_above_mask_angle_l2(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.num_of_satellites_above_mask_angle_l2)
}

// required uint32 solution_source = 16;
inline bool Heading2::_internal_has_solution_source() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Heading2::has_solution_source() const {
  return _internal_has_solution_source();
}
inline void Heading2::clear_solution_source() {
  solution_source_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::_internal_solution_source() const {
  return solution_source_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::solution_source() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.solution_source)
  return _internal_solution_source();
}
inline void Heading2::_internal_set_solution_source(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  solution_source_ = value;
}
inline void Heading2::set_solution_source(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_solution_source(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.solution_source)
}

// required uint32 extended_solution_status = 17;
inline bool Heading2::_internal_has_extended_solution_status() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Heading2::has_extended_solution_status() const {
  return _internal_has_extended_solution_status();
}
inline void Heading2::clear_extended_solution_status() {
  extended_solution_status_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::_internal_extended_solution_status() const {
  return extended_solution_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::extended_solution_status() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.extended_solution_status)
  return _internal_extended_solution_status();
}
inline void Heading2::_internal_set_extended_solution_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  extended_solution_status_ = value;
}
inline void Heading2::set_extended_solution_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_extended_solution_status(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.extended_solution_status)
}

// required uint32 galileo_beidou_sig_mask = 18;
inline bool Heading2::_internal_has_galileo_beidou_sig_mask() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Heading2::has_galileo_beidou_sig_mask() const {
  return _internal_has_galileo_beidou_sig_mask();
}
inline void Heading2::clear_galileo_beidou_sig_mask() {
  galileo_beidou_sig_mask_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::_internal_galileo_beidou_sig_mask() const {
  return galileo_beidou_sig_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::galileo_beidou_sig_mask() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.galileo_beidou_sig_mask)
  return _internal_galileo_beidou_sig_mask();
}
inline void Heading2::_internal_set_galileo_beidou_sig_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00020000u;
  galileo_beidou_sig_mask_ = value;
}
inline void Heading2::set_galileo_beidou_sig_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_galileo_beidou_sig_mask(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.galileo_beidou_sig_mask)
}

// required uint32 gps_glonass_sig_mask = 19;
inline bool Heading2::_internal_has_gps_glonass_sig_mask() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Heading2::has_gps_glonass_sig_mask() const {
  return _internal_has_gps_glonass_sig_mask();
}
inline void Heading2::clear_gps_glonass_sig_mask() {
  gps_glonass_sig_mask_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::_internal_gps_glonass_sig_mask() const {
  return gps_glonass_sig_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Heading2::gps_glonass_sig_mask() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.Heading2.gps_glonass_sig_mask)
  return _internal_gps_glonass_sig_mask();
}
inline void Heading2::_internal_set_gps_glonass_sig_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00040000u;
  gps_glonass_sig_mask_ = value;
}
inline void Heading2::set_gps_glonass_sig_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_gps_glonass_sig_mask(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.Heading2.gps_glonass_sig_mask)
}

// -------------------------------------------------------------------

// RawImu

// required .civ.drivers.rawgnss.GnssHeader gnss_header = 1;
inline bool RawImu::_internal_has_gnss_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || gnss_header_ != nullptr);
  return value;
}
inline bool RawImu::has_gnss_header() const {
  return _internal_has_gnss_header();
}
inline void RawImu::clear_gnss_header() {
  if (gnss_header_ != nullptr) gnss_header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::civ::drivers::rawgnss::GnssHeader& RawImu::_internal_gnss_header() const {
  const ::civ::drivers::rawgnss::GnssHeader* p = gnss_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::drivers::rawgnss::GnssHeader&>(
      ::civ::drivers::rawgnss::_GnssHeader_default_instance_);
}
inline const ::civ::drivers::rawgnss::GnssHeader& RawImu::gnss_header() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.RawImu.gnss_header)
  return _internal_gnss_header();
}
inline void RawImu::unsafe_arena_set_allocated_gnss_header(
    ::civ::drivers::rawgnss::GnssHeader* gnss_header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gnss_header_);
  }
  gnss_header_ = gnss_header;
  if (gnss_header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.drivers.rawgnss.RawImu.gnss_header)
}
inline ::civ::drivers::rawgnss::GnssHeader* RawImu::release_gnss_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::civ::drivers::rawgnss::GnssHeader* temp = gnss_header_;
  gnss_header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::drivers::rawgnss::GnssHeader* RawImu::unsafe_arena_release_gnss_header() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.RawImu.gnss_header)
  _has_bits_[0] &= ~0x00000001u;
  ::civ::drivers::rawgnss::GnssHeader* temp = gnss_header_;
  gnss_header_ = nullptr;
  return temp;
}
inline ::civ::drivers::rawgnss::GnssHeader* RawImu::_internal_mutable_gnss_header() {
  _has_bits_[0] |= 0x00000001u;
  if (gnss_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::drivers::rawgnss::GnssHeader>(GetArena());
    gnss_header_ = p;
  }
  return gnss_header_;
}
inline ::civ::drivers::rawgnss::GnssHeader* RawImu::mutable_gnss_header() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.RawImu.gnss_header)
  return _internal_mutable_gnss_header();
}
inline void RawImu::set_allocated_gnss_header(::civ::drivers::rawgnss::GnssHeader* gnss_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gnss_header_;
  }
  if (gnss_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gnss_header);
    if (message_arena != submessage_arena) {
      gnss_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gnss_header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gnss_header_ = gnss_header;
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.RawImu.gnss_header)
}

// required uint32 gnss_week = 2;
inline bool RawImu::_internal_has_gnss_week() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RawImu::has_gnss_week() const {
  return _internal_has_gnss_week();
}
inline void RawImu::clear_gnss_week() {
  gnss_week_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawImu::_internal_gnss_week() const {
  return gnss_week_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawImu::gnss_week() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.RawImu.gnss_week)
  return _internal_gnss_week();
}
inline void RawImu::_internal_set_gnss_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  gnss_week_ = value;
}
inline void RawImu::set_gnss_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_gnss_week(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.RawImu.gnss_week)
}

// required double seconds_into_week = 3;
inline bool RawImu::_internal_has_seconds_into_week() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RawImu::has_seconds_into_week() const {
  return _internal_has_seconds_into_week();
}
inline void RawImu::clear_seconds_into_week() {
  seconds_into_week_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double RawImu::_internal_seconds_into_week() const {
  return seconds_into_week_;
}
inline double RawImu::seconds_into_week() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.RawImu.seconds_into_week)
  return _internal_seconds_into_week();
}
inline void RawImu::_internal_set_seconds_into_week(double value) {
  _has_bits_[0] |= 0x00000002u;
  seconds_into_week_ = value;
}
inline void RawImu::set_seconds_into_week(double value) {
  _internal_set_seconds_into_week(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.RawImu.seconds_into_week)
}

// required uint32 imu_status = 4;
inline bool RawImu::_internal_has_imu_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RawImu::has_imu_status() const {
  return _internal_has_imu_status();
}
inline void RawImu::clear_imu_status() {
  imu_status_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawImu::_internal_imu_status() const {
  return imu_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawImu::imu_status() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.RawImu.imu_status)
  return _internal_imu_status();
}
inline void RawImu::_internal_set_imu_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  imu_status_ = value;
}
inline void RawImu::set_imu_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_imu_status(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.RawImu.imu_status)
}

// required double z_accel_output = 5;
inline bool RawImu::_internal_has_z_accel_output() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RawImu::has_z_accel_output() const {
  return _internal_has_z_accel_output();
}
inline void RawImu::clear_z_accel_output() {
  z_accel_output_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double RawImu::_internal_z_accel_output() const {
  return z_accel_output_;
}
inline double RawImu::z_accel_output() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.RawImu.z_accel_output)
  return _internal_z_accel_output();
}
inline void RawImu::_internal_set_z_accel_output(double value) {
  _has_bits_[0] |= 0x00000010u;
  z_accel_output_ = value;
}
inline void RawImu::set_z_accel_output(double value) {
  _internal_set_z_accel_output(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.RawImu.z_accel_output)
}

// required double y_accel_output = 6;
inline bool RawImu::_internal_has_y_accel_output() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RawImu::has_y_accel_output() const {
  return _internal_has_y_accel_output();
}
inline void RawImu::clear_y_accel_output() {
  y_accel_output_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double RawImu::_internal_y_accel_output() const {
  return y_accel_output_;
}
inline double RawImu::y_accel_output() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.RawImu.y_accel_output)
  return _internal_y_accel_output();
}
inline void RawImu::_internal_set_y_accel_output(double value) {
  _has_bits_[0] |= 0x00000020u;
  y_accel_output_ = value;
}
inline void RawImu::set_y_accel_output(double value) {
  _internal_set_y_accel_output(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.RawImu.y_accel_output)
}

// required double x_accel_output = 7;
inline bool RawImu::_internal_has_x_accel_output() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RawImu::has_x_accel_output() const {
  return _internal_has_x_accel_output();
}
inline void RawImu::clear_x_accel_output() {
  x_accel_output_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double RawImu::_internal_x_accel_output() const {
  return x_accel_output_;
}
inline double RawImu::x_accel_output() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.RawImu.x_accel_output)
  return _internal_x_accel_output();
}
inline void RawImu::_internal_set_x_accel_output(double value) {
  _has_bits_[0] |= 0x00000040u;
  x_accel_output_ = value;
}
inline void RawImu::set_x_accel_output(double value) {
  _internal_set_x_accel_output(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.RawImu.x_accel_output)
}

// required double z_gyro_output = 8;
inline bool RawImu::_internal_has_z_gyro_output() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RawImu::has_z_gyro_output() const {
  return _internal_has_z_gyro_output();
}
inline void RawImu::clear_z_gyro_output() {
  z_gyro_output_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double RawImu::_internal_z_gyro_output() const {
  return z_gyro_output_;
}
inline double RawImu::z_gyro_output() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.RawImu.z_gyro_output)
  return _internal_z_gyro_output();
}
inline void RawImu::_internal_set_z_gyro_output(double value) {
  _has_bits_[0] |= 0x00000080u;
  z_gyro_output_ = value;
}
inline void RawImu::set_z_gyro_output(double value) {
  _internal_set_z_gyro_output(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.RawImu.z_gyro_output)
}

// required double y_gyro_output = 9;
inline bool RawImu::_internal_has_y_gyro_output() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool RawImu::has_y_gyro_output() const {
  return _internal_has_y_gyro_output();
}
inline void RawImu::clear_y_gyro_output() {
  y_gyro_output_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double RawImu::_internal_y_gyro_output() const {
  return y_gyro_output_;
}
inline double RawImu::y_gyro_output() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.RawImu.y_gyro_output)
  return _internal_y_gyro_output();
}
inline void RawImu::_internal_set_y_gyro_output(double value) {
  _has_bits_[0] |= 0x00000100u;
  y_gyro_output_ = value;
}
inline void RawImu::set_y_gyro_output(double value) {
  _internal_set_y_gyro_output(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.RawImu.y_gyro_output)
}

// required double x_gyro_output = 10;
inline bool RawImu::_internal_has_x_gyro_output() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool RawImu::has_x_gyro_output() const {
  return _internal_has_x_gyro_output();
}
inline void RawImu::clear_x_gyro_output() {
  x_gyro_output_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double RawImu::_internal_x_gyro_output() const {
  return x_gyro_output_;
}
inline double RawImu::x_gyro_output() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.RawImu.x_gyro_output)
  return _internal_x_gyro_output();
}
inline void RawImu::_internal_set_x_gyro_output(double value) {
  _has_bits_[0] |= 0x00000200u;
  x_gyro_output_ = value;
}
inline void RawImu::set_x_gyro_output(double value) {
  _internal_set_x_gyro_output(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.RawImu.x_gyro_output)
}

// -------------------------------------------------------------------

// BestVel

// required .civ.drivers.rawgnss.GnssHeader gnss_header = 1;
inline bool BestVel::_internal_has_gnss_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || gnss_header_ != nullptr);
  return value;
}
inline bool BestVel::has_gnss_header() const {
  return _internal_has_gnss_header();
}
inline void BestVel::clear_gnss_header() {
  if (gnss_header_ != nullptr) gnss_header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::civ::drivers::rawgnss::GnssHeader& BestVel::_internal_gnss_header() const {
  const ::civ::drivers::rawgnss::GnssHeader* p = gnss_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::drivers::rawgnss::GnssHeader&>(
      ::civ::drivers::rawgnss::_GnssHeader_default_instance_);
}
inline const ::civ::drivers::rawgnss::GnssHeader& BestVel::gnss_header() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.BestVel.gnss_header)
  return _internal_gnss_header();
}
inline void BestVel::unsafe_arena_set_allocated_gnss_header(
    ::civ::drivers::rawgnss::GnssHeader* gnss_header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gnss_header_);
  }
  gnss_header_ = gnss_header;
  if (gnss_header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.drivers.rawgnss.BestVel.gnss_header)
}
inline ::civ::drivers::rawgnss::GnssHeader* BestVel::release_gnss_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::civ::drivers::rawgnss::GnssHeader* temp = gnss_header_;
  gnss_header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::drivers::rawgnss::GnssHeader* BestVel::unsafe_arena_release_gnss_header() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.BestVel.gnss_header)
  _has_bits_[0] &= ~0x00000001u;
  ::civ::drivers::rawgnss::GnssHeader* temp = gnss_header_;
  gnss_header_ = nullptr;
  return temp;
}
inline ::civ::drivers::rawgnss::GnssHeader* BestVel::_internal_mutable_gnss_header() {
  _has_bits_[0] |= 0x00000001u;
  if (gnss_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::drivers::rawgnss::GnssHeader>(GetArena());
    gnss_header_ = p;
  }
  return gnss_header_;
}
inline ::civ::drivers::rawgnss::GnssHeader* BestVel::mutable_gnss_header() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.BestVel.gnss_header)
  return _internal_mutable_gnss_header();
}
inline void BestVel::set_allocated_gnss_header(::civ::drivers::rawgnss::GnssHeader* gnss_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gnss_header_;
  }
  if (gnss_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gnss_header);
    if (message_arena != submessage_arena) {
      gnss_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gnss_header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gnss_header_ = gnss_header;
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.BestVel.gnss_header)
}

// optional .civ.drivers.rawgnss.SolutionStatus solution_status = 2;
inline bool BestVel::_internal_has_solution_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BestVel::has_solution_status() const {
  return _internal_has_solution_status();
}
inline void BestVel::clear_solution_status() {
  solution_status_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::civ::drivers::rawgnss::SolutionStatus BestVel::_internal_solution_status() const {
  return static_cast< ::civ::drivers::rawgnss::SolutionStatus >(solution_status_);
}
inline ::civ::drivers::rawgnss::SolutionStatus BestVel::solution_status() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.BestVel.solution_status)
  return _internal_solution_status();
}
inline void BestVel::_internal_set_solution_status(::civ::drivers::rawgnss::SolutionStatus value) {
  assert(::civ::drivers::rawgnss::SolutionStatus_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  solution_status_ = value;
}
inline void BestVel::set_solution_status(::civ::drivers::rawgnss::SolutionStatus value) {
  _internal_set_solution_status(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.BestVel.solution_status)
}

// optional .civ.drivers.rawgnss.PositonVelocityType vel_type = 3;
inline bool BestVel::_internal_has_vel_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BestVel::has_vel_type() const {
  return _internal_has_vel_type();
}
inline void BestVel::clear_vel_type() {
  vel_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::civ::drivers::rawgnss::PositonVelocityType BestVel::_internal_vel_type() const {
  return static_cast< ::civ::drivers::rawgnss::PositonVelocityType >(vel_type_);
}
inline ::civ::drivers::rawgnss::PositonVelocityType BestVel::vel_type() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.BestVel.vel_type)
  return _internal_vel_type();
}
inline void BestVel::_internal_set_vel_type(::civ::drivers::rawgnss::PositonVelocityType value) {
  assert(::civ::drivers::rawgnss::PositonVelocityType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  vel_type_ = value;
}
inline void BestVel::set_vel_type(::civ::drivers::rawgnss::PositonVelocityType value) {
  _internal_set_vel_type(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.BestVel.vel_type)
}

// required float latency = 4;
inline bool BestVel::_internal_has_latency() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BestVel::has_latency() const {
  return _internal_has_latency();
}
inline void BestVel::clear_latency() {
  latency_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float BestVel::_internal_latency() const {
  return latency_;
}
inline float BestVel::latency() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.BestVel.latency)
  return _internal_latency();
}
inline void BestVel::_internal_set_latency(float value) {
  _has_bits_[0] |= 0x00000008u;
  latency_ = value;
}
inline void BestVel::set_latency(float value) {
  _internal_set_latency(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.BestVel.latency)
}

// required float diff_age_in_seconds = 5;
inline bool BestVel::_internal_has_diff_age_in_seconds() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BestVel::has_diff_age_in_seconds() const {
  return _internal_has_diff_age_in_seconds();
}
inline void BestVel::clear_diff_age_in_seconds() {
  diff_age_in_seconds_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float BestVel::_internal_diff_age_in_seconds() const {
  return diff_age_in_seconds_;
}
inline float BestVel::diff_age_in_seconds() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.BestVel.diff_age_in_seconds)
  return _internal_diff_age_in_seconds();
}
inline void BestVel::_internal_set_diff_age_in_seconds(float value) {
  _has_bits_[0] |= 0x00000010u;
  diff_age_in_seconds_ = value;
}
inline void BestVel::set_diff_age_in_seconds(float value) {
  _internal_set_diff_age_in_seconds(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.BestVel.diff_age_in_seconds)
}

// required double horizontal_speed_over_ground = 6;
inline bool BestVel::_internal_has_horizontal_speed_over_ground() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BestVel::has_horizontal_speed_over_ground() const {
  return _internal_has_horizontal_speed_over_ground();
}
inline void BestVel::clear_horizontal_speed_over_ground() {
  horizontal_speed_over_ground_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double BestVel::_internal_horizontal_speed_over_ground() const {
  return horizontal_speed_over_ground_;
}
inline double BestVel::horizontal_speed_over_ground() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.BestVel.horizontal_speed_over_ground)
  return _internal_horizontal_speed_over_ground();
}
inline void BestVel::_internal_set_horizontal_speed_over_ground(double value) {
  _has_bits_[0] |= 0x00000020u;
  horizontal_speed_over_ground_ = value;
}
inline void BestVel::set_horizontal_speed_over_ground(double value) {
  _internal_set_horizontal_speed_over_ground(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.BestVel.horizontal_speed_over_ground)
}

// required double track_over_ground = 7;
inline bool BestVel::_internal_has_track_over_ground() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BestVel::has_track_over_ground() const {
  return _internal_has_track_over_ground();
}
inline void BestVel::clear_track_over_ground() {
  track_over_ground_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double BestVel::_internal_track_over_ground() const {
  return track_over_ground_;
}
inline double BestVel::track_over_ground() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.BestVel.track_over_ground)
  return _internal_track_over_ground();
}
inline void BestVel::_internal_set_track_over_ground(double value) {
  _has_bits_[0] |= 0x00000040u;
  track_over_ground_ = value;
}
inline void BestVel::set_track_over_ground(double value) {
  _internal_set_track_over_ground(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.BestVel.track_over_ground)
}

// required double vertical_speed = 8;
inline bool BestVel::_internal_has_vertical_speed() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BestVel::has_vertical_speed() const {
  return _internal_has_vertical_speed();
}
inline void BestVel::clear_vertical_speed() {
  vertical_speed_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double BestVel::_internal_vertical_speed() const {
  return vertical_speed_;
}
inline double BestVel::vertical_speed() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.BestVel.vertical_speed)
  return _internal_vertical_speed();
}
inline void BestVel::_internal_set_vertical_speed(double value) {
  _has_bits_[0] |= 0x00000080u;
  vertical_speed_ = value;
}
inline void BestVel::set_vertical_speed(double value) {
  _internal_set_vertical_speed(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.BestVel.vertical_speed)
}

// required float reserved = 9;
inline bool BestVel::_internal_has_reserved() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BestVel::has_reserved() const {
  return _internal_has_reserved();
}
inline void BestVel::clear_reserved() {
  reserved_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float BestVel::_internal_reserved() const {
  return reserved_;
}
inline float BestVel::reserved() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.BestVel.reserved)
  return _internal_reserved();
}
inline void BestVel::_internal_set_reserved(float value) {
  _has_bits_[0] |= 0x00000100u;
  reserved_ = value;
}
inline void BestVel::set_reserved(float value) {
  _internal_set_reserved(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.BestVel.reserved)
}

// -------------------------------------------------------------------

// InspVax

// required .civ.drivers.rawgnss.GnssHeader gnss_header = 1;
inline bool InspVax::_internal_has_gnss_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || gnss_header_ != nullptr);
  return value;
}
inline bool InspVax::has_gnss_header() const {
  return _internal_has_gnss_header();
}
inline void InspVax::clear_gnss_header() {
  if (gnss_header_ != nullptr) gnss_header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::civ::drivers::rawgnss::GnssHeader& InspVax::_internal_gnss_header() const {
  const ::civ::drivers::rawgnss::GnssHeader* p = gnss_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::drivers::rawgnss::GnssHeader&>(
      ::civ::drivers::rawgnss::_GnssHeader_default_instance_);
}
inline const ::civ::drivers::rawgnss::GnssHeader& InspVax::gnss_header() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.gnss_header)
  return _internal_gnss_header();
}
inline void InspVax::unsafe_arena_set_allocated_gnss_header(
    ::civ::drivers::rawgnss::GnssHeader* gnss_header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gnss_header_);
  }
  gnss_header_ = gnss_header;
  if (gnss_header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.drivers.rawgnss.InspVax.gnss_header)
}
inline ::civ::drivers::rawgnss::GnssHeader* InspVax::release_gnss_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::civ::drivers::rawgnss::GnssHeader* temp = gnss_header_;
  gnss_header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::drivers::rawgnss::GnssHeader* InspVax::unsafe_arena_release_gnss_header() {
  // @@protoc_insertion_point(field_release:civ.drivers.rawgnss.InspVax.gnss_header)
  _has_bits_[0] &= ~0x00000001u;
  ::civ::drivers::rawgnss::GnssHeader* temp = gnss_header_;
  gnss_header_ = nullptr;
  return temp;
}
inline ::civ::drivers::rawgnss::GnssHeader* InspVax::_internal_mutable_gnss_header() {
  _has_bits_[0] |= 0x00000001u;
  if (gnss_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::drivers::rawgnss::GnssHeader>(GetArena());
    gnss_header_ = p;
  }
  return gnss_header_;
}
inline ::civ::drivers::rawgnss::GnssHeader* InspVax::mutable_gnss_header() {
  // @@protoc_insertion_point(field_mutable:civ.drivers.rawgnss.InspVax.gnss_header)
  return _internal_mutable_gnss_header();
}
inline void InspVax::set_allocated_gnss_header(::civ::drivers::rawgnss::GnssHeader* gnss_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gnss_header_;
  }
  if (gnss_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gnss_header);
    if (message_arena != submessage_arena) {
      gnss_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gnss_header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gnss_header_ = gnss_header;
  // @@protoc_insertion_point(field_set_allocated:civ.drivers.rawgnss.InspVax.gnss_header)
}

// required .civ.drivers.rawgnss.InsStatus ins_status = 2;
inline bool InspVax::_internal_has_ins_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InspVax::has_ins_status() const {
  return _internal_has_ins_status();
}
inline void InspVax::clear_ins_status() {
  ins_status_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::civ::drivers::rawgnss::InsStatus InspVax::_internal_ins_status() const {
  return static_cast< ::civ::drivers::rawgnss::InsStatus >(ins_status_);
}
inline ::civ::drivers::rawgnss::InsStatus InspVax::ins_status() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.ins_status)
  return _internal_ins_status();
}
inline void InspVax::_internal_set_ins_status(::civ::drivers::rawgnss::InsStatus value) {
  assert(::civ::drivers::rawgnss::InsStatus_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  ins_status_ = value;
}
inline void InspVax::set_ins_status(::civ::drivers::rawgnss::InsStatus value) {
  _internal_set_ins_status(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.ins_status)
}

// optional .civ.drivers.rawgnss.PositonVelocityType pos_type = 3;
inline bool InspVax::_internal_has_pos_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InspVax::has_pos_type() const {
  return _internal_has_pos_type();
}
inline void InspVax::clear_pos_type() {
  pos_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::civ::drivers::rawgnss::PositonVelocityType InspVax::_internal_pos_type() const {
  return static_cast< ::civ::drivers::rawgnss::PositonVelocityType >(pos_type_);
}
inline ::civ::drivers::rawgnss::PositonVelocityType InspVax::pos_type() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.pos_type)
  return _internal_pos_type();
}
inline void InspVax::_internal_set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value) {
  assert(::civ::drivers::rawgnss::PositonVelocityType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  pos_type_ = value;
}
inline void InspVax::set_pos_type(::civ::drivers::rawgnss::PositonVelocityType value) {
  _internal_set_pos_type(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.pos_type)
}

// required double latitude = 4;
inline bool InspVax::_internal_has_latitude() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InspVax::has_latitude() const {
  return _internal_has_latitude();
}
inline void InspVax::clear_latitude() {
  latitude_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double InspVax::_internal_latitude() const {
  return latitude_;
}
inline double InspVax::latitude() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.latitude)
  return _internal_latitude();
}
inline void InspVax::_internal_set_latitude(double value) {
  _has_bits_[0] |= 0x00000008u;
  latitude_ = value;
}
inline void InspVax::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.latitude)
}

// required double longitude = 5;
inline bool InspVax::_internal_has_longitude() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InspVax::has_longitude() const {
  return _internal_has_longitude();
}
inline void InspVax::clear_longitude() {
  longitude_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double InspVax::_internal_longitude() const {
  return longitude_;
}
inline double InspVax::longitude() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.longitude)
  return _internal_longitude();
}
inline void InspVax::_internal_set_longitude(double value) {
  _has_bits_[0] |= 0x00000010u;
  longitude_ = value;
}
inline void InspVax::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.longitude)
}

// required double height = 6;
inline bool InspVax::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InspVax::has_height() const {
  return _internal_has_height();
}
inline void InspVax::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double InspVax::_internal_height() const {
  return height_;
}
inline double InspVax::height() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.height)
  return _internal_height();
}
inline void InspVax::_internal_set_height(double value) {
  _has_bits_[0] |= 0x00000020u;
  height_ = value;
}
inline void InspVax::set_height(double value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.height)
}

// required float undulation = 7;
inline bool InspVax::_internal_has_undulation() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool InspVax::has_undulation() const {
  return _internal_has_undulation();
}
inline void InspVax::clear_undulation() {
  undulation_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float InspVax::_internal_undulation() const {
  return undulation_;
}
inline float InspVax::undulation() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.undulation)
  return _internal_undulation();
}
inline void InspVax::_internal_set_undulation(float value) {
  _has_bits_[0] |= 0x00000200u;
  undulation_ = value;
}
inline void InspVax::set_undulation(float value) {
  _internal_set_undulation(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.undulation)
}

// required double north_velocity = 8;
inline bool InspVax::_internal_has_north_velocity() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InspVax::has_north_velocity() const {
  return _internal_has_north_velocity();
}
inline void InspVax::clear_north_velocity() {
  north_velocity_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double InspVax::_internal_north_velocity() const {
  return north_velocity_;
}
inline double InspVax::north_velocity() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.north_velocity)
  return _internal_north_velocity();
}
inline void InspVax::_internal_set_north_velocity(double value) {
  _has_bits_[0] |= 0x00000040u;
  north_velocity_ = value;
}
inline void InspVax::set_north_velocity(double value) {
  _internal_set_north_velocity(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.north_velocity)
}

// required double east_velocity = 9;
inline bool InspVax::_internal_has_east_velocity() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool InspVax::has_east_velocity() const {
  return _internal_has_east_velocity();
}
inline void InspVax::clear_east_velocity() {
  east_velocity_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double InspVax::_internal_east_velocity() const {
  return east_velocity_;
}
inline double InspVax::east_velocity() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.east_velocity)
  return _internal_east_velocity();
}
inline void InspVax::_internal_set_east_velocity(double value) {
  _has_bits_[0] |= 0x00000080u;
  east_velocity_ = value;
}
inline void InspVax::set_east_velocity(double value) {
  _internal_set_east_velocity(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.east_velocity)
}

// required double up_velocity = 10;
inline bool InspVax::_internal_has_up_velocity() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool InspVax::has_up_velocity() const {
  return _internal_has_up_velocity();
}
inline void InspVax::clear_up_velocity() {
  up_velocity_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double InspVax::_internal_up_velocity() const {
  return up_velocity_;
}
inline double InspVax::up_velocity() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.up_velocity)
  return _internal_up_velocity();
}
inline void InspVax::_internal_set_up_velocity(double value) {
  _has_bits_[0] |= 0x00000100u;
  up_velocity_ = value;
}
inline void InspVax::set_up_velocity(double value) {
  _internal_set_up_velocity(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.up_velocity)
}

// required double roll_in_local = 11;
inline bool InspVax::_internal_has_roll_in_local() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool InspVax::has_roll_in_local() const {
  return _internal_has_roll_in_local();
}
inline void InspVax::clear_roll_in_local() {
  roll_in_local_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline double InspVax::_internal_roll_in_local() const {
  return roll_in_local_;
}
inline double InspVax::roll_in_local() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.roll_in_local)
  return _internal_roll_in_local();
}
inline void InspVax::_internal_set_roll_in_local(double value) {
  _has_bits_[0] |= 0x00000800u;
  roll_in_local_ = value;
}
inline void InspVax::set_roll_in_local(double value) {
  _internal_set_roll_in_local(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.roll_in_local)
}

// required double pitch_in_local = 12;
inline bool InspVax::_internal_has_pitch_in_local() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool InspVax::has_pitch_in_local() const {
  return _internal_has_pitch_in_local();
}
inline void InspVax::clear_pitch_in_local() {
  pitch_in_local_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline double InspVax::_internal_pitch_in_local() const {
  return pitch_in_local_;
}
inline double InspVax::pitch_in_local() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.pitch_in_local)
  return _internal_pitch_in_local();
}
inline void InspVax::_internal_set_pitch_in_local(double value) {
  _has_bits_[0] |= 0x00001000u;
  pitch_in_local_ = value;
}
inline void InspVax::set_pitch_in_local(double value) {
  _internal_set_pitch_in_local(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.pitch_in_local)
}

// required double azimuth_in_local = 13;
inline bool InspVax::_internal_has_azimuth_in_local() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool InspVax::has_azimuth_in_local() const {
  return _internal_has_azimuth_in_local();
}
inline void InspVax::clear_azimuth_in_local() {
  azimuth_in_local_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline double InspVax::_internal_azimuth_in_local() const {
  return azimuth_in_local_;
}
inline double InspVax::azimuth_in_local() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.azimuth_in_local)
  return _internal_azimuth_in_local();
}
inline void InspVax::_internal_set_azimuth_in_local(double value) {
  _has_bits_[0] |= 0x00002000u;
  azimuth_in_local_ = value;
}
inline void InspVax::set_azimuth_in_local(double value) {
  _internal_set_azimuth_in_local(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.azimuth_in_local)
}

// required float latitude_std_deviation = 14;
inline bool InspVax::_internal_has_latitude_std_deviation() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool InspVax::has_latitude_std_deviation() const {
  return _internal_has_latitude_std_deviation();
}
inline void InspVax::clear_latitude_std_deviation() {
  latitude_std_deviation_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float InspVax::_internal_latitude_std_deviation() const {
  return latitude_std_deviation_;
}
inline float InspVax::latitude_std_deviation() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.latitude_std_deviation)
  return _internal_latitude_std_deviation();
}
inline void InspVax::_internal_set_latitude_std_deviation(float value) {
  _has_bits_[0] |= 0x00000400u;
  latitude_std_deviation_ = value;
}
inline void InspVax::set_latitude_std_deviation(float value) {
  _internal_set_latitude_std_deviation(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.latitude_std_deviation)
}

// required float longitude_std_deviation = 15;
inline bool InspVax::_internal_has_longitude_std_deviation() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool InspVax::has_longitude_std_deviation() const {
  return _internal_has_longitude_std_deviation();
}
inline void InspVax::clear_longitude_std_deviation() {
  longitude_std_deviation_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline float InspVax::_internal_longitude_std_deviation() const {
  return longitude_std_deviation_;
}
inline float InspVax::longitude_std_deviation() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.longitude_std_deviation)
  return _internal_longitude_std_deviation();
}
inline void InspVax::_internal_set_longitude_std_deviation(float value) {
  _has_bits_[0] |= 0x00004000u;
  longitude_std_deviation_ = value;
}
inline void InspVax::set_longitude_std_deviation(float value) {
  _internal_set_longitude_std_deviation(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.longitude_std_deviation)
}

// required float height_std_deviation = 16;
inline bool InspVax::_internal_has_height_std_deviation() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool InspVax::has_height_std_deviation() const {
  return _internal_has_height_std_deviation();
}
inline void InspVax::clear_height_std_deviation() {
  height_std_deviation_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline float InspVax::_internal_height_std_deviation() const {
  return height_std_deviation_;
}
inline float InspVax::height_std_deviation() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.height_std_deviation)
  return _internal_height_std_deviation();
}
inline void InspVax::_internal_set_height_std_deviation(float value) {
  _has_bits_[0] |= 0x00008000u;
  height_std_deviation_ = value;
}
inline void InspVax::set_height_std_deviation(float value) {
  _internal_set_height_std_deviation(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.height_std_deviation)
}

// required float north_velocity_std_deviation = 17;
inline bool InspVax::_internal_has_north_velocity_std_deviation() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool InspVax::has_north_velocity_std_deviation() const {
  return _internal_has_north_velocity_std_deviation();
}
inline void InspVax::clear_north_velocity_std_deviation() {
  north_velocity_std_deviation_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline float InspVax::_internal_north_velocity_std_deviation() const {
  return north_velocity_std_deviation_;
}
inline float InspVax::north_velocity_std_deviation() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.north_velocity_std_deviation)
  return _internal_north_velocity_std_deviation();
}
inline void InspVax::_internal_set_north_velocity_std_deviation(float value) {
  _has_bits_[0] |= 0x00010000u;
  north_velocity_std_deviation_ = value;
}
inline void InspVax::set_north_velocity_std_deviation(float value) {
  _internal_set_north_velocity_std_deviation(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.north_velocity_std_deviation)
}

// required float east_velocity_std_deviation = 18;
inline bool InspVax::_internal_has_east_velocity_std_deviation() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool InspVax::has_east_velocity_std_deviation() const {
  return _internal_has_east_velocity_std_deviation();
}
inline void InspVax::clear_east_velocity_std_deviation() {
  east_velocity_std_deviation_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline float InspVax::_internal_east_velocity_std_deviation() const {
  return east_velocity_std_deviation_;
}
inline float InspVax::east_velocity_std_deviation() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.east_velocity_std_deviation)
  return _internal_east_velocity_std_deviation();
}
inline void InspVax::_internal_set_east_velocity_std_deviation(float value) {
  _has_bits_[0] |= 0x00020000u;
  east_velocity_std_deviation_ = value;
}
inline void InspVax::set_east_velocity_std_deviation(float value) {
  _internal_set_east_velocity_std_deviation(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.east_velocity_std_deviation)
}

// required float up_velocity_std_deviation = 19;
inline bool InspVax::_internal_has_up_velocity_std_deviation() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool InspVax::has_up_velocity_std_deviation() const {
  return _internal_has_up_velocity_std_deviation();
}
inline void InspVax::clear_up_velocity_std_deviation() {
  up_velocity_std_deviation_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline float InspVax::_internal_up_velocity_std_deviation() const {
  return up_velocity_std_deviation_;
}
inline float InspVax::up_velocity_std_deviation() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.up_velocity_std_deviation)
  return _internal_up_velocity_std_deviation();
}
inline void InspVax::_internal_set_up_velocity_std_deviation(float value) {
  _has_bits_[0] |= 0x00040000u;
  up_velocity_std_deviation_ = value;
}
inline void InspVax::set_up_velocity_std_deviation(float value) {
  _internal_set_up_velocity_std_deviation(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.up_velocity_std_deviation)
}

// required float roll_std_deviation = 20;
inline bool InspVax::_internal_has_roll_std_deviation() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool InspVax::has_roll_std_deviation() const {
  return _internal_has_roll_std_deviation();
}
inline void InspVax::clear_roll_std_deviation() {
  roll_std_deviation_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline float InspVax::_internal_roll_std_deviation() const {
  return roll_std_deviation_;
}
inline float InspVax::roll_std_deviation() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.roll_std_deviation)
  return _internal_roll_std_deviation();
}
inline void InspVax::_internal_set_roll_std_deviation(float value) {
  _has_bits_[0] |= 0x00080000u;
  roll_std_deviation_ = value;
}
inline void InspVax::set_roll_std_deviation(float value) {
  _internal_set_roll_std_deviation(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.roll_std_deviation)
}

// required float pitch_std_deviation = 21;
inline bool InspVax::_internal_has_pitch_std_deviation() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool InspVax::has_pitch_std_deviation() const {
  return _internal_has_pitch_std_deviation();
}
inline void InspVax::clear_pitch_std_deviation() {
  pitch_std_deviation_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline float InspVax::_internal_pitch_std_deviation() const {
  return pitch_std_deviation_;
}
inline float InspVax::pitch_std_deviation() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.pitch_std_deviation)
  return _internal_pitch_std_deviation();
}
inline void InspVax::_internal_set_pitch_std_deviation(float value) {
  _has_bits_[0] |= 0x00100000u;
  pitch_std_deviation_ = value;
}
inline void InspVax::set_pitch_std_deviation(float value) {
  _internal_set_pitch_std_deviation(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.pitch_std_deviation)
}

// required float azimuth_std_deviation = 22;
inline bool InspVax::_internal_has_azimuth_std_deviation() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool InspVax::has_azimuth_std_deviation() const {
  return _internal_has_azimuth_std_deviation();
}
inline void InspVax::clear_azimuth_std_deviation() {
  azimuth_std_deviation_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline float InspVax::_internal_azimuth_std_deviation() const {
  return azimuth_std_deviation_;
}
inline float InspVax::azimuth_std_deviation() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.azimuth_std_deviation)
  return _internal_azimuth_std_deviation();
}
inline void InspVax::_internal_set_azimuth_std_deviation(float value) {
  _has_bits_[0] |= 0x00200000u;
  azimuth_std_deviation_ = value;
}
inline void InspVax::set_azimuth_std_deviation(float value) {
  _internal_set_azimuth_std_deviation(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.azimuth_std_deviation)
}

// required uint32 ext_sol_status = 23;
inline bool InspVax::_internal_has_ext_sol_status() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool InspVax::has_ext_sol_status() const {
  return _internal_has_ext_sol_status();
}
inline void InspVax::clear_ext_sol_status() {
  ext_sol_status_ = 0u;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InspVax::_internal_ext_sol_status() const {
  return ext_sol_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InspVax::ext_sol_status() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.ext_sol_status)
  return _internal_ext_sol_status();
}
inline void InspVax::_internal_set_ext_sol_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00400000u;
  ext_sol_status_ = value;
}
inline void InspVax::set_ext_sol_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ext_sol_status(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.ext_sol_status)
}

// required uint32 time_since_update = 24;
inline bool InspVax::_internal_has_time_since_update() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool InspVax::has_time_since_update() const {
  return _internal_has_time_since_update();
}
inline void InspVax::clear_time_since_update() {
  time_since_update_ = 0u;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InspVax::_internal_time_since_update() const {
  return time_since_update_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InspVax::time_since_update() const {
  // @@protoc_insertion_point(field_get:civ.drivers.rawgnss.InspVax.time_since_update)
  return _internal_time_since_update();
}
inline void InspVax::_internal_set_time_since_update(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00800000u;
  time_since_update_ = value;
}
inline void InspVax::set_time_since_update(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_time_since_update(value);
  // @@protoc_insertion_point(field_set:civ.drivers.rawgnss.InspVax.time_since_update)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rawgnss
}  // namespace drivers
}  // namespace civ

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::civ::drivers::rawgnss::GNGGA_LatitudeDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::drivers::rawgnss::GNGGA_LatitudeDirection>() {
  return ::civ::drivers::rawgnss::GNGGA_LatitudeDirection_descriptor();
}
template <> struct is_proto_enum< ::civ::drivers::rawgnss::GNGGA_LongitudeDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::drivers::rawgnss::GNGGA_LongitudeDirection>() {
  return ::civ::drivers::rawgnss::GNGGA_LongitudeDirection_descriptor();
}
template <> struct is_proto_enum< ::civ::drivers::rawgnss::GNGGA_UnitTypes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::drivers::rawgnss::GNGGA_UnitTypes>() {
  return ::civ::drivers::rawgnss::GNGGA_UnitTypes_descriptor();
}
template <> struct is_proto_enum< ::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator>() {
  return ::civ::drivers::rawgnss::GNVTG_PositionSystemModeIndicator_descriptor();
}
template <> struct is_proto_enum< ::civ::drivers::rawgnss::TimeStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::drivers::rawgnss::TimeStatus>() {
  return ::civ::drivers::rawgnss::TimeStatus_descriptor();
}
template <> struct is_proto_enum< ::civ::drivers::rawgnss::SolutionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::drivers::rawgnss::SolutionStatus>() {
  return ::civ::drivers::rawgnss::SolutionStatus_descriptor();
}
template <> struct is_proto_enum< ::civ::drivers::rawgnss::PositonVelocityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::drivers::rawgnss::PositonVelocityType>() {
  return ::civ::drivers::rawgnss::PositonVelocityType_descriptor();
}
template <> struct is_proto_enum< ::civ::drivers::rawgnss::DatumID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::drivers::rawgnss::DatumID>() {
  return ::civ::drivers::rawgnss::DatumID_descriptor();
}
template <> struct is_proto_enum< ::civ::drivers::rawgnss::InsStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::drivers::rawgnss::InsStatus>() {
  return ::civ::drivers::rawgnss::InsStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2fdrivers_2fgnss_2fproto_2fraw_5fgnss_2eproto
