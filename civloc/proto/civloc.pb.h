// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: civloc/proto/civloc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_civloc_2fproto_2fcivloc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_civloc_2fproto_2fcivloc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_civloc_2fproto_2fcivloc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_civloc_2fproto_2fcivloc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_civloc_2fproto_2fcivloc_2eproto;
namespace civ {
namespace civloc {
class ChanelConfig;
class ChanelConfigDefaultTypeInternal;
extern ChanelConfigDefaultTypeInternal _ChanelConfig_default_instance_;
class CivLocConfig;
class CivLocConfigDefaultTypeInternal;
extern CivLocConfigDefaultTypeInternal _CivLocConfig_default_instance_;
class PerceptionChanelConfig;
class PerceptionChanelConfigDefaultTypeInternal;
extern PerceptionChanelConfigDefaultTypeInternal _PerceptionChanelConfig_default_instance_;
class TFConfig;
class TFConfigDefaultTypeInternal;
extern TFConfigDefaultTypeInternal _TFConfig_default_instance_;
}  // namespace civloc
}  // namespace civ
PROTOBUF_NAMESPACE_OPEN
template<> ::civ::civloc::ChanelConfig* Arena::CreateMaybeMessage<::civ::civloc::ChanelConfig>(Arena*);
template<> ::civ::civloc::CivLocConfig* Arena::CreateMaybeMessage<::civ::civloc::CivLocConfig>(Arena*);
template<> ::civ::civloc::PerceptionChanelConfig* Arena::CreateMaybeMessage<::civ::civloc::PerceptionChanelConfig>(Arena*);
template<> ::civ::civloc::TFConfig* Arena::CreateMaybeMessage<::civ::civloc::TFConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace civ {
namespace civloc {

enum PerceptionChanelConfig_Vendor : int {
  PerceptionChanelConfig_Vendor_OTHERS = 0,
  PerceptionChanelConfig_Vendor_SIM = 1,
  PerceptionChanelConfig_Vendor_ZHITO = 2,
  PerceptionChanelConfig_Vendor_MOBILEYE = 3,
  PerceptionChanelConfig_Vendor_MAXIEYE = 4,
  PerceptionChanelConfig_Vendor_SMARTEREYE = 5,
  PerceptionChanelConfig_Vendor_HORIZON = 6
};
bool PerceptionChanelConfig_Vendor_IsValid(int value);
constexpr PerceptionChanelConfig_Vendor PerceptionChanelConfig_Vendor_Vendor_MIN = PerceptionChanelConfig_Vendor_OTHERS;
constexpr PerceptionChanelConfig_Vendor PerceptionChanelConfig_Vendor_Vendor_MAX = PerceptionChanelConfig_Vendor_HORIZON;
constexpr int PerceptionChanelConfig_Vendor_Vendor_ARRAYSIZE = PerceptionChanelConfig_Vendor_Vendor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerceptionChanelConfig_Vendor_descriptor();
template<typename T>
inline const std::string& PerceptionChanelConfig_Vendor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerceptionChanelConfig_Vendor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerceptionChanelConfig_Vendor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerceptionChanelConfig_Vendor_descriptor(), enum_t_value);
}
inline bool PerceptionChanelConfig_Vendor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerceptionChanelConfig_Vendor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerceptionChanelConfig_Vendor>(
    PerceptionChanelConfig_Vendor_descriptor(), name, value);
}
enum CivLocConfig_WorkMode : int {
  CivLocConfig_WorkMode_Forward = 0,
  CivLocConfig_WorkMode_Fuse = 1
};
bool CivLocConfig_WorkMode_IsValid(int value);
constexpr CivLocConfig_WorkMode CivLocConfig_WorkMode_WorkMode_MIN = CivLocConfig_WorkMode_Forward;
constexpr CivLocConfig_WorkMode CivLocConfig_WorkMode_WorkMode_MAX = CivLocConfig_WorkMode_Fuse;
constexpr int CivLocConfig_WorkMode_WorkMode_ARRAYSIZE = CivLocConfig_WorkMode_WorkMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CivLocConfig_WorkMode_descriptor();
template<typename T>
inline const std::string& CivLocConfig_WorkMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CivLocConfig_WorkMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CivLocConfig_WorkMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CivLocConfig_WorkMode_descriptor(), enum_t_value);
}
inline bool CivLocConfig_WorkMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CivLocConfig_WorkMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CivLocConfig_WorkMode>(
    CivLocConfig_WorkMode_descriptor(), name, value);
}
// ===================================================================

class PerceptionChanelConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.PerceptionChanelConfig) */ {
 public:
  inline PerceptionChanelConfig() : PerceptionChanelConfig(nullptr) {}
  virtual ~PerceptionChanelConfig();

  PerceptionChanelConfig(const PerceptionChanelConfig& from);
  PerceptionChanelConfig(PerceptionChanelConfig&& from) noexcept
    : PerceptionChanelConfig() {
    *this = ::std::move(from);
  }

  inline PerceptionChanelConfig& operator=(const PerceptionChanelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerceptionChanelConfig& operator=(PerceptionChanelConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PerceptionChanelConfig& default_instance();

  static inline const PerceptionChanelConfig* internal_default_instance() {
    return reinterpret_cast<const PerceptionChanelConfig*>(
               &_PerceptionChanelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PerceptionChanelConfig& a, PerceptionChanelConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PerceptionChanelConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerceptionChanelConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PerceptionChanelConfig* New() const final {
    return CreateMaybeMessage<PerceptionChanelConfig>(nullptr);
  }

  PerceptionChanelConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PerceptionChanelConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PerceptionChanelConfig& from);
  void MergeFrom(const PerceptionChanelConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerceptionChanelConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.PerceptionChanelConfig";
  }
  protected:
  explicit PerceptionChanelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fcivloc_2eproto);
    return ::descriptor_table_civloc_2fproto_2fcivloc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PerceptionChanelConfig_Vendor Vendor;
  static constexpr Vendor OTHERS =
    PerceptionChanelConfig_Vendor_OTHERS;
  static constexpr Vendor SIM =
    PerceptionChanelConfig_Vendor_SIM;
  static constexpr Vendor ZHITO =
    PerceptionChanelConfig_Vendor_ZHITO;
  static constexpr Vendor MOBILEYE =
    PerceptionChanelConfig_Vendor_MOBILEYE;
  static constexpr Vendor MAXIEYE =
    PerceptionChanelConfig_Vendor_MAXIEYE;
  static constexpr Vendor SMARTEREYE =
    PerceptionChanelConfig_Vendor_SMARTEREYE;
  static constexpr Vendor HORIZON =
    PerceptionChanelConfig_Vendor_HORIZON;
  static inline bool Vendor_IsValid(int value) {
    return PerceptionChanelConfig_Vendor_IsValid(value);
  }
  static constexpr Vendor Vendor_MIN =
    PerceptionChanelConfig_Vendor_Vendor_MIN;
  static constexpr Vendor Vendor_MAX =
    PerceptionChanelConfig_Vendor_Vendor_MAX;
  static constexpr int Vendor_ARRAYSIZE =
    PerceptionChanelConfig_Vendor_Vendor_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Vendor_descriptor() {
    return PerceptionChanelConfig_Vendor_descriptor();
  }
  template<typename T>
  static inline const std::string& Vendor_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Vendor>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Vendor_Name.");
    return PerceptionChanelConfig_Vendor_Name(enum_t_value);
  }
  static inline bool Vendor_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Vendor* value) {
    return PerceptionChanelConfig_Vendor_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVendorFieldNumber = 2,
    kRateHzFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .civ.civloc.PerceptionChanelConfig.Vendor vendor = 2 [default = SIM];
  bool has_vendor() const;
  private:
  bool _internal_has_vendor() const;
  public:
  void clear_vendor();
  ::civ::civloc::PerceptionChanelConfig_Vendor vendor() const;
  void set_vendor(::civ::civloc::PerceptionChanelConfig_Vendor value);
  private:
  ::civ::civloc::PerceptionChanelConfig_Vendor _internal_vendor() const;
  void _internal_set_vendor(::civ::civloc::PerceptionChanelConfig_Vendor value);
  public:

  // optional uint32 rate_hz = 3 [default = 10];
  bool has_rate_hz() const;
  private:
  bool _internal_has_rate_hz() const;
  public:
  void clear_rate_hz();
  ::PROTOBUF_NAMESPACE_ID::uint32 rate_hz() const;
  void set_rate_hz(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_rate_hz() const;
  void _internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.PerceptionChanelConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int vendor_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rate_hz_;
  friend struct ::TableStruct_civloc_2fproto_2fcivloc_2eproto;
};
// -------------------------------------------------------------------

class TFConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.TFConfig) */ {
 public:
  inline TFConfig() : TFConfig(nullptr) {}
  virtual ~TFConfig();

  TFConfig(const TFConfig& from);
  TFConfig(TFConfig&& from) noexcept
    : TFConfig() {
    *this = ::std::move(from);
  }

  inline TFConfig& operator=(const TFConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TFConfig& operator=(TFConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TFConfig& default_instance();

  static inline const TFConfig* internal_default_instance() {
    return reinterpret_cast<const TFConfig*>(
               &_TFConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TFConfig& a, TFConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TFConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TFConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TFConfig* New() const final {
    return CreateMaybeMessage<TFConfig>(nullptr);
  }

  TFConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TFConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TFConfig& from);
  void MergeFrom(const TFConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TFConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.TFConfig";
  }
  protected:
  explicit TFConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fcivloc_2eproto);
    return ::descriptor_table_civloc_2fproto_2fcivloc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastTfFrameIdFieldNumber = 9,
    kBroadcastTfChildFrameIdFieldNumber = 10,
  };
  // optional string broadcast_tf_frame_id = 9;
  bool has_broadcast_tf_frame_id() const;
  private:
  bool _internal_has_broadcast_tf_frame_id() const;
  public:
  void clear_broadcast_tf_frame_id();
  const std::string& broadcast_tf_frame_id() const;
  void set_broadcast_tf_frame_id(const std::string& value);
  void set_broadcast_tf_frame_id(std::string&& value);
  void set_broadcast_tf_frame_id(const char* value);
  void set_broadcast_tf_frame_id(const char* value, size_t size);
  std::string* mutable_broadcast_tf_frame_id();
  std::string* release_broadcast_tf_frame_id();
  void set_allocated_broadcast_tf_frame_id(std::string* broadcast_tf_frame_id);
  private:
  const std::string& _internal_broadcast_tf_frame_id() const;
  void _internal_set_broadcast_tf_frame_id(const std::string& value);
  std::string* _internal_mutable_broadcast_tf_frame_id();
  public:

  // optional string broadcast_tf_child_frame_id = 10;
  bool has_broadcast_tf_child_frame_id() const;
  private:
  bool _internal_has_broadcast_tf_child_frame_id() const;
  public:
  void clear_broadcast_tf_child_frame_id();
  const std::string& broadcast_tf_child_frame_id() const;
  void set_broadcast_tf_child_frame_id(const std::string& value);
  void set_broadcast_tf_child_frame_id(std::string&& value);
  void set_broadcast_tf_child_frame_id(const char* value);
  void set_broadcast_tf_child_frame_id(const char* value, size_t size);
  std::string* mutable_broadcast_tf_child_frame_id();
  std::string* release_broadcast_tf_child_frame_id();
  void set_allocated_broadcast_tf_child_frame_id(std::string* broadcast_tf_child_frame_id);
  private:
  const std::string& _internal_broadcast_tf_child_frame_id() const;
  void _internal_set_broadcast_tf_child_frame_id(const std::string& value);
  std::string* _internal_mutable_broadcast_tf_child_frame_id();
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.TFConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr broadcast_tf_frame_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr broadcast_tf_child_frame_id_;
  friend struct ::TableStruct_civloc_2fproto_2fcivloc_2eproto;
};
// -------------------------------------------------------------------

class ChanelConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.ChanelConfig) */ {
 public:
  inline ChanelConfig() : ChanelConfig(nullptr) {}
  virtual ~ChanelConfig();

  ChanelConfig(const ChanelConfig& from);
  ChanelConfig(ChanelConfig&& from) noexcept
    : ChanelConfig() {
    *this = ::std::move(from);
  }

  inline ChanelConfig& operator=(const ChanelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChanelConfig& operator=(ChanelConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChanelConfig& default_instance();

  static inline const ChanelConfig* internal_default_instance() {
    return reinterpret_cast<const ChanelConfig*>(
               &_ChanelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChanelConfig& a, ChanelConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ChanelConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChanelConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChanelConfig* New() const final {
    return CreateMaybeMessage<ChanelConfig>(nullptr);
  }

  ChanelConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChanelConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChanelConfig& from);
  void MergeFrom(const ChanelConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChanelConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.ChanelConfig";
  }
  protected:
  explicit ChanelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fcivloc_2eproto);
    return ::descriptor_table_civloc_2fproto_2fcivloc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRateHzFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 rate_hz = 2;
  bool has_rate_hz() const;
  private:
  bool _internal_has_rate_hz() const;
  public:
  void clear_rate_hz();
  ::PROTOBUF_NAMESPACE_ID::uint32 rate_hz() const;
  void set_rate_hz(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_rate_hz() const;
  void _internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.ChanelConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rate_hz_;
  friend struct ::TableStruct_civloc_2fproto_2fcivloc_2eproto;
};
// -------------------------------------------------------------------

class CivLocConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.CivLocConfig) */ {
 public:
  inline CivLocConfig() : CivLocConfig(nullptr) {}
  virtual ~CivLocConfig();

  CivLocConfig(const CivLocConfig& from);
  CivLocConfig(CivLocConfig&& from) noexcept
    : CivLocConfig() {
    *this = ::std::move(from);
  }

  inline CivLocConfig& operator=(const CivLocConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CivLocConfig& operator=(CivLocConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CivLocConfig& default_instance();

  static inline const CivLocConfig* internal_default_instance() {
    return reinterpret_cast<const CivLocConfig*>(
               &_CivLocConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CivLocConfig& a, CivLocConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CivLocConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CivLocConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CivLocConfig* New() const final {
    return CreateMaybeMessage<CivLocConfig>(nullptr);
  }

  CivLocConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CivLocConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CivLocConfig& from);
  void MergeFrom(const CivLocConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CivLocConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.CivLocConfig";
  }
  protected:
  explicit CivLocConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fcivloc_2eproto);
    return ::descriptor_table_civloc_2fproto_2fcivloc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CivLocConfig_WorkMode WorkMode;
  static constexpr WorkMode Forward =
    CivLocConfig_WorkMode_Forward;
  static constexpr WorkMode Fuse =
    CivLocConfig_WorkMode_Fuse;
  static inline bool WorkMode_IsValid(int value) {
    return CivLocConfig_WorkMode_IsValid(value);
  }
  static constexpr WorkMode WorkMode_MIN =
    CivLocConfig_WorkMode_WorkMode_MIN;
  static constexpr WorkMode WorkMode_MAX =
    CivLocConfig_WorkMode_WorkMode_MAX;
  static constexpr int WorkMode_ARRAYSIZE =
    CivLocConfig_WorkMode_WorkMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WorkMode_descriptor() {
    return CivLocConfig_WorkMode_descriptor();
  }
  template<typename T>
  static inline const std::string& WorkMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WorkMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WorkMode_Name.");
    return CivLocConfig_WorkMode_Name(enum_t_value);
  }
  static inline bool WorkMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WorkMode* value) {
    return CivLocConfig_WorkMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPerceptionFieldNumber = 17,
    kVersionFieldNumber = 1,
    kChassisFieldNumber = 8,
    kCgi610FieldNumber = 12,
    kRawCgi610BestposFieldNumber = 13,
    kRawCgi610BestvelFieldNumber = 14,
    kRawCgi610Heading2FieldNumber = 15,
    kRawWheeltecImuFieldNumber = 16,
    kPointcloudFieldNumber = 18,
    kPointcloudMapFieldNumber = 19,
    kZlocMapFieldNumber = 20,
    kCpt7FieldNumber = 21,
    kZlocFuseFieldNumber = 22,
    kForwardCfgFieldNumber = 23,
    kModeFieldNumber = 2,
  };
  // repeated .civ.civloc.PerceptionChanelConfig perception = 17;
  int perception_size() const;
  private:
  int _internal_perception_size() const;
  public:
  void clear_perception();
  ::civ::civloc::PerceptionChanelConfig* mutable_perception(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::PerceptionChanelConfig >*
      mutable_perception();
  private:
  const ::civ::civloc::PerceptionChanelConfig& _internal_perception(int index) const;
  ::civ::civloc::PerceptionChanelConfig* _internal_add_perception();
  public:
  const ::civ::civloc::PerceptionChanelConfig& perception(int index) const;
  ::civ::civloc::PerceptionChanelConfig* add_perception();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::PerceptionChanelConfig >&
      perception() const;

  // required string version = 1 [default = "zloc_component config 1.0.0"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // required .civ.civloc.ChanelConfig chassis = 8;
  bool has_chassis() const;
  private:
  bool _internal_has_chassis() const;
  public:
  void clear_chassis();
  const ::civ::civloc::ChanelConfig& chassis() const;
  ::civ::civloc::ChanelConfig* release_chassis();
  ::civ::civloc::ChanelConfig* mutable_chassis();
  void set_allocated_chassis(::civ::civloc::ChanelConfig* chassis);
  private:
  const ::civ::civloc::ChanelConfig& _internal_chassis() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_chassis();
  public:
  void unsafe_arena_set_allocated_chassis(
      ::civ::civloc::ChanelConfig* chassis);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_chassis();

  // required .civ.civloc.ChanelConfig cgi610 = 12;
  bool has_cgi610() const;
  private:
  bool _internal_has_cgi610() const;
  public:
  void clear_cgi610();
  const ::civ::civloc::ChanelConfig& cgi610() const;
  ::civ::civloc::ChanelConfig* release_cgi610();
  ::civ::civloc::ChanelConfig* mutable_cgi610();
  void set_allocated_cgi610(::civ::civloc::ChanelConfig* cgi610);
  private:
  const ::civ::civloc::ChanelConfig& _internal_cgi610() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_cgi610();
  public:
  void unsafe_arena_set_allocated_cgi610(
      ::civ::civloc::ChanelConfig* cgi610);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_cgi610();

  // required .civ.civloc.ChanelConfig raw_cgi610_bestpos = 13;
  bool has_raw_cgi610_bestpos() const;
  private:
  bool _internal_has_raw_cgi610_bestpos() const;
  public:
  void clear_raw_cgi610_bestpos();
  const ::civ::civloc::ChanelConfig& raw_cgi610_bestpos() const;
  ::civ::civloc::ChanelConfig* release_raw_cgi610_bestpos();
  ::civ::civloc::ChanelConfig* mutable_raw_cgi610_bestpos();
  void set_allocated_raw_cgi610_bestpos(::civ::civloc::ChanelConfig* raw_cgi610_bestpos);
  private:
  const ::civ::civloc::ChanelConfig& _internal_raw_cgi610_bestpos() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_raw_cgi610_bestpos();
  public:
  void unsafe_arena_set_allocated_raw_cgi610_bestpos(
      ::civ::civloc::ChanelConfig* raw_cgi610_bestpos);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_raw_cgi610_bestpos();

  // required .civ.civloc.ChanelConfig raw_cgi610_bestvel = 14;
  bool has_raw_cgi610_bestvel() const;
  private:
  bool _internal_has_raw_cgi610_bestvel() const;
  public:
  void clear_raw_cgi610_bestvel();
  const ::civ::civloc::ChanelConfig& raw_cgi610_bestvel() const;
  ::civ::civloc::ChanelConfig* release_raw_cgi610_bestvel();
  ::civ::civloc::ChanelConfig* mutable_raw_cgi610_bestvel();
  void set_allocated_raw_cgi610_bestvel(::civ::civloc::ChanelConfig* raw_cgi610_bestvel);
  private:
  const ::civ::civloc::ChanelConfig& _internal_raw_cgi610_bestvel() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_raw_cgi610_bestvel();
  public:
  void unsafe_arena_set_allocated_raw_cgi610_bestvel(
      ::civ::civloc::ChanelConfig* raw_cgi610_bestvel);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_raw_cgi610_bestvel();

  // required .civ.civloc.ChanelConfig raw_cgi610_heading2 = 15;
  bool has_raw_cgi610_heading2() const;
  private:
  bool _internal_has_raw_cgi610_heading2() const;
  public:
  void clear_raw_cgi610_heading2();
  const ::civ::civloc::ChanelConfig& raw_cgi610_heading2() const;
  ::civ::civloc::ChanelConfig* release_raw_cgi610_heading2();
  ::civ::civloc::ChanelConfig* mutable_raw_cgi610_heading2();
  void set_allocated_raw_cgi610_heading2(::civ::civloc::ChanelConfig* raw_cgi610_heading2);
  private:
  const ::civ::civloc::ChanelConfig& _internal_raw_cgi610_heading2() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_raw_cgi610_heading2();
  public:
  void unsafe_arena_set_allocated_raw_cgi610_heading2(
      ::civ::civloc::ChanelConfig* raw_cgi610_heading2);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_raw_cgi610_heading2();

  // required .civ.civloc.ChanelConfig raw_wheeltec_imu = 16;
  bool has_raw_wheeltec_imu() const;
  private:
  bool _internal_has_raw_wheeltec_imu() const;
  public:
  void clear_raw_wheeltec_imu();
  const ::civ::civloc::ChanelConfig& raw_wheeltec_imu() const;
  ::civ::civloc::ChanelConfig* release_raw_wheeltec_imu();
  ::civ::civloc::ChanelConfig* mutable_raw_wheeltec_imu();
  void set_allocated_raw_wheeltec_imu(::civ::civloc::ChanelConfig* raw_wheeltec_imu);
  private:
  const ::civ::civloc::ChanelConfig& _internal_raw_wheeltec_imu() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_raw_wheeltec_imu();
  public:
  void unsafe_arena_set_allocated_raw_wheeltec_imu(
      ::civ::civloc::ChanelConfig* raw_wheeltec_imu);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_raw_wheeltec_imu();

  // required .civ.civloc.ChanelConfig pointcloud = 18;
  bool has_pointcloud() const;
  private:
  bool _internal_has_pointcloud() const;
  public:
  void clear_pointcloud();
  const ::civ::civloc::ChanelConfig& pointcloud() const;
  ::civ::civloc::ChanelConfig* release_pointcloud();
  ::civ::civloc::ChanelConfig* mutable_pointcloud();
  void set_allocated_pointcloud(::civ::civloc::ChanelConfig* pointcloud);
  private:
  const ::civ::civloc::ChanelConfig& _internal_pointcloud() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_pointcloud();
  public:
  void unsafe_arena_set_allocated_pointcloud(
      ::civ::civloc::ChanelConfig* pointcloud);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_pointcloud();

  // optional .civ.civloc.ChanelConfig pointcloud_map = 19;
  bool has_pointcloud_map() const;
  private:
  bool _internal_has_pointcloud_map() const;
  public:
  void clear_pointcloud_map();
  const ::civ::civloc::ChanelConfig& pointcloud_map() const;
  ::civ::civloc::ChanelConfig* release_pointcloud_map();
  ::civ::civloc::ChanelConfig* mutable_pointcloud_map();
  void set_allocated_pointcloud_map(::civ::civloc::ChanelConfig* pointcloud_map);
  private:
  const ::civ::civloc::ChanelConfig& _internal_pointcloud_map() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_pointcloud_map();
  public:
  void unsafe_arena_set_allocated_pointcloud_map(
      ::civ::civloc::ChanelConfig* pointcloud_map);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_pointcloud_map();

  // optional .civ.civloc.ChanelConfig zloc_map = 20;
  bool has_zloc_map() const;
  private:
  bool _internal_has_zloc_map() const;
  public:
  void clear_zloc_map();
  const ::civ::civloc::ChanelConfig& zloc_map() const;
  ::civ::civloc::ChanelConfig* release_zloc_map();
  ::civ::civloc::ChanelConfig* mutable_zloc_map();
  void set_allocated_zloc_map(::civ::civloc::ChanelConfig* zloc_map);
  private:
  const ::civ::civloc::ChanelConfig& _internal_zloc_map() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_zloc_map();
  public:
  void unsafe_arena_set_allocated_zloc_map(
      ::civ::civloc::ChanelConfig* zloc_map);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_zloc_map();

  // optional .civ.civloc.ChanelConfig cpt7 = 21;
  bool has_cpt7() const;
  private:
  bool _internal_has_cpt7() const;
  public:
  void clear_cpt7();
  const ::civ::civloc::ChanelConfig& cpt7() const;
  ::civ::civloc::ChanelConfig* release_cpt7();
  ::civ::civloc::ChanelConfig* mutable_cpt7();
  void set_allocated_cpt7(::civ::civloc::ChanelConfig* cpt7);
  private:
  const ::civ::civloc::ChanelConfig& _internal_cpt7() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_cpt7();
  public:
  void unsafe_arena_set_allocated_cpt7(
      ::civ::civloc::ChanelConfig* cpt7);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_cpt7();

  // required .civ.civloc.ChanelConfig zloc_fuse = 22;
  bool has_zloc_fuse() const;
  private:
  bool _internal_has_zloc_fuse() const;
  public:
  void clear_zloc_fuse();
  const ::civ::civloc::ChanelConfig& zloc_fuse() const;
  ::civ::civloc::ChanelConfig* release_zloc_fuse();
  ::civ::civloc::ChanelConfig* mutable_zloc_fuse();
  void set_allocated_zloc_fuse(::civ::civloc::ChanelConfig* zloc_fuse);
  private:
  const ::civ::civloc::ChanelConfig& _internal_zloc_fuse() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_zloc_fuse();
  public:
  void unsafe_arena_set_allocated_zloc_fuse(
      ::civ::civloc::ChanelConfig* zloc_fuse);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_zloc_fuse();

  // required .civ.civloc.ChanelConfig forward_cfg = 23;
  bool has_forward_cfg() const;
  private:
  bool _internal_has_forward_cfg() const;
  public:
  void clear_forward_cfg();
  const ::civ::civloc::ChanelConfig& forward_cfg() const;
  ::civ::civloc::ChanelConfig* release_forward_cfg();
  ::civ::civloc::ChanelConfig* mutable_forward_cfg();
  void set_allocated_forward_cfg(::civ::civloc::ChanelConfig* forward_cfg);
  private:
  const ::civ::civloc::ChanelConfig& _internal_forward_cfg() const;
  ::civ::civloc::ChanelConfig* _internal_mutable_forward_cfg();
  public:
  void unsafe_arena_set_allocated_forward_cfg(
      ::civ::civloc::ChanelConfig* forward_cfg);
  ::civ::civloc::ChanelConfig* unsafe_arena_release_forward_cfg();

  // optional .civ.civloc.CivLocConfig.WorkMode mode = 2 [default = Forward];
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::civ::civloc::CivLocConfig_WorkMode mode() const;
  void set_mode(::civ::civloc::CivLocConfig_WorkMode value);
  private:
  ::civ::civloc::CivLocConfig_WorkMode _internal_mode() const;
  void _internal_set_mode(::civ::civloc::CivLocConfig_WorkMode value);
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.CivLocConfig)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::PerceptionChanelConfig > perception_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::civ::civloc::ChanelConfig* chassis_;
  ::civ::civloc::ChanelConfig* cgi610_;
  ::civ::civloc::ChanelConfig* raw_cgi610_bestpos_;
  ::civ::civloc::ChanelConfig* raw_cgi610_bestvel_;
  ::civ::civloc::ChanelConfig* raw_cgi610_heading2_;
  ::civ::civloc::ChanelConfig* raw_wheeltec_imu_;
  ::civ::civloc::ChanelConfig* pointcloud_;
  ::civ::civloc::ChanelConfig* pointcloud_map_;
  ::civ::civloc::ChanelConfig* zloc_map_;
  ::civ::civloc::ChanelConfig* cpt7_;
  ::civ::civloc::ChanelConfig* zloc_fuse_;
  ::civ::civloc::ChanelConfig* forward_cfg_;
  int mode_;
  friend struct ::TableStruct_civloc_2fproto_2fcivloc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PerceptionChanelConfig

// optional string name = 1;
inline bool PerceptionChanelConfig::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PerceptionChanelConfig::has_name() const {
  return _internal_has_name();
}
inline void PerceptionChanelConfig::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PerceptionChanelConfig::name() const {
  // @@protoc_insertion_point(field_get:civ.civloc.PerceptionChanelConfig.name)
  return _internal_name();
}
inline void PerceptionChanelConfig::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:civ.civloc.PerceptionChanelConfig.name)
}
inline std::string* PerceptionChanelConfig::mutable_name() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.PerceptionChanelConfig.name)
  return _internal_mutable_name();
}
inline const std::string& PerceptionChanelConfig::_internal_name() const {
  return name_.Get();
}
inline void PerceptionChanelConfig::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PerceptionChanelConfig::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.PerceptionChanelConfig.name)
}
inline void PerceptionChanelConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.PerceptionChanelConfig.name)
}
inline void PerceptionChanelConfig::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.PerceptionChanelConfig.name)
}
inline std::string* PerceptionChanelConfig::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PerceptionChanelConfig::release_name() {
  // @@protoc_insertion_point(field_release:civ.civloc.PerceptionChanelConfig.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PerceptionChanelConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.PerceptionChanelConfig.name)
}

// optional .civ.civloc.PerceptionChanelConfig.Vendor vendor = 2 [default = SIM];
inline bool PerceptionChanelConfig::_internal_has_vendor() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PerceptionChanelConfig::has_vendor() const {
  return _internal_has_vendor();
}
inline void PerceptionChanelConfig::clear_vendor() {
  vendor_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::civ::civloc::PerceptionChanelConfig_Vendor PerceptionChanelConfig::_internal_vendor() const {
  return static_cast< ::civ::civloc::PerceptionChanelConfig_Vendor >(vendor_);
}
inline ::civ::civloc::PerceptionChanelConfig_Vendor PerceptionChanelConfig::vendor() const {
  // @@protoc_insertion_point(field_get:civ.civloc.PerceptionChanelConfig.vendor)
  return _internal_vendor();
}
inline void PerceptionChanelConfig::_internal_set_vendor(::civ::civloc::PerceptionChanelConfig_Vendor value) {
  assert(::civ::civloc::PerceptionChanelConfig_Vendor_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  vendor_ = value;
}
inline void PerceptionChanelConfig::set_vendor(::civ::civloc::PerceptionChanelConfig_Vendor value) {
  _internal_set_vendor(value);
  // @@protoc_insertion_point(field_set:civ.civloc.PerceptionChanelConfig.vendor)
}

// optional uint32 rate_hz = 3 [default = 10];
inline bool PerceptionChanelConfig::_internal_has_rate_hz() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PerceptionChanelConfig::has_rate_hz() const {
  return _internal_has_rate_hz();
}
inline void PerceptionChanelConfig::clear_rate_hz() {
  rate_hz_ = 10u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PerceptionChanelConfig::_internal_rate_hz() const {
  return rate_hz_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PerceptionChanelConfig::rate_hz() const {
  // @@protoc_insertion_point(field_get:civ.civloc.PerceptionChanelConfig.rate_hz)
  return _internal_rate_hz();
}
inline void PerceptionChanelConfig::_internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  rate_hz_ = value;
}
inline void PerceptionChanelConfig::set_rate_hz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_rate_hz(value);
  // @@protoc_insertion_point(field_set:civ.civloc.PerceptionChanelConfig.rate_hz)
}

// -------------------------------------------------------------------

// TFConfig

// optional string broadcast_tf_frame_id = 9;
inline bool TFConfig::_internal_has_broadcast_tf_frame_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TFConfig::has_broadcast_tf_frame_id() const {
  return _internal_has_broadcast_tf_frame_id();
}
inline void TFConfig::clear_broadcast_tf_frame_id() {
  broadcast_tf_frame_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TFConfig::broadcast_tf_frame_id() const {
  // @@protoc_insertion_point(field_get:civ.civloc.TFConfig.broadcast_tf_frame_id)
  return _internal_broadcast_tf_frame_id();
}
inline void TFConfig::set_broadcast_tf_frame_id(const std::string& value) {
  _internal_set_broadcast_tf_frame_id(value);
  // @@protoc_insertion_point(field_set:civ.civloc.TFConfig.broadcast_tf_frame_id)
}
inline std::string* TFConfig::mutable_broadcast_tf_frame_id() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.TFConfig.broadcast_tf_frame_id)
  return _internal_mutable_broadcast_tf_frame_id();
}
inline const std::string& TFConfig::_internal_broadcast_tf_frame_id() const {
  return broadcast_tf_frame_id_.Get();
}
inline void TFConfig::_internal_set_broadcast_tf_frame_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_tf_frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TFConfig::set_broadcast_tf_frame_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_tf_frame_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.TFConfig.broadcast_tf_frame_id)
}
inline void TFConfig::set_broadcast_tf_frame_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  broadcast_tf_frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.TFConfig.broadcast_tf_frame_id)
}
inline void TFConfig::set_broadcast_tf_frame_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_tf_frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.TFConfig.broadcast_tf_frame_id)
}
inline std::string* TFConfig::_internal_mutable_broadcast_tf_frame_id() {
  _has_bits_[0] |= 0x00000001u;
  return broadcast_tf_frame_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TFConfig::release_broadcast_tf_frame_id() {
  // @@protoc_insertion_point(field_release:civ.civloc.TFConfig.broadcast_tf_frame_id)
  if (!_internal_has_broadcast_tf_frame_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return broadcast_tf_frame_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TFConfig::set_allocated_broadcast_tf_frame_id(std::string* broadcast_tf_frame_id) {
  if (broadcast_tf_frame_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  broadcast_tf_frame_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), broadcast_tf_frame_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.TFConfig.broadcast_tf_frame_id)
}

// optional string broadcast_tf_child_frame_id = 10;
inline bool TFConfig::_internal_has_broadcast_tf_child_frame_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TFConfig::has_broadcast_tf_child_frame_id() const {
  return _internal_has_broadcast_tf_child_frame_id();
}
inline void TFConfig::clear_broadcast_tf_child_frame_id() {
  broadcast_tf_child_frame_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TFConfig::broadcast_tf_child_frame_id() const {
  // @@protoc_insertion_point(field_get:civ.civloc.TFConfig.broadcast_tf_child_frame_id)
  return _internal_broadcast_tf_child_frame_id();
}
inline void TFConfig::set_broadcast_tf_child_frame_id(const std::string& value) {
  _internal_set_broadcast_tf_child_frame_id(value);
  // @@protoc_insertion_point(field_set:civ.civloc.TFConfig.broadcast_tf_child_frame_id)
}
inline std::string* TFConfig::mutable_broadcast_tf_child_frame_id() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.TFConfig.broadcast_tf_child_frame_id)
  return _internal_mutable_broadcast_tf_child_frame_id();
}
inline const std::string& TFConfig::_internal_broadcast_tf_child_frame_id() const {
  return broadcast_tf_child_frame_id_.Get();
}
inline void TFConfig::_internal_set_broadcast_tf_child_frame_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  broadcast_tf_child_frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TFConfig::set_broadcast_tf_child_frame_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  broadcast_tf_child_frame_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.TFConfig.broadcast_tf_child_frame_id)
}
inline void TFConfig::set_broadcast_tf_child_frame_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  broadcast_tf_child_frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.TFConfig.broadcast_tf_child_frame_id)
}
inline void TFConfig::set_broadcast_tf_child_frame_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  broadcast_tf_child_frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.TFConfig.broadcast_tf_child_frame_id)
}
inline std::string* TFConfig::_internal_mutable_broadcast_tf_child_frame_id() {
  _has_bits_[0] |= 0x00000002u;
  return broadcast_tf_child_frame_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TFConfig::release_broadcast_tf_child_frame_id() {
  // @@protoc_insertion_point(field_release:civ.civloc.TFConfig.broadcast_tf_child_frame_id)
  if (!_internal_has_broadcast_tf_child_frame_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return broadcast_tf_child_frame_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TFConfig::set_allocated_broadcast_tf_child_frame_id(std::string* broadcast_tf_child_frame_id) {
  if (broadcast_tf_child_frame_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  broadcast_tf_child_frame_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), broadcast_tf_child_frame_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.TFConfig.broadcast_tf_child_frame_id)
}

// -------------------------------------------------------------------

// ChanelConfig

// optional string name = 1;
inline bool ChanelConfig::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChanelConfig::has_name() const {
  return _internal_has_name();
}
inline void ChanelConfig::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChanelConfig::name() const {
  // @@protoc_insertion_point(field_get:civ.civloc.ChanelConfig.name)
  return _internal_name();
}
inline void ChanelConfig::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:civ.civloc.ChanelConfig.name)
}
inline std::string* ChanelConfig::mutable_name() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.ChanelConfig.name)
  return _internal_mutable_name();
}
inline const std::string& ChanelConfig::_internal_name() const {
  return name_.Get();
}
inline void ChanelConfig::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChanelConfig::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.ChanelConfig.name)
}
inline void ChanelConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.ChanelConfig.name)
}
inline void ChanelConfig::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.ChanelConfig.name)
}
inline std::string* ChanelConfig::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChanelConfig::release_name() {
  // @@protoc_insertion_point(field_release:civ.civloc.ChanelConfig.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChanelConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.ChanelConfig.name)
}

// optional uint32 rate_hz = 2;
inline bool ChanelConfig::_internal_has_rate_hz() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChanelConfig::has_rate_hz() const {
  return _internal_has_rate_hz();
}
inline void ChanelConfig::clear_rate_hz() {
  rate_hz_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChanelConfig::_internal_rate_hz() const {
  return rate_hz_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChanelConfig::rate_hz() const {
  // @@protoc_insertion_point(field_get:civ.civloc.ChanelConfig.rate_hz)
  return _internal_rate_hz();
}
inline void ChanelConfig::_internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  rate_hz_ = value;
}
inline void ChanelConfig::set_rate_hz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_rate_hz(value);
  // @@protoc_insertion_point(field_set:civ.civloc.ChanelConfig.rate_hz)
}

// -------------------------------------------------------------------

// CivLocConfig

// required string version = 1 [default = "zloc_component config 1.0.0"];
inline bool CivLocConfig::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CivLocConfig::has_version() const {
  return _internal_has_version();
}
inline void CivLocConfig::clear_version() {
  version_.ClearToDefault(::civ::civloc::CivLocConfig::_i_give_permission_to_break_this_code_default_version_, GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CivLocConfig::version() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.version)
  if (version_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_version_.get();
  return _internal_version();
}
inline void CivLocConfig::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:civ.civloc.CivLocConfig.version)
}
inline std::string* CivLocConfig::mutable_version() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.version)
  return _internal_mutable_version();
}
inline const std::string& CivLocConfig::_internal_version() const {
  return version_.Get();
}
inline void CivLocConfig::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void CivLocConfig::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.CivLocConfig.version)
}
inline void CivLocConfig::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.CivLocConfig.version)
}
inline void CivLocConfig::set_version(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.CivLocConfig.version)
}
inline std::string* CivLocConfig::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  return version_.Mutable(::civ::civloc::CivLocConfig::_i_give_permission_to_break_this_code_default_version_, GetArena());
}
inline std::string* CivLocConfig::release_version() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return version_.ReleaseNonDefault(nullptr, GetArena());
}
inline void CivLocConfig::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.SetAllocated(nullptr, version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.version)
}

// optional .civ.civloc.CivLocConfig.WorkMode mode = 2 [default = Forward];
inline bool CivLocConfig::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CivLocConfig::has_mode() const {
  return _internal_has_mode();
}
inline void CivLocConfig::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::civ::civloc::CivLocConfig_WorkMode CivLocConfig::_internal_mode() const {
  return static_cast< ::civ::civloc::CivLocConfig_WorkMode >(mode_);
}
inline ::civ::civloc::CivLocConfig_WorkMode CivLocConfig::mode() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.mode)
  return _internal_mode();
}
inline void CivLocConfig::_internal_set_mode(::civ::civloc::CivLocConfig_WorkMode value) {
  assert(::civ::civloc::CivLocConfig_WorkMode_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  mode_ = value;
}
inline void CivLocConfig::set_mode(::civ::civloc::CivLocConfig_WorkMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:civ.civloc.CivLocConfig.mode)
}

// required .civ.civloc.ChanelConfig chassis = 8;
inline bool CivLocConfig::_internal_has_chassis() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || chassis_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_chassis() const {
  return _internal_has_chassis();
}
inline void CivLocConfig::clear_chassis() {
  if (chassis_ != nullptr) chassis_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_chassis() const {
  const ::civ::civloc::ChanelConfig* p = chassis_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::chassis() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.chassis)
  return _internal_chassis();
}
inline void CivLocConfig::unsafe_arena_set_allocated_chassis(
    ::civ::civloc::ChanelConfig* chassis) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chassis_);
  }
  chassis_ = chassis;
  if (chassis) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.chassis)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_chassis() {
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::ChanelConfig* temp = chassis_;
  chassis_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_chassis() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.chassis)
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::ChanelConfig* temp = chassis_;
  chassis_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_chassis() {
  _has_bits_[0] |= 0x00000002u;
  if (chassis_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    chassis_ = p;
  }
  return chassis_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_chassis() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.chassis)
  return _internal_mutable_chassis();
}
inline void CivLocConfig::set_allocated_chassis(::civ::civloc::ChanelConfig* chassis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete chassis_;
  }
  if (chassis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(chassis);
    if (message_arena != submessage_arena) {
      chassis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chassis, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  chassis_ = chassis;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.chassis)
}

// required .civ.civloc.ChanelConfig cgi610 = 12;
inline bool CivLocConfig::_internal_has_cgi610() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || cgi610_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_cgi610() const {
  return _internal_has_cgi610();
}
inline void CivLocConfig::clear_cgi610() {
  if (cgi610_ != nullptr) cgi610_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_cgi610() const {
  const ::civ::civloc::ChanelConfig* p = cgi610_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::cgi610() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.cgi610)
  return _internal_cgi610();
}
inline void CivLocConfig::unsafe_arena_set_allocated_cgi610(
    ::civ::civloc::ChanelConfig* cgi610) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cgi610_);
  }
  cgi610_ = cgi610;
  if (cgi610) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.cgi610)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_cgi610() {
  _has_bits_[0] &= ~0x00000004u;
  ::civ::civloc::ChanelConfig* temp = cgi610_;
  cgi610_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_cgi610() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.cgi610)
  _has_bits_[0] &= ~0x00000004u;
  ::civ::civloc::ChanelConfig* temp = cgi610_;
  cgi610_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_cgi610() {
  _has_bits_[0] |= 0x00000004u;
  if (cgi610_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    cgi610_ = p;
  }
  return cgi610_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_cgi610() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.cgi610)
  return _internal_mutable_cgi610();
}
inline void CivLocConfig::set_allocated_cgi610(::civ::civloc::ChanelConfig* cgi610) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cgi610_;
  }
  if (cgi610) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cgi610);
    if (message_arena != submessage_arena) {
      cgi610 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cgi610, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cgi610_ = cgi610;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.cgi610)
}

// required .civ.civloc.ChanelConfig raw_cgi610_bestpos = 13;
inline bool CivLocConfig::_internal_has_raw_cgi610_bestpos() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || raw_cgi610_bestpos_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_raw_cgi610_bestpos() const {
  return _internal_has_raw_cgi610_bestpos();
}
inline void CivLocConfig::clear_raw_cgi610_bestpos() {
  if (raw_cgi610_bestpos_ != nullptr) raw_cgi610_bestpos_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_raw_cgi610_bestpos() const {
  const ::civ::civloc::ChanelConfig* p = raw_cgi610_bestpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::raw_cgi610_bestpos() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.raw_cgi610_bestpos)
  return _internal_raw_cgi610_bestpos();
}
inline void CivLocConfig::unsafe_arena_set_allocated_raw_cgi610_bestpos(
    ::civ::civloc::ChanelConfig* raw_cgi610_bestpos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_cgi610_bestpos_);
  }
  raw_cgi610_bestpos_ = raw_cgi610_bestpos;
  if (raw_cgi610_bestpos) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.raw_cgi610_bestpos)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_raw_cgi610_bestpos() {
  _has_bits_[0] &= ~0x00000008u;
  ::civ::civloc::ChanelConfig* temp = raw_cgi610_bestpos_;
  raw_cgi610_bestpos_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_raw_cgi610_bestpos() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.raw_cgi610_bestpos)
  _has_bits_[0] &= ~0x00000008u;
  ::civ::civloc::ChanelConfig* temp = raw_cgi610_bestpos_;
  raw_cgi610_bestpos_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_raw_cgi610_bestpos() {
  _has_bits_[0] |= 0x00000008u;
  if (raw_cgi610_bestpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    raw_cgi610_bestpos_ = p;
  }
  return raw_cgi610_bestpos_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_raw_cgi610_bestpos() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.raw_cgi610_bestpos)
  return _internal_mutable_raw_cgi610_bestpos();
}
inline void CivLocConfig::set_allocated_raw_cgi610_bestpos(::civ::civloc::ChanelConfig* raw_cgi610_bestpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete raw_cgi610_bestpos_;
  }
  if (raw_cgi610_bestpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(raw_cgi610_bestpos);
    if (message_arena != submessage_arena) {
      raw_cgi610_bestpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_cgi610_bestpos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  raw_cgi610_bestpos_ = raw_cgi610_bestpos;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.raw_cgi610_bestpos)
}

// required .civ.civloc.ChanelConfig raw_cgi610_bestvel = 14;
inline bool CivLocConfig::_internal_has_raw_cgi610_bestvel() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || raw_cgi610_bestvel_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_raw_cgi610_bestvel() const {
  return _internal_has_raw_cgi610_bestvel();
}
inline void CivLocConfig::clear_raw_cgi610_bestvel() {
  if (raw_cgi610_bestvel_ != nullptr) raw_cgi610_bestvel_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_raw_cgi610_bestvel() const {
  const ::civ::civloc::ChanelConfig* p = raw_cgi610_bestvel_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::raw_cgi610_bestvel() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.raw_cgi610_bestvel)
  return _internal_raw_cgi610_bestvel();
}
inline void CivLocConfig::unsafe_arena_set_allocated_raw_cgi610_bestvel(
    ::civ::civloc::ChanelConfig* raw_cgi610_bestvel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_cgi610_bestvel_);
  }
  raw_cgi610_bestvel_ = raw_cgi610_bestvel;
  if (raw_cgi610_bestvel) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.raw_cgi610_bestvel)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_raw_cgi610_bestvel() {
  _has_bits_[0] &= ~0x00000010u;
  ::civ::civloc::ChanelConfig* temp = raw_cgi610_bestvel_;
  raw_cgi610_bestvel_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_raw_cgi610_bestvel() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.raw_cgi610_bestvel)
  _has_bits_[0] &= ~0x00000010u;
  ::civ::civloc::ChanelConfig* temp = raw_cgi610_bestvel_;
  raw_cgi610_bestvel_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_raw_cgi610_bestvel() {
  _has_bits_[0] |= 0x00000010u;
  if (raw_cgi610_bestvel_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    raw_cgi610_bestvel_ = p;
  }
  return raw_cgi610_bestvel_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_raw_cgi610_bestvel() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.raw_cgi610_bestvel)
  return _internal_mutable_raw_cgi610_bestvel();
}
inline void CivLocConfig::set_allocated_raw_cgi610_bestvel(::civ::civloc::ChanelConfig* raw_cgi610_bestvel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete raw_cgi610_bestvel_;
  }
  if (raw_cgi610_bestvel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(raw_cgi610_bestvel);
    if (message_arena != submessage_arena) {
      raw_cgi610_bestvel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_cgi610_bestvel, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  raw_cgi610_bestvel_ = raw_cgi610_bestvel;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.raw_cgi610_bestvel)
}

// required .civ.civloc.ChanelConfig raw_cgi610_heading2 = 15;
inline bool CivLocConfig::_internal_has_raw_cgi610_heading2() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || raw_cgi610_heading2_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_raw_cgi610_heading2() const {
  return _internal_has_raw_cgi610_heading2();
}
inline void CivLocConfig::clear_raw_cgi610_heading2() {
  if (raw_cgi610_heading2_ != nullptr) raw_cgi610_heading2_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_raw_cgi610_heading2() const {
  const ::civ::civloc::ChanelConfig* p = raw_cgi610_heading2_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::raw_cgi610_heading2() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.raw_cgi610_heading2)
  return _internal_raw_cgi610_heading2();
}
inline void CivLocConfig::unsafe_arena_set_allocated_raw_cgi610_heading2(
    ::civ::civloc::ChanelConfig* raw_cgi610_heading2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_cgi610_heading2_);
  }
  raw_cgi610_heading2_ = raw_cgi610_heading2;
  if (raw_cgi610_heading2) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.raw_cgi610_heading2)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_raw_cgi610_heading2() {
  _has_bits_[0] &= ~0x00000020u;
  ::civ::civloc::ChanelConfig* temp = raw_cgi610_heading2_;
  raw_cgi610_heading2_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_raw_cgi610_heading2() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.raw_cgi610_heading2)
  _has_bits_[0] &= ~0x00000020u;
  ::civ::civloc::ChanelConfig* temp = raw_cgi610_heading2_;
  raw_cgi610_heading2_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_raw_cgi610_heading2() {
  _has_bits_[0] |= 0x00000020u;
  if (raw_cgi610_heading2_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    raw_cgi610_heading2_ = p;
  }
  return raw_cgi610_heading2_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_raw_cgi610_heading2() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.raw_cgi610_heading2)
  return _internal_mutable_raw_cgi610_heading2();
}
inline void CivLocConfig::set_allocated_raw_cgi610_heading2(::civ::civloc::ChanelConfig* raw_cgi610_heading2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete raw_cgi610_heading2_;
  }
  if (raw_cgi610_heading2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(raw_cgi610_heading2);
    if (message_arena != submessage_arena) {
      raw_cgi610_heading2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_cgi610_heading2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  raw_cgi610_heading2_ = raw_cgi610_heading2;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.raw_cgi610_heading2)
}

// required .civ.civloc.ChanelConfig raw_wheeltec_imu = 16;
inline bool CivLocConfig::_internal_has_raw_wheeltec_imu() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || raw_wheeltec_imu_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_raw_wheeltec_imu() const {
  return _internal_has_raw_wheeltec_imu();
}
inline void CivLocConfig::clear_raw_wheeltec_imu() {
  if (raw_wheeltec_imu_ != nullptr) raw_wheeltec_imu_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_raw_wheeltec_imu() const {
  const ::civ::civloc::ChanelConfig* p = raw_wheeltec_imu_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::raw_wheeltec_imu() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.raw_wheeltec_imu)
  return _internal_raw_wheeltec_imu();
}
inline void CivLocConfig::unsafe_arena_set_allocated_raw_wheeltec_imu(
    ::civ::civloc::ChanelConfig* raw_wheeltec_imu) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_wheeltec_imu_);
  }
  raw_wheeltec_imu_ = raw_wheeltec_imu;
  if (raw_wheeltec_imu) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.raw_wheeltec_imu)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_raw_wheeltec_imu() {
  _has_bits_[0] &= ~0x00000040u;
  ::civ::civloc::ChanelConfig* temp = raw_wheeltec_imu_;
  raw_wheeltec_imu_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_raw_wheeltec_imu() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.raw_wheeltec_imu)
  _has_bits_[0] &= ~0x00000040u;
  ::civ::civloc::ChanelConfig* temp = raw_wheeltec_imu_;
  raw_wheeltec_imu_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_raw_wheeltec_imu() {
  _has_bits_[0] |= 0x00000040u;
  if (raw_wheeltec_imu_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    raw_wheeltec_imu_ = p;
  }
  return raw_wheeltec_imu_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_raw_wheeltec_imu() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.raw_wheeltec_imu)
  return _internal_mutable_raw_wheeltec_imu();
}
inline void CivLocConfig::set_allocated_raw_wheeltec_imu(::civ::civloc::ChanelConfig* raw_wheeltec_imu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete raw_wheeltec_imu_;
  }
  if (raw_wheeltec_imu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(raw_wheeltec_imu);
    if (message_arena != submessage_arena) {
      raw_wheeltec_imu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_wheeltec_imu, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  raw_wheeltec_imu_ = raw_wheeltec_imu;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.raw_wheeltec_imu)
}

// repeated .civ.civloc.PerceptionChanelConfig perception = 17;
inline int CivLocConfig::_internal_perception_size() const {
  return perception_.size();
}
inline int CivLocConfig::perception_size() const {
  return _internal_perception_size();
}
inline void CivLocConfig::clear_perception() {
  perception_.Clear();
}
inline ::civ::civloc::PerceptionChanelConfig* CivLocConfig::mutable_perception(int index) {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.perception)
  return perception_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::PerceptionChanelConfig >*
CivLocConfig::mutable_perception() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.CivLocConfig.perception)
  return &perception_;
}
inline const ::civ::civloc::PerceptionChanelConfig& CivLocConfig::_internal_perception(int index) const {
  return perception_.Get(index);
}
inline const ::civ::civloc::PerceptionChanelConfig& CivLocConfig::perception(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.perception)
  return _internal_perception(index);
}
inline ::civ::civloc::PerceptionChanelConfig* CivLocConfig::_internal_add_perception() {
  return perception_.Add();
}
inline ::civ::civloc::PerceptionChanelConfig* CivLocConfig::add_perception() {
  // @@protoc_insertion_point(field_add:civ.civloc.CivLocConfig.perception)
  return _internal_add_perception();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::PerceptionChanelConfig >&
CivLocConfig::perception() const {
  // @@protoc_insertion_point(field_list:civ.civloc.CivLocConfig.perception)
  return perception_;
}

// required .civ.civloc.ChanelConfig pointcloud = 18;
inline bool CivLocConfig::_internal_has_pointcloud() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || pointcloud_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_pointcloud() const {
  return _internal_has_pointcloud();
}
inline void CivLocConfig::clear_pointcloud() {
  if (pointcloud_ != nullptr) pointcloud_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_pointcloud() const {
  const ::civ::civloc::ChanelConfig* p = pointcloud_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::pointcloud() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.pointcloud)
  return _internal_pointcloud();
}
inline void CivLocConfig::unsafe_arena_set_allocated_pointcloud(
    ::civ::civloc::ChanelConfig* pointcloud) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pointcloud_);
  }
  pointcloud_ = pointcloud;
  if (pointcloud) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.pointcloud)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_pointcloud() {
  _has_bits_[0] &= ~0x00000080u;
  ::civ::civloc::ChanelConfig* temp = pointcloud_;
  pointcloud_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_pointcloud() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.pointcloud)
  _has_bits_[0] &= ~0x00000080u;
  ::civ::civloc::ChanelConfig* temp = pointcloud_;
  pointcloud_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_pointcloud() {
  _has_bits_[0] |= 0x00000080u;
  if (pointcloud_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    pointcloud_ = p;
  }
  return pointcloud_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_pointcloud() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.pointcloud)
  return _internal_mutable_pointcloud();
}
inline void CivLocConfig::set_allocated_pointcloud(::civ::civloc::ChanelConfig* pointcloud) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pointcloud_;
  }
  if (pointcloud) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pointcloud);
    if (message_arena != submessage_arena) {
      pointcloud = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pointcloud, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  pointcloud_ = pointcloud;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.pointcloud)
}

// optional .civ.civloc.ChanelConfig pointcloud_map = 19;
inline bool CivLocConfig::_internal_has_pointcloud_map() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || pointcloud_map_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_pointcloud_map() const {
  return _internal_has_pointcloud_map();
}
inline void CivLocConfig::clear_pointcloud_map() {
  if (pointcloud_map_ != nullptr) pointcloud_map_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_pointcloud_map() const {
  const ::civ::civloc::ChanelConfig* p = pointcloud_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::pointcloud_map() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.pointcloud_map)
  return _internal_pointcloud_map();
}
inline void CivLocConfig::unsafe_arena_set_allocated_pointcloud_map(
    ::civ::civloc::ChanelConfig* pointcloud_map) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pointcloud_map_);
  }
  pointcloud_map_ = pointcloud_map;
  if (pointcloud_map) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.pointcloud_map)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_pointcloud_map() {
  _has_bits_[0] &= ~0x00000100u;
  ::civ::civloc::ChanelConfig* temp = pointcloud_map_;
  pointcloud_map_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_pointcloud_map() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.pointcloud_map)
  _has_bits_[0] &= ~0x00000100u;
  ::civ::civloc::ChanelConfig* temp = pointcloud_map_;
  pointcloud_map_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_pointcloud_map() {
  _has_bits_[0] |= 0x00000100u;
  if (pointcloud_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    pointcloud_map_ = p;
  }
  return pointcloud_map_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_pointcloud_map() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.pointcloud_map)
  return _internal_mutable_pointcloud_map();
}
inline void CivLocConfig::set_allocated_pointcloud_map(::civ::civloc::ChanelConfig* pointcloud_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pointcloud_map_;
  }
  if (pointcloud_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pointcloud_map);
    if (message_arena != submessage_arena) {
      pointcloud_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pointcloud_map, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  pointcloud_map_ = pointcloud_map;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.pointcloud_map)
}

// optional .civ.civloc.ChanelConfig zloc_map = 20;
inline bool CivLocConfig::_internal_has_zloc_map() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || zloc_map_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_zloc_map() const {
  return _internal_has_zloc_map();
}
inline void CivLocConfig::clear_zloc_map() {
  if (zloc_map_ != nullptr) zloc_map_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_zloc_map() const {
  const ::civ::civloc::ChanelConfig* p = zloc_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::zloc_map() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.zloc_map)
  return _internal_zloc_map();
}
inline void CivLocConfig::unsafe_arena_set_allocated_zloc_map(
    ::civ::civloc::ChanelConfig* zloc_map) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(zloc_map_);
  }
  zloc_map_ = zloc_map;
  if (zloc_map) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.zloc_map)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_zloc_map() {
  _has_bits_[0] &= ~0x00000200u;
  ::civ::civloc::ChanelConfig* temp = zloc_map_;
  zloc_map_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_zloc_map() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.zloc_map)
  _has_bits_[0] &= ~0x00000200u;
  ::civ::civloc::ChanelConfig* temp = zloc_map_;
  zloc_map_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_zloc_map() {
  _has_bits_[0] |= 0x00000200u;
  if (zloc_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    zloc_map_ = p;
  }
  return zloc_map_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_zloc_map() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.zloc_map)
  return _internal_mutable_zloc_map();
}
inline void CivLocConfig::set_allocated_zloc_map(::civ::civloc::ChanelConfig* zloc_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete zloc_map_;
  }
  if (zloc_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(zloc_map);
    if (message_arena != submessage_arena) {
      zloc_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zloc_map, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  zloc_map_ = zloc_map;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.zloc_map)
}

// optional .civ.civloc.ChanelConfig cpt7 = 21;
inline bool CivLocConfig::_internal_has_cpt7() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || cpt7_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_cpt7() const {
  return _internal_has_cpt7();
}
inline void CivLocConfig::clear_cpt7() {
  if (cpt7_ != nullptr) cpt7_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_cpt7() const {
  const ::civ::civloc::ChanelConfig* p = cpt7_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::cpt7() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.cpt7)
  return _internal_cpt7();
}
inline void CivLocConfig::unsafe_arena_set_allocated_cpt7(
    ::civ::civloc::ChanelConfig* cpt7) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cpt7_);
  }
  cpt7_ = cpt7;
  if (cpt7) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.cpt7)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_cpt7() {
  _has_bits_[0] &= ~0x00000400u;
  ::civ::civloc::ChanelConfig* temp = cpt7_;
  cpt7_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_cpt7() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.cpt7)
  _has_bits_[0] &= ~0x00000400u;
  ::civ::civloc::ChanelConfig* temp = cpt7_;
  cpt7_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_cpt7() {
  _has_bits_[0] |= 0x00000400u;
  if (cpt7_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    cpt7_ = p;
  }
  return cpt7_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_cpt7() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.cpt7)
  return _internal_mutable_cpt7();
}
inline void CivLocConfig::set_allocated_cpt7(::civ::civloc::ChanelConfig* cpt7) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cpt7_;
  }
  if (cpt7) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cpt7);
    if (message_arena != submessage_arena) {
      cpt7 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cpt7, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  cpt7_ = cpt7;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.cpt7)
}

// required .civ.civloc.ChanelConfig zloc_fuse = 22;
inline bool CivLocConfig::_internal_has_zloc_fuse() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || zloc_fuse_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_zloc_fuse() const {
  return _internal_has_zloc_fuse();
}
inline void CivLocConfig::clear_zloc_fuse() {
  if (zloc_fuse_ != nullptr) zloc_fuse_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_zloc_fuse() const {
  const ::civ::civloc::ChanelConfig* p = zloc_fuse_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::zloc_fuse() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.zloc_fuse)
  return _internal_zloc_fuse();
}
inline void CivLocConfig::unsafe_arena_set_allocated_zloc_fuse(
    ::civ::civloc::ChanelConfig* zloc_fuse) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(zloc_fuse_);
  }
  zloc_fuse_ = zloc_fuse;
  if (zloc_fuse) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.zloc_fuse)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_zloc_fuse() {
  _has_bits_[0] &= ~0x00000800u;
  ::civ::civloc::ChanelConfig* temp = zloc_fuse_;
  zloc_fuse_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_zloc_fuse() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.zloc_fuse)
  _has_bits_[0] &= ~0x00000800u;
  ::civ::civloc::ChanelConfig* temp = zloc_fuse_;
  zloc_fuse_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_zloc_fuse() {
  _has_bits_[0] |= 0x00000800u;
  if (zloc_fuse_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    zloc_fuse_ = p;
  }
  return zloc_fuse_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_zloc_fuse() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.zloc_fuse)
  return _internal_mutable_zloc_fuse();
}
inline void CivLocConfig::set_allocated_zloc_fuse(::civ::civloc::ChanelConfig* zloc_fuse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete zloc_fuse_;
  }
  if (zloc_fuse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(zloc_fuse);
    if (message_arena != submessage_arena) {
      zloc_fuse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zloc_fuse, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  zloc_fuse_ = zloc_fuse;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.zloc_fuse)
}

// required .civ.civloc.ChanelConfig forward_cfg = 23;
inline bool CivLocConfig::_internal_has_forward_cfg() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || forward_cfg_ != nullptr);
  return value;
}
inline bool CivLocConfig::has_forward_cfg() const {
  return _internal_has_forward_cfg();
}
inline void CivLocConfig::clear_forward_cfg() {
  if (forward_cfg_ != nullptr) forward_cfg_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::_internal_forward_cfg() const {
  const ::civ::civloc::ChanelConfig* p = forward_cfg_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::ChanelConfig&>(
      ::civ::civloc::_ChanelConfig_default_instance_);
}
inline const ::civ::civloc::ChanelConfig& CivLocConfig::forward_cfg() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CivLocConfig.forward_cfg)
  return _internal_forward_cfg();
}
inline void CivLocConfig::unsafe_arena_set_allocated_forward_cfg(
    ::civ::civloc::ChanelConfig* forward_cfg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(forward_cfg_);
  }
  forward_cfg_ = forward_cfg;
  if (forward_cfg) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CivLocConfig.forward_cfg)
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::release_forward_cfg() {
  _has_bits_[0] &= ~0x00001000u;
  ::civ::civloc::ChanelConfig* temp = forward_cfg_;
  forward_cfg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::unsafe_arena_release_forward_cfg() {
  // @@protoc_insertion_point(field_release:civ.civloc.CivLocConfig.forward_cfg)
  _has_bits_[0] &= ~0x00001000u;
  ::civ::civloc::ChanelConfig* temp = forward_cfg_;
  forward_cfg_ = nullptr;
  return temp;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::_internal_mutable_forward_cfg() {
  _has_bits_[0] |= 0x00001000u;
  if (forward_cfg_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::ChanelConfig>(GetArena());
    forward_cfg_ = p;
  }
  return forward_cfg_;
}
inline ::civ::civloc::ChanelConfig* CivLocConfig::mutable_forward_cfg() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CivLocConfig.forward_cfg)
  return _internal_mutable_forward_cfg();
}
inline void CivLocConfig::set_allocated_forward_cfg(::civ::civloc::ChanelConfig* forward_cfg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete forward_cfg_;
  }
  if (forward_cfg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(forward_cfg);
    if (message_arena != submessage_arena) {
      forward_cfg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forward_cfg, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  forward_cfg_ = forward_cfg;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CivLocConfig.forward_cfg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace civloc
}  // namespace civ

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::civ::civloc::PerceptionChanelConfig_Vendor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::civloc::PerceptionChanelConfig_Vendor>() {
  return ::civ::civloc::PerceptionChanelConfig_Vendor_descriptor();
}
template <> struct is_proto_enum< ::civ::civloc::CivLocConfig_WorkMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::civloc::CivLocConfig_WorkMode>() {
  return ::civ::civloc::CivLocConfig_WorkMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_civloc_2fproto_2fcivloc_2eproto
