// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: civloc/proto/sensors_setting.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_civloc_2fproto_2fsensors_5fsetting_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_civloc_2fproto_2fsensors_5fsetting_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "message/common/proto/geometry.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_civloc_2fproto_2fsensors_5fsetting_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_civloc_2fproto_2fsensors_5fsetting_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto;
namespace civ {
namespace civloc {
class AcceleratorPara;
class AcceleratorParaDefaultTypeInternal;
extern AcceleratorParaDefaultTypeInternal _AcceleratorPara_default_instance_;
class CameraPara;
class CameraParaDefaultTypeInternal;
extern CameraParaDefaultTypeInternal _CameraPara_default_instance_;
class Extrinsic;
class ExtrinsicDefaultTypeInternal;
extern ExtrinsicDefaultTypeInternal _Extrinsic_default_instance_;
class GnssPara;
class GnssParaDefaultTypeInternal;
extern GnssParaDefaultTypeInternal _GnssPara_default_instance_;
class GyroscopePara;
class GyroscopeParaDefaultTypeInternal;
extern GyroscopeParaDefaultTypeInternal _GyroscopePara_default_instance_;
class ImuPara;
class ImuParaDefaultTypeInternal;
extern ImuParaDefaultTypeInternal _ImuPara_default_instance_;
class LidarPara;
class LidarParaDefaultTypeInternal;
extern LidarParaDefaultTypeInternal _LidarPara_default_instance_;
class PerceptionPara;
class PerceptionParaDefaultTypeInternal;
extern PerceptionParaDefaultTypeInternal _PerceptionPara_default_instance_;
class SensorsSetting;
class SensorsSettingDefaultTypeInternal;
extern SensorsSettingDefaultTypeInternal _SensorsSetting_default_instance_;
class WheelOdoPara;
class WheelOdoParaDefaultTypeInternal;
extern WheelOdoParaDefaultTypeInternal _WheelOdoPara_default_instance_;
}  // namespace civloc
}  // namespace civ
PROTOBUF_NAMESPACE_OPEN
template<> ::civ::civloc::AcceleratorPara* Arena::CreateMaybeMessage<::civ::civloc::AcceleratorPara>(Arena*);
template<> ::civ::civloc::CameraPara* Arena::CreateMaybeMessage<::civ::civloc::CameraPara>(Arena*);
template<> ::civ::civloc::Extrinsic* Arena::CreateMaybeMessage<::civ::civloc::Extrinsic>(Arena*);
template<> ::civ::civloc::GnssPara* Arena::CreateMaybeMessage<::civ::civloc::GnssPara>(Arena*);
template<> ::civ::civloc::GyroscopePara* Arena::CreateMaybeMessage<::civ::civloc::GyroscopePara>(Arena*);
template<> ::civ::civloc::ImuPara* Arena::CreateMaybeMessage<::civ::civloc::ImuPara>(Arena*);
template<> ::civ::civloc::LidarPara* Arena::CreateMaybeMessage<::civ::civloc::LidarPara>(Arena*);
template<> ::civ::civloc::PerceptionPara* Arena::CreateMaybeMessage<::civ::civloc::PerceptionPara>(Arena*);
template<> ::civ::civloc::SensorsSetting* Arena::CreateMaybeMessage<::civ::civloc::SensorsSetting>(Arena*);
template<> ::civ::civloc::WheelOdoPara* Arena::CreateMaybeMessage<::civ::civloc::WheelOdoPara>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace civ {
namespace civloc {

enum CameraPara_ProjectionModel : int {
  CameraPara_ProjectionModel_Pinhole = 0
};
bool CameraPara_ProjectionModel_IsValid(int value);
constexpr CameraPara_ProjectionModel CameraPara_ProjectionModel_ProjectionModel_MIN = CameraPara_ProjectionModel_Pinhole;
constexpr CameraPara_ProjectionModel CameraPara_ProjectionModel_ProjectionModel_MAX = CameraPara_ProjectionModel_Pinhole;
constexpr int CameraPara_ProjectionModel_ProjectionModel_ARRAYSIZE = CameraPara_ProjectionModel_ProjectionModel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraPara_ProjectionModel_descriptor();
template<typename T>
inline const std::string& CameraPara_ProjectionModel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraPara_ProjectionModel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraPara_ProjectionModel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraPara_ProjectionModel_descriptor(), enum_t_value);
}
inline bool CameraPara_ProjectionModel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CameraPara_ProjectionModel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraPara_ProjectionModel>(
    CameraPara_ProjectionModel_descriptor(), name, value);
}
enum CameraPara_DistortionModel : int {
  CameraPara_DistortionModel_Radtan = 0
};
bool CameraPara_DistortionModel_IsValid(int value);
constexpr CameraPara_DistortionModel CameraPara_DistortionModel_DistortionModel_MIN = CameraPara_DistortionModel_Radtan;
constexpr CameraPara_DistortionModel CameraPara_DistortionModel_DistortionModel_MAX = CameraPara_DistortionModel_Radtan;
constexpr int CameraPara_DistortionModel_DistortionModel_ARRAYSIZE = CameraPara_DistortionModel_DistortionModel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraPara_DistortionModel_descriptor();
template<typename T>
inline const std::string& CameraPara_DistortionModel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraPara_DistortionModel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraPara_DistortionModel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraPara_DistortionModel_descriptor(), enum_t_value);
}
inline bool CameraPara_DistortionModel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CameraPara_DistortionModel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraPara_DistortionModel>(
    CameraPara_DistortionModel_descriptor(), name, value);
}
enum PerceptionPara_Type : int {
  PerceptionPara_Type_IMAGE_UV = 0,
  PerceptionPara_Type_BEV_XY = 1
};
bool PerceptionPara_Type_IsValid(int value);
constexpr PerceptionPara_Type PerceptionPara_Type_Type_MIN = PerceptionPara_Type_IMAGE_UV;
constexpr PerceptionPara_Type PerceptionPara_Type_Type_MAX = PerceptionPara_Type_BEV_XY;
constexpr int PerceptionPara_Type_Type_ARRAYSIZE = PerceptionPara_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerceptionPara_Type_descriptor();
template<typename T>
inline const std::string& PerceptionPara_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerceptionPara_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerceptionPara_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerceptionPara_Type_descriptor(), enum_t_value);
}
inline bool PerceptionPara_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerceptionPara_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerceptionPara_Type>(
    PerceptionPara_Type_descriptor(), name, value);
}
// ===================================================================

class Extrinsic PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.Extrinsic) */ {
 public:
  inline Extrinsic() : Extrinsic(nullptr) {}
  virtual ~Extrinsic();

  Extrinsic(const Extrinsic& from);
  Extrinsic(Extrinsic&& from) noexcept
    : Extrinsic() {
    *this = ::std::move(from);
  }

  inline Extrinsic& operator=(const Extrinsic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Extrinsic& operator=(Extrinsic&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Extrinsic& default_instance();

  static inline const Extrinsic* internal_default_instance() {
    return reinterpret_cast<const Extrinsic*>(
               &_Extrinsic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Extrinsic& a, Extrinsic& b) {
    a.Swap(&b);
  }
  inline void Swap(Extrinsic* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Extrinsic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Extrinsic* New() const final {
    return CreateMaybeMessage<Extrinsic>(nullptr);
  }

  Extrinsic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Extrinsic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Extrinsic& from);
  void MergeFrom(const Extrinsic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Extrinsic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.Extrinsic";
  }
  protected:
  explicit Extrinsic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto);
    return ::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTranslationFieldNumber = 2,
    kRotationFieldNumber = 3,
  };
  // required .civ.common.PointENU translation = 2;
  bool has_translation() const;
  private:
  bool _internal_has_translation() const;
  public:
  void clear_translation();
  const ::civ::common::PointENU& translation() const;
  ::civ::common::PointENU* release_translation();
  ::civ::common::PointENU* mutable_translation();
  void set_allocated_translation(::civ::common::PointENU* translation);
  private:
  const ::civ::common::PointENU& _internal_translation() const;
  ::civ::common::PointENU* _internal_mutable_translation();
  public:
  void unsafe_arena_set_allocated_translation(
      ::civ::common::PointENU* translation);
  ::civ::common::PointENU* unsafe_arena_release_translation();

  // required .civ.common.Quaternion rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::civ::common::Quaternion& rotation() const;
  ::civ::common::Quaternion* release_rotation();
  ::civ::common::Quaternion* mutable_rotation();
  void set_allocated_rotation(::civ::common::Quaternion* rotation);
  private:
  const ::civ::common::Quaternion& _internal_rotation() const;
  ::civ::common::Quaternion* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::civ::common::Quaternion* rotation);
  ::civ::common::Quaternion* unsafe_arena_release_rotation();

  // @@protoc_insertion_point(class_scope:civ.civloc.Extrinsic)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::civ::common::PointENU* translation_;
  ::civ::common::Quaternion* rotation_;
  friend struct ::TableStruct_civloc_2fproto_2fsensors_5fsetting_2eproto;
};
// -------------------------------------------------------------------

class AcceleratorPara PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.AcceleratorPara) */ {
 public:
  inline AcceleratorPara() : AcceleratorPara(nullptr) {}
  virtual ~AcceleratorPara();

  AcceleratorPara(const AcceleratorPara& from);
  AcceleratorPara(AcceleratorPara&& from) noexcept
    : AcceleratorPara() {
    *this = ::std::move(from);
  }

  inline AcceleratorPara& operator=(const AcceleratorPara& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcceleratorPara& operator=(AcceleratorPara&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AcceleratorPara& default_instance();

  static inline const AcceleratorPara* internal_default_instance() {
    return reinterpret_cast<const AcceleratorPara*>(
               &_AcceleratorPara_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AcceleratorPara& a, AcceleratorPara& b) {
    a.Swap(&b);
  }
  inline void Swap(AcceleratorPara* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcceleratorPara* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AcceleratorPara* New() const final {
    return CreateMaybeMessage<AcceleratorPara>(nullptr);
  }

  AcceleratorPara* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AcceleratorPara>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AcceleratorPara& from);
  void MergeFrom(const AcceleratorPara& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcceleratorPara* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.AcceleratorPara";
  }
  protected:
  explicit AcceleratorPara(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto);
    return ::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkewFieldNumber = 1,
    kVelocityRandomWalkFieldNumber = 2,
    kBiasStabilityFieldNumber = 3,
    kOutputNoiseFieldNumber = 5,
    kRelatedTimeSFieldNumber = 4,
  };
  // repeated double skew = 1;
  int skew_size() const;
  private:
  int _internal_skew_size() const;
  public:
  void clear_skew();
  private:
  double _internal_skew(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_skew() const;
  void _internal_add_skew(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_skew();
  public:
  double skew(int index) const;
  void set_skew(int index, double value);
  void add_skew(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      skew() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_skew();

  // repeated double velocity_random_walk = 2;
  int velocity_random_walk_size() const;
  private:
  int _internal_velocity_random_walk_size() const;
  public:
  void clear_velocity_random_walk();
  private:
  double _internal_velocity_random_walk(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_velocity_random_walk() const;
  void _internal_add_velocity_random_walk(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_velocity_random_walk();
  public:
  double velocity_random_walk(int index) const;
  void set_velocity_random_walk(int index, double value);
  void add_velocity_random_walk(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      velocity_random_walk() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_velocity_random_walk();

  // repeated double bias_stability = 3;
  int bias_stability_size() const;
  private:
  int _internal_bias_stability_size() const;
  public:
  void clear_bias_stability();
  private:
  double _internal_bias_stability(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_bias_stability() const;
  void _internal_add_bias_stability(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_bias_stability();
  public:
  double bias_stability(int index) const;
  void set_bias_stability(int index, double value);
  void add_bias_stability(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      bias_stability() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_bias_stability();

  // repeated double output_noise = 5;
  int output_noise_size() const;
  private:
  int _internal_output_noise_size() const;
  public:
  void clear_output_noise();
  private:
  double _internal_output_noise(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_output_noise() const;
  void _internal_add_output_noise(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_output_noise();
  public:
  double output_noise(int index) const;
  void set_output_noise(int index, double value);
  void add_output_noise(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      output_noise() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_output_noise();

  // required double related_time_s = 4;
  bool has_related_time_s() const;
  private:
  bool _internal_has_related_time_s() const;
  public:
  void clear_related_time_s();
  double related_time_s() const;
  void set_related_time_s(double value);
  private:
  double _internal_related_time_s() const;
  void _internal_set_related_time_s(double value);
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.AcceleratorPara)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > skew_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > velocity_random_walk_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > bias_stability_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > output_noise_;
  double related_time_s_;
  friend struct ::TableStruct_civloc_2fproto_2fsensors_5fsetting_2eproto;
};
// -------------------------------------------------------------------

class GyroscopePara PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.GyroscopePara) */ {
 public:
  inline GyroscopePara() : GyroscopePara(nullptr) {}
  virtual ~GyroscopePara();

  GyroscopePara(const GyroscopePara& from);
  GyroscopePara(GyroscopePara&& from) noexcept
    : GyroscopePara() {
    *this = ::std::move(from);
  }

  inline GyroscopePara& operator=(const GyroscopePara& from) {
    CopyFrom(from);
    return *this;
  }
  inline GyroscopePara& operator=(GyroscopePara&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GyroscopePara& default_instance();

  static inline const GyroscopePara* internal_default_instance() {
    return reinterpret_cast<const GyroscopePara*>(
               &_GyroscopePara_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GyroscopePara& a, GyroscopePara& b) {
    a.Swap(&b);
  }
  inline void Swap(GyroscopePara* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GyroscopePara* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GyroscopePara* New() const final {
    return CreateMaybeMessage<GyroscopePara>(nullptr);
  }

  GyroscopePara* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GyroscopePara>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GyroscopePara& from);
  void MergeFrom(const GyroscopePara& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GyroscopePara* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.GyroscopePara";
  }
  protected:
  explicit GyroscopePara(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto);
    return ::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkewFieldNumber = 1,
    kAngleRandomWalkFieldNumber = 2,
    kBiasStabilityFieldNumber = 3,
    kOutputNoiseFieldNumber = 5,
    kRelatedTimeSFieldNumber = 4,
  };
  // repeated double skew = 1;
  int skew_size() const;
  private:
  int _internal_skew_size() const;
  public:
  void clear_skew();
  private:
  double _internal_skew(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_skew() const;
  void _internal_add_skew(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_skew();
  public:
  double skew(int index) const;
  void set_skew(int index, double value);
  void add_skew(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      skew() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_skew();

  // repeated double angle_random_walk = 2;
  int angle_random_walk_size() const;
  private:
  int _internal_angle_random_walk_size() const;
  public:
  void clear_angle_random_walk();
  private:
  double _internal_angle_random_walk(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_angle_random_walk() const;
  void _internal_add_angle_random_walk(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_angle_random_walk();
  public:
  double angle_random_walk(int index) const;
  void set_angle_random_walk(int index, double value);
  void add_angle_random_walk(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      angle_random_walk() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_angle_random_walk();

  // repeated double bias_stability = 3;
  int bias_stability_size() const;
  private:
  int _internal_bias_stability_size() const;
  public:
  void clear_bias_stability();
  private:
  double _internal_bias_stability(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_bias_stability() const;
  void _internal_add_bias_stability(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_bias_stability();
  public:
  double bias_stability(int index) const;
  void set_bias_stability(int index, double value);
  void add_bias_stability(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      bias_stability() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_bias_stability();

  // repeated double output_noise = 5;
  int output_noise_size() const;
  private:
  int _internal_output_noise_size() const;
  public:
  void clear_output_noise();
  private:
  double _internal_output_noise(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_output_noise() const;
  void _internal_add_output_noise(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_output_noise();
  public:
  double output_noise(int index) const;
  void set_output_noise(int index, double value);
  void add_output_noise(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      output_noise() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_output_noise();

  // required double related_time_s = 4;
  bool has_related_time_s() const;
  private:
  bool _internal_has_related_time_s() const;
  public:
  void clear_related_time_s();
  double related_time_s() const;
  void set_related_time_s(double value);
  private:
  double _internal_related_time_s() const;
  void _internal_set_related_time_s(double value);
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.GyroscopePara)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > skew_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > angle_random_walk_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > bias_stability_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > output_noise_;
  double related_time_s_;
  friend struct ::TableStruct_civloc_2fproto_2fsensors_5fsetting_2eproto;
};
// -------------------------------------------------------------------

class ImuPara PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.ImuPara) */ {
 public:
  inline ImuPara() : ImuPara(nullptr) {}
  virtual ~ImuPara();

  ImuPara(const ImuPara& from);
  ImuPara(ImuPara&& from) noexcept
    : ImuPara() {
    *this = ::std::move(from);
  }

  inline ImuPara& operator=(const ImuPara& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImuPara& operator=(ImuPara&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImuPara& default_instance();

  static inline const ImuPara* internal_default_instance() {
    return reinterpret_cast<const ImuPara*>(
               &_ImuPara_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ImuPara& a, ImuPara& b) {
    a.Swap(&b);
  }
  inline void Swap(ImuPara* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImuPara* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImuPara* New() const final {
    return CreateMaybeMessage<ImuPara>(nullptr);
  }

  ImuPara* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImuPara>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImuPara& from);
  void MergeFrom(const ImuPara& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImuPara* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.ImuPara";
  }
  protected:
  explicit ImuPara(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto);
    return ::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotGyrAccFieldNumber = 5,
    kNameFieldNumber = 1,
    kAccFieldNumber = 3,
    kGyrFieldNumber = 4,
    kExParaFieldNumber = 6,
    kRateHzFieldNumber = 2,
  };
  // repeated double rot_gyr_acc = 5;
  int rot_gyr_acc_size() const;
  private:
  int _internal_rot_gyr_acc_size() const;
  public:
  void clear_rot_gyr_acc();
  private:
  double _internal_rot_gyr_acc(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_rot_gyr_acc() const;
  void _internal_add_rot_gyr_acc(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_rot_gyr_acc();
  public:
  double rot_gyr_acc(int index) const;
  void set_rot_gyr_acc(int index, double value);
  void add_rot_gyr_acc(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      rot_gyr_acc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_rot_gyr_acc();

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required .civ.civloc.AcceleratorPara acc = 3;
  bool has_acc() const;
  private:
  bool _internal_has_acc() const;
  public:
  void clear_acc();
  const ::civ::civloc::AcceleratorPara& acc() const;
  ::civ::civloc::AcceleratorPara* release_acc();
  ::civ::civloc::AcceleratorPara* mutable_acc();
  void set_allocated_acc(::civ::civloc::AcceleratorPara* acc);
  private:
  const ::civ::civloc::AcceleratorPara& _internal_acc() const;
  ::civ::civloc::AcceleratorPara* _internal_mutable_acc();
  public:
  void unsafe_arena_set_allocated_acc(
      ::civ::civloc::AcceleratorPara* acc);
  ::civ::civloc::AcceleratorPara* unsafe_arena_release_acc();

  // required .civ.civloc.GyroscopePara gyr = 4;
  bool has_gyr() const;
  private:
  bool _internal_has_gyr() const;
  public:
  void clear_gyr();
  const ::civ::civloc::GyroscopePara& gyr() const;
  ::civ::civloc::GyroscopePara* release_gyr();
  ::civ::civloc::GyroscopePara* mutable_gyr();
  void set_allocated_gyr(::civ::civloc::GyroscopePara* gyr);
  private:
  const ::civ::civloc::GyroscopePara& _internal_gyr() const;
  ::civ::civloc::GyroscopePara* _internal_mutable_gyr();
  public:
  void unsafe_arena_set_allocated_gyr(
      ::civ::civloc::GyroscopePara* gyr);
  ::civ::civloc::GyroscopePara* unsafe_arena_release_gyr();

  // required .civ.civloc.Extrinsic ex_para = 6;
  bool has_ex_para() const;
  private:
  bool _internal_has_ex_para() const;
  public:
  void clear_ex_para();
  const ::civ::civloc::Extrinsic& ex_para() const;
  ::civ::civloc::Extrinsic* release_ex_para();
  ::civ::civloc::Extrinsic* mutable_ex_para();
  void set_allocated_ex_para(::civ::civloc::Extrinsic* ex_para);
  private:
  const ::civ::civloc::Extrinsic& _internal_ex_para() const;
  ::civ::civloc::Extrinsic* _internal_mutable_ex_para();
  public:
  void unsafe_arena_set_allocated_ex_para(
      ::civ::civloc::Extrinsic* ex_para);
  ::civ::civloc::Extrinsic* unsafe_arena_release_ex_para();

  // required int32 rate_hz = 2;
  bool has_rate_hz() const;
  private:
  bool _internal_has_rate_hz() const;
  public:
  void clear_rate_hz();
  ::PROTOBUF_NAMESPACE_ID::int32 rate_hz() const;
  void set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rate_hz() const;
  void _internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.ImuPara)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > rot_gyr_acc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::civ::civloc::AcceleratorPara* acc_;
  ::civ::civloc::GyroscopePara* gyr_;
  ::civ::civloc::Extrinsic* ex_para_;
  ::PROTOBUF_NAMESPACE_ID::int32 rate_hz_;
  friend struct ::TableStruct_civloc_2fproto_2fsensors_5fsetting_2eproto;
};
// -------------------------------------------------------------------

class GnssPara PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.GnssPara) */ {
 public:
  inline GnssPara() : GnssPara(nullptr) {}
  virtual ~GnssPara();

  GnssPara(const GnssPara& from);
  GnssPara(GnssPara&& from) noexcept
    : GnssPara() {
    *this = ::std::move(from);
  }

  inline GnssPara& operator=(const GnssPara& from) {
    CopyFrom(from);
    return *this;
  }
  inline GnssPara& operator=(GnssPara&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GnssPara& default_instance();

  static inline const GnssPara* internal_default_instance() {
    return reinterpret_cast<const GnssPara*>(
               &_GnssPara_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GnssPara& a, GnssPara& b) {
    a.Swap(&b);
  }
  inline void Swap(GnssPara* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GnssPara* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GnssPara* New() const final {
    return CreateMaybeMessage<GnssPara>(nullptr);
  }

  GnssPara* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GnssPara>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GnssPara& from);
  void MergeFrom(const GnssPara& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GnssPara* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.GnssPara";
  }
  protected:
  explicit GnssPara(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto);
    return ::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExParaFieldNumber = 4,
    kRateHzFieldNumber = 2,
    kWithDifferentialInformationFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required .civ.civloc.Extrinsic ex_para = 4;
  bool has_ex_para() const;
  private:
  bool _internal_has_ex_para() const;
  public:
  void clear_ex_para();
  const ::civ::civloc::Extrinsic& ex_para() const;
  ::civ::civloc::Extrinsic* release_ex_para();
  ::civ::civloc::Extrinsic* mutable_ex_para();
  void set_allocated_ex_para(::civ::civloc::Extrinsic* ex_para);
  private:
  const ::civ::civloc::Extrinsic& _internal_ex_para() const;
  ::civ::civloc::Extrinsic* _internal_mutable_ex_para();
  public:
  void unsafe_arena_set_allocated_ex_para(
      ::civ::civloc::Extrinsic* ex_para);
  ::civ::civloc::Extrinsic* unsafe_arena_release_ex_para();

  // required int32 rate_hz = 2;
  bool has_rate_hz() const;
  private:
  bool _internal_has_rate_hz() const;
  public:
  void clear_rate_hz();
  ::PROTOBUF_NAMESPACE_ID::int32 rate_hz() const;
  void set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rate_hz() const;
  void _internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required bool with_differential_information = 3;
  bool has_with_differential_information() const;
  private:
  bool _internal_has_with_differential_information() const;
  public:
  void clear_with_differential_information();
  bool with_differential_information() const;
  void set_with_differential_information(bool value);
  private:
  bool _internal_with_differential_information() const;
  void _internal_set_with_differential_information(bool value);
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.GnssPara)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::civ::civloc::Extrinsic* ex_para_;
  ::PROTOBUF_NAMESPACE_ID::int32 rate_hz_;
  bool with_differential_information_;
  friend struct ::TableStruct_civloc_2fproto_2fsensors_5fsetting_2eproto;
};
// -------------------------------------------------------------------

class CameraPara PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.CameraPara) */ {
 public:
  inline CameraPara() : CameraPara(nullptr) {}
  virtual ~CameraPara();

  CameraPara(const CameraPara& from);
  CameraPara(CameraPara&& from) noexcept
    : CameraPara() {
    *this = ::std::move(from);
  }

  inline CameraPara& operator=(const CameraPara& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraPara& operator=(CameraPara&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraPara& default_instance();

  static inline const CameraPara* internal_default_instance() {
    return reinterpret_cast<const CameraPara*>(
               &_CameraPara_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CameraPara& a, CameraPara& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraPara* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraPara* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraPara* New() const final {
    return CreateMaybeMessage<CameraPara>(nullptr);
  }

  CameraPara* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraPara>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraPara& from);
  void MergeFrom(const CameraPara& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraPara* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.CameraPara";
  }
  protected:
  explicit CameraPara(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto);
    return ::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CameraPara_ProjectionModel ProjectionModel;
  static constexpr ProjectionModel Pinhole =
    CameraPara_ProjectionModel_Pinhole;
  static inline bool ProjectionModel_IsValid(int value) {
    return CameraPara_ProjectionModel_IsValid(value);
  }
  static constexpr ProjectionModel ProjectionModel_MIN =
    CameraPara_ProjectionModel_ProjectionModel_MIN;
  static constexpr ProjectionModel ProjectionModel_MAX =
    CameraPara_ProjectionModel_ProjectionModel_MAX;
  static constexpr int ProjectionModel_ARRAYSIZE =
    CameraPara_ProjectionModel_ProjectionModel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ProjectionModel_descriptor() {
    return CameraPara_ProjectionModel_descriptor();
  }
  template<typename T>
  static inline const std::string& ProjectionModel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ProjectionModel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ProjectionModel_Name.");
    return CameraPara_ProjectionModel_Name(enum_t_value);
  }
  static inline bool ProjectionModel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ProjectionModel* value) {
    return CameraPara_ProjectionModel_Parse(name, value);
  }

  typedef CameraPara_DistortionModel DistortionModel;
  static constexpr DistortionModel Radtan =
    CameraPara_DistortionModel_Radtan;
  static inline bool DistortionModel_IsValid(int value) {
    return CameraPara_DistortionModel_IsValid(value);
  }
  static constexpr DistortionModel DistortionModel_MIN =
    CameraPara_DistortionModel_DistortionModel_MIN;
  static constexpr DistortionModel DistortionModel_MAX =
    CameraPara_DistortionModel_DistortionModel_MAX;
  static constexpr int DistortionModel_ARRAYSIZE =
    CameraPara_DistortionModel_DistortionModel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DistortionModel_descriptor() {
    return CameraPara_DistortionModel_descriptor();
  }
  template<typename T>
  static inline const std::string& DistortionModel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DistortionModel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DistortionModel_Name.");
    return CameraPara_DistortionModel_Name(enum_t_value);
  }
  static inline bool DistortionModel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DistortionModel* value) {
    return CameraPara_DistortionModel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResolutionFieldNumber = 3,
    kKFieldNumber = 5,
    kDistortionCoffFieldNumber = 8,
    kNameFieldNumber = 1,
    kExParaFieldNumber = 10,
    kRateHzFieldNumber = 2,
    kProjectionModelFieldNumber = 6,
    kDistortionModelFieldNumber = 7,
  };
  // repeated double resolution = 3;
  int resolution_size() const;
  private:
  int _internal_resolution_size() const;
  public:
  void clear_resolution();
  private:
  double _internal_resolution(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_resolution() const;
  void _internal_add_resolution(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_resolution();
  public:
  double resolution(int index) const;
  void set_resolution(int index, double value);
  void add_resolution(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      resolution() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_resolution();

  // repeated double K = 5;
  int k_size() const;
  private:
  int _internal_k_size() const;
  public:
  void clear_k();
  private:
  double _internal_k(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_k() const;
  void _internal_add_k(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_k();
  public:
  double k(int index) const;
  void set_k(int index, double value);
  void add_k(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      k() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_k();

  // repeated double distortion_coff_ = 8;
  int distortion_coff__size() const;
  private:
  int _internal_distortion_coff__size() const;
  public:
  void clear_distortion_coff_();
  private:
  double _internal_distortion_coff_(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_distortion_coff_() const;
  void _internal_add_distortion_coff_(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_distortion_coff_();
  public:
  double distortion_coff_(int index) const;
  void set_distortion_coff_(int index, double value);
  void add_distortion_coff_(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      distortion_coff_() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_distortion_coff_();

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required .civ.civloc.Extrinsic ex_para = 10;
  bool has_ex_para() const;
  private:
  bool _internal_has_ex_para() const;
  public:
  void clear_ex_para();
  const ::civ::civloc::Extrinsic& ex_para() const;
  ::civ::civloc::Extrinsic* release_ex_para();
  ::civ::civloc::Extrinsic* mutable_ex_para();
  void set_allocated_ex_para(::civ::civloc::Extrinsic* ex_para);
  private:
  const ::civ::civloc::Extrinsic& _internal_ex_para() const;
  ::civ::civloc::Extrinsic* _internal_mutable_ex_para();
  public:
  void unsafe_arena_set_allocated_ex_para(
      ::civ::civloc::Extrinsic* ex_para);
  ::civ::civloc::Extrinsic* unsafe_arena_release_ex_para();

  // required int32 rate_hz = 2;
  bool has_rate_hz() const;
  private:
  bool _internal_has_rate_hz() const;
  public:
  void clear_rate_hz();
  ::PROTOBUF_NAMESPACE_ID::int32 rate_hz() const;
  void set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rate_hz() const;
  void _internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required .civ.civloc.CameraPara.ProjectionModel projection_model = 6 [default = Pinhole];
  bool has_projection_model() const;
  private:
  bool _internal_has_projection_model() const;
  public:
  void clear_projection_model();
  ::civ::civloc::CameraPara_ProjectionModel projection_model() const;
  void set_projection_model(::civ::civloc::CameraPara_ProjectionModel value);
  private:
  ::civ::civloc::CameraPara_ProjectionModel _internal_projection_model() const;
  void _internal_set_projection_model(::civ::civloc::CameraPara_ProjectionModel value);
  public:

  // required .civ.civloc.CameraPara.DistortionModel distortion_model = 7 [default = Radtan];
  bool has_distortion_model() const;
  private:
  bool _internal_has_distortion_model() const;
  public:
  void clear_distortion_model();
  ::civ::civloc::CameraPara_DistortionModel distortion_model() const;
  void set_distortion_model(::civ::civloc::CameraPara_DistortionModel value);
  private:
  ::civ::civloc::CameraPara_DistortionModel _internal_distortion_model() const;
  void _internal_set_distortion_model(::civ::civloc::CameraPara_DistortionModel value);
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.CameraPara)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > resolution_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > k_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > distortion_coff__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::civ::civloc::Extrinsic* ex_para_;
  ::PROTOBUF_NAMESPACE_ID::int32 rate_hz_;
  int projection_model_;
  int distortion_model_;
  friend struct ::TableStruct_civloc_2fproto_2fsensors_5fsetting_2eproto;
};
// -------------------------------------------------------------------

class PerceptionPara PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.PerceptionPara) */ {
 public:
  inline PerceptionPara() : PerceptionPara(nullptr) {}
  virtual ~PerceptionPara();

  PerceptionPara(const PerceptionPara& from);
  PerceptionPara(PerceptionPara&& from) noexcept
    : PerceptionPara() {
    *this = ::std::move(from);
  }

  inline PerceptionPara& operator=(const PerceptionPara& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerceptionPara& operator=(PerceptionPara&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PerceptionPara& default_instance();

  static inline const PerceptionPara* internal_default_instance() {
    return reinterpret_cast<const PerceptionPara*>(
               &_PerceptionPara_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PerceptionPara& a, PerceptionPara& b) {
    a.Swap(&b);
  }
  inline void Swap(PerceptionPara* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerceptionPara* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PerceptionPara* New() const final {
    return CreateMaybeMessage<PerceptionPara>(nullptr);
  }

  PerceptionPara* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PerceptionPara>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PerceptionPara& from);
  void MergeFrom(const PerceptionPara& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerceptionPara* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.PerceptionPara";
  }
  protected:
  explicit PerceptionPara(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto);
    return ::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PerceptionPara_Type Type;
  static constexpr Type IMAGE_UV =
    PerceptionPara_Type_IMAGE_UV;
  static constexpr Type BEV_XY =
    PerceptionPara_Type_BEV_XY;
  static inline bool Type_IsValid(int value) {
    return PerceptionPara_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    PerceptionPara_Type_Type_MIN;
  static constexpr Type Type_MAX =
    PerceptionPara_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    PerceptionPara_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return PerceptionPara_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return PerceptionPara_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return PerceptionPara_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCamParaFieldNumber = 5,
    kTypeFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required .civ.civloc.CameraPara cam_para = 5;
  bool has_cam_para() const;
  private:
  bool _internal_has_cam_para() const;
  public:
  void clear_cam_para();
  const ::civ::civloc::CameraPara& cam_para() const;
  ::civ::civloc::CameraPara* release_cam_para();
  ::civ::civloc::CameraPara* mutable_cam_para();
  void set_allocated_cam_para(::civ::civloc::CameraPara* cam_para);
  private:
  const ::civ::civloc::CameraPara& _internal_cam_para() const;
  ::civ::civloc::CameraPara* _internal_mutable_cam_para();
  public:
  void unsafe_arena_set_allocated_cam_para(
      ::civ::civloc::CameraPara* cam_para);
  ::civ::civloc::CameraPara* unsafe_arena_release_cam_para();

  // required .civ.civloc.PerceptionPara.Type type = 2 [default = BEV_XY];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::civ::civloc::PerceptionPara_Type type() const;
  void set_type(::civ::civloc::PerceptionPara_Type value);
  private:
  ::civ::civloc::PerceptionPara_Type _internal_type() const;
  void _internal_set_type(::civ::civloc::PerceptionPara_Type value);
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.PerceptionPara)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::civ::civloc::CameraPara* cam_para_;
  int type_;
  friend struct ::TableStruct_civloc_2fproto_2fsensors_5fsetting_2eproto;
};
// -------------------------------------------------------------------

class WheelOdoPara PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.WheelOdoPara) */ {
 public:
  inline WheelOdoPara() : WheelOdoPara(nullptr) {}
  virtual ~WheelOdoPara();

  WheelOdoPara(const WheelOdoPara& from);
  WheelOdoPara(WheelOdoPara&& from) noexcept
    : WheelOdoPara() {
    *this = ::std::move(from);
  }

  inline WheelOdoPara& operator=(const WheelOdoPara& from) {
    CopyFrom(from);
    return *this;
  }
  inline WheelOdoPara& operator=(WheelOdoPara&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WheelOdoPara& default_instance();

  static inline const WheelOdoPara* internal_default_instance() {
    return reinterpret_cast<const WheelOdoPara*>(
               &_WheelOdoPara_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(WheelOdoPara& a, WheelOdoPara& b) {
    a.Swap(&b);
  }
  inline void Swap(WheelOdoPara* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WheelOdoPara* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WheelOdoPara* New() const final {
    return CreateMaybeMessage<WheelOdoPara>(nullptr);
  }

  WheelOdoPara* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WheelOdoPara>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WheelOdoPara& from);
  void MergeFrom(const WheelOdoPara& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WheelOdoPara* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.WheelOdoPara";
  }
  protected:
  explicit WheelOdoPara(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto);
    return ::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKoFieldNumber = 6,
    kNameFieldNumber = 1,
    kWFieldNumber = 3,
    kL1FieldNumber = 4,
    kL2FieldNumber = 5,
    kRateHzFieldNumber = 2,
  };
  // repeated double ko = 6;
  int ko_size() const;
  private:
  int _internal_ko_size() const;
  public:
  void clear_ko();
  private:
  double _internal_ko(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_ko() const;
  void _internal_add_ko(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_ko();
  public:
  double ko(int index) const;
  void set_ko(int index, double value);
  void add_ko(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      ko() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_ko();

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required double w = 3;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  double w() const;
  void set_w(double value);
  private:
  double _internal_w() const;
  void _internal_set_w(double value);
  public:

  // required double l1 = 4;
  bool has_l1() const;
  private:
  bool _internal_has_l1() const;
  public:
  void clear_l1();
  double l1() const;
  void set_l1(double value);
  private:
  double _internal_l1() const;
  void _internal_set_l1(double value);
  public:

  // required double l2 = 5;
  bool has_l2() const;
  private:
  bool _internal_has_l2() const;
  public:
  void clear_l2();
  double l2() const;
  void set_l2(double value);
  private:
  double _internal_l2() const;
  void _internal_set_l2(double value);
  public:

  // required int32 rate_hz = 2;
  bool has_rate_hz() const;
  private:
  bool _internal_has_rate_hz() const;
  public:
  void clear_rate_hz();
  ::PROTOBUF_NAMESPACE_ID::int32 rate_hz() const;
  void set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rate_hz() const;
  void _internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.WheelOdoPara)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > ko_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double w_;
  double l1_;
  double l2_;
  ::PROTOBUF_NAMESPACE_ID::int32 rate_hz_;
  friend struct ::TableStruct_civloc_2fproto_2fsensors_5fsetting_2eproto;
};
// -------------------------------------------------------------------

class LidarPara PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.LidarPara) */ {
 public:
  inline LidarPara() : LidarPara(nullptr) {}
  virtual ~LidarPara();

  LidarPara(const LidarPara& from);
  LidarPara(LidarPara&& from) noexcept
    : LidarPara() {
    *this = ::std::move(from);
  }

  inline LidarPara& operator=(const LidarPara& from) {
    CopyFrom(from);
    return *this;
  }
  inline LidarPara& operator=(LidarPara&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LidarPara& default_instance();

  static inline const LidarPara* internal_default_instance() {
    return reinterpret_cast<const LidarPara*>(
               &_LidarPara_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LidarPara& a, LidarPara& b) {
    a.Swap(&b);
  }
  inline void Swap(LidarPara* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LidarPara* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LidarPara* New() const final {
    return CreateMaybeMessage<LidarPara>(nullptr);
  }

  LidarPara* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LidarPara>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LidarPara& from);
  void MergeFrom(const LidarPara& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LidarPara* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.LidarPara";
  }
  protected:
  explicit LidarPara(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto);
    return ::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExParaFieldNumber = 3,
    kRateHzFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required .civ.civloc.Extrinsic ex_para = 3;
  bool has_ex_para() const;
  private:
  bool _internal_has_ex_para() const;
  public:
  void clear_ex_para();
  const ::civ::civloc::Extrinsic& ex_para() const;
  ::civ::civloc::Extrinsic* release_ex_para();
  ::civ::civloc::Extrinsic* mutable_ex_para();
  void set_allocated_ex_para(::civ::civloc::Extrinsic* ex_para);
  private:
  const ::civ::civloc::Extrinsic& _internal_ex_para() const;
  ::civ::civloc::Extrinsic* _internal_mutable_ex_para();
  public:
  void unsafe_arena_set_allocated_ex_para(
      ::civ::civloc::Extrinsic* ex_para);
  ::civ::civloc::Extrinsic* unsafe_arena_release_ex_para();

  // required int32 rate_hz = 2;
  bool has_rate_hz() const;
  private:
  bool _internal_has_rate_hz() const;
  public:
  void clear_rate_hz();
  ::PROTOBUF_NAMESPACE_ID::int32 rate_hz() const;
  void set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rate_hz() const;
  void _internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:civ.civloc.LidarPara)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::civ::civloc::Extrinsic* ex_para_;
  ::PROTOBUF_NAMESPACE_ID::int32 rate_hz_;
  friend struct ::TableStruct_civloc_2fproto_2fsensors_5fsetting_2eproto;
};
// -------------------------------------------------------------------

class SensorsSetting PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:civ.civloc.SensorsSetting) */ {
 public:
  inline SensorsSetting() : SensorsSetting(nullptr) {}
  virtual ~SensorsSetting();

  SensorsSetting(const SensorsSetting& from);
  SensorsSetting(SensorsSetting&& from) noexcept
    : SensorsSetting() {
    *this = ::std::move(from);
  }

  inline SensorsSetting& operator=(const SensorsSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorsSetting& operator=(SensorsSetting&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorsSetting& default_instance();

  static inline const SensorsSetting* internal_default_instance() {
    return reinterpret_cast<const SensorsSetting*>(
               &_SensorsSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SensorsSetting& a, SensorsSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorsSetting* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorsSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorsSetting* New() const final {
    return CreateMaybeMessage<SensorsSetting>(nullptr);
  }

  SensorsSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorsSetting>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorsSetting& from);
  void MergeFrom(const SensorsSetting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorsSetting* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "civ.civloc.SensorsSetting";
  }
  protected:
  explicit SensorsSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto);
    return ::descriptor_table_civloc_2fproto_2fsensors_5fsetting_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImuFieldNumber = 3,
    kGnssFieldNumber = 4,
    kPercFieldNumber = 5,
    kVersionFieldNumber = 1,
    kVehicleNameFieldNumber = 2,
    kWheelFieldNumber = 6,
    kLidarFieldNumber = 7,
  };
  // repeated .civ.civloc.ImuPara imu = 3;
  int imu_size() const;
  private:
  int _internal_imu_size() const;
  public:
  void clear_imu();
  ::civ::civloc::ImuPara* mutable_imu(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::ImuPara >*
      mutable_imu();
  private:
  const ::civ::civloc::ImuPara& _internal_imu(int index) const;
  ::civ::civloc::ImuPara* _internal_add_imu();
  public:
  const ::civ::civloc::ImuPara& imu(int index) const;
  ::civ::civloc::ImuPara* add_imu();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::ImuPara >&
      imu() const;

  // repeated .civ.civloc.GnssPara gnss = 4;
  int gnss_size() const;
  private:
  int _internal_gnss_size() const;
  public:
  void clear_gnss();
  ::civ::civloc::GnssPara* mutable_gnss(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::GnssPara >*
      mutable_gnss();
  private:
  const ::civ::civloc::GnssPara& _internal_gnss(int index) const;
  ::civ::civloc::GnssPara* _internal_add_gnss();
  public:
  const ::civ::civloc::GnssPara& gnss(int index) const;
  ::civ::civloc::GnssPara* add_gnss();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::GnssPara >&
      gnss() const;

  // repeated .civ.civloc.PerceptionPara perc = 5;
  int perc_size() const;
  private:
  int _internal_perc_size() const;
  public:
  void clear_perc();
  ::civ::civloc::PerceptionPara* mutable_perc(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::PerceptionPara >*
      mutable_perc();
  private:
  const ::civ::civloc::PerceptionPara& _internal_perc(int index) const;
  ::civ::civloc::PerceptionPara* _internal_add_perc();
  public:
  const ::civ::civloc::PerceptionPara& perc(int index) const;
  ::civ::civloc::PerceptionPara* add_perc();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::PerceptionPara >&
      perc() const;

  // required string version = 1 [default = "1.0.0"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // required string vehicle_name = 2;
  bool has_vehicle_name() const;
  private:
  bool _internal_has_vehicle_name() const;
  public:
  void clear_vehicle_name();
  const std::string& vehicle_name() const;
  void set_vehicle_name(const std::string& value);
  void set_vehicle_name(std::string&& value);
  void set_vehicle_name(const char* value);
  void set_vehicle_name(const char* value, size_t size);
  std::string* mutable_vehicle_name();
  std::string* release_vehicle_name();
  void set_allocated_vehicle_name(std::string* vehicle_name);
  private:
  const std::string& _internal_vehicle_name() const;
  void _internal_set_vehicle_name(const std::string& value);
  std::string* _internal_mutable_vehicle_name();
  public:

  // optional .civ.civloc.WheelOdoPara wheel = 6;
  bool has_wheel() const;
  private:
  bool _internal_has_wheel() const;
  public:
  void clear_wheel();
  const ::civ::civloc::WheelOdoPara& wheel() const;
  ::civ::civloc::WheelOdoPara* release_wheel();
  ::civ::civloc::WheelOdoPara* mutable_wheel();
  void set_allocated_wheel(::civ::civloc::WheelOdoPara* wheel);
  private:
  const ::civ::civloc::WheelOdoPara& _internal_wheel() const;
  ::civ::civloc::WheelOdoPara* _internal_mutable_wheel();
  public:
  void unsafe_arena_set_allocated_wheel(
      ::civ::civloc::WheelOdoPara* wheel);
  ::civ::civloc::WheelOdoPara* unsafe_arena_release_wheel();

  // optional .civ.civloc.LidarPara lidar = 7;
  bool has_lidar() const;
  private:
  bool _internal_has_lidar() const;
  public:
  void clear_lidar();
  const ::civ::civloc::LidarPara& lidar() const;
  ::civ::civloc::LidarPara* release_lidar();
  ::civ::civloc::LidarPara* mutable_lidar();
  void set_allocated_lidar(::civ::civloc::LidarPara* lidar);
  private:
  const ::civ::civloc::LidarPara& _internal_lidar() const;
  ::civ::civloc::LidarPara* _internal_mutable_lidar();
  public:
  void unsafe_arena_set_allocated_lidar(
      ::civ::civloc::LidarPara* lidar);
  ::civ::civloc::LidarPara* unsafe_arena_release_lidar();

  // @@protoc_insertion_point(class_scope:civ.civloc.SensorsSetting)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::ImuPara > imu_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::GnssPara > gnss_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::PerceptionPara > perc_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_name_;
  ::civ::civloc::WheelOdoPara* wheel_;
  ::civ::civloc::LidarPara* lidar_;
  friend struct ::TableStruct_civloc_2fproto_2fsensors_5fsetting_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Extrinsic

// required .civ.common.PointENU translation = 2;
inline bool Extrinsic::_internal_has_translation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || translation_ != nullptr);
  return value;
}
inline bool Extrinsic::has_translation() const {
  return _internal_has_translation();
}
inline const ::civ::common::PointENU& Extrinsic::_internal_translation() const {
  const ::civ::common::PointENU* p = translation_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::common::PointENU&>(
      ::civ::common::_PointENU_default_instance_);
}
inline const ::civ::common::PointENU& Extrinsic::translation() const {
  // @@protoc_insertion_point(field_get:civ.civloc.Extrinsic.translation)
  return _internal_translation();
}
inline void Extrinsic::unsafe_arena_set_allocated_translation(
    ::civ::common::PointENU* translation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(translation_);
  }
  translation_ = translation;
  if (translation) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.Extrinsic.translation)
}
inline ::civ::common::PointENU* Extrinsic::release_translation() {
  _has_bits_[0] &= ~0x00000001u;
  ::civ::common::PointENU* temp = translation_;
  translation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::common::PointENU* Extrinsic::unsafe_arena_release_translation() {
  // @@protoc_insertion_point(field_release:civ.civloc.Extrinsic.translation)
  _has_bits_[0] &= ~0x00000001u;
  ::civ::common::PointENU* temp = translation_;
  translation_ = nullptr;
  return temp;
}
inline ::civ::common::PointENU* Extrinsic::_internal_mutable_translation() {
  _has_bits_[0] |= 0x00000001u;
  if (translation_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::common::PointENU>(GetArena());
    translation_ = p;
  }
  return translation_;
}
inline ::civ::common::PointENU* Extrinsic::mutable_translation() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.Extrinsic.translation)
  return _internal_mutable_translation();
}
inline void Extrinsic::set_allocated_translation(::civ::common::PointENU* translation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(translation_);
  }
  if (translation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(translation)->GetArena();
    if (message_arena != submessage_arena) {
      translation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, translation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  translation_ = translation;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.Extrinsic.translation)
}

// required .civ.common.Quaternion rotation = 3;
inline bool Extrinsic::_internal_has_rotation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || rotation_ != nullptr);
  return value;
}
inline bool Extrinsic::has_rotation() const {
  return _internal_has_rotation();
}
inline const ::civ::common::Quaternion& Extrinsic::_internal_rotation() const {
  const ::civ::common::Quaternion* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::common::Quaternion&>(
      ::civ::common::_Quaternion_default_instance_);
}
inline const ::civ::common::Quaternion& Extrinsic::rotation() const {
  // @@protoc_insertion_point(field_get:civ.civloc.Extrinsic.rotation)
  return _internal_rotation();
}
inline void Extrinsic::unsafe_arena_set_allocated_rotation(
    ::civ::common::Quaternion* rotation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.Extrinsic.rotation)
}
inline ::civ::common::Quaternion* Extrinsic::release_rotation() {
  _has_bits_[0] &= ~0x00000002u;
  ::civ::common::Quaternion* temp = rotation_;
  rotation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::common::Quaternion* Extrinsic::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:civ.civloc.Extrinsic.rotation)
  _has_bits_[0] &= ~0x00000002u;
  ::civ::common::Quaternion* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::civ::common::Quaternion* Extrinsic::_internal_mutable_rotation() {
  _has_bits_[0] |= 0x00000002u;
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::common::Quaternion>(GetArena());
    rotation_ = p;
  }
  return rotation_;
}
inline ::civ::common::Quaternion* Extrinsic::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.Extrinsic.rotation)
  return _internal_mutable_rotation();
}
inline void Extrinsic::set_allocated_rotation(::civ::common::Quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation)->GetArena();
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.Extrinsic.rotation)
}

// -------------------------------------------------------------------

// AcceleratorPara

// repeated double skew = 1;
inline int AcceleratorPara::_internal_skew_size() const {
  return skew_.size();
}
inline int AcceleratorPara::skew_size() const {
  return _internal_skew_size();
}
inline void AcceleratorPara::clear_skew() {
  skew_.Clear();
}
inline double AcceleratorPara::_internal_skew(int index) const {
  return skew_.Get(index);
}
inline double AcceleratorPara::skew(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.AcceleratorPara.skew)
  return _internal_skew(index);
}
inline void AcceleratorPara::set_skew(int index, double value) {
  skew_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.AcceleratorPara.skew)
}
inline void AcceleratorPara::_internal_add_skew(double value) {
  skew_.Add(value);
}
inline void AcceleratorPara::add_skew(double value) {
  _internal_add_skew(value);
  // @@protoc_insertion_point(field_add:civ.civloc.AcceleratorPara.skew)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcceleratorPara::_internal_skew() const {
  return skew_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcceleratorPara::skew() const {
  // @@protoc_insertion_point(field_list:civ.civloc.AcceleratorPara.skew)
  return _internal_skew();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcceleratorPara::_internal_mutable_skew() {
  return &skew_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcceleratorPara::mutable_skew() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.AcceleratorPara.skew)
  return _internal_mutable_skew();
}

// repeated double velocity_random_walk = 2;
inline int AcceleratorPara::_internal_velocity_random_walk_size() const {
  return velocity_random_walk_.size();
}
inline int AcceleratorPara::velocity_random_walk_size() const {
  return _internal_velocity_random_walk_size();
}
inline void AcceleratorPara::clear_velocity_random_walk() {
  velocity_random_walk_.Clear();
}
inline double AcceleratorPara::_internal_velocity_random_walk(int index) const {
  return velocity_random_walk_.Get(index);
}
inline double AcceleratorPara::velocity_random_walk(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.AcceleratorPara.velocity_random_walk)
  return _internal_velocity_random_walk(index);
}
inline void AcceleratorPara::set_velocity_random_walk(int index, double value) {
  velocity_random_walk_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.AcceleratorPara.velocity_random_walk)
}
inline void AcceleratorPara::_internal_add_velocity_random_walk(double value) {
  velocity_random_walk_.Add(value);
}
inline void AcceleratorPara::add_velocity_random_walk(double value) {
  _internal_add_velocity_random_walk(value);
  // @@protoc_insertion_point(field_add:civ.civloc.AcceleratorPara.velocity_random_walk)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcceleratorPara::_internal_velocity_random_walk() const {
  return velocity_random_walk_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcceleratorPara::velocity_random_walk() const {
  // @@protoc_insertion_point(field_list:civ.civloc.AcceleratorPara.velocity_random_walk)
  return _internal_velocity_random_walk();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcceleratorPara::_internal_mutable_velocity_random_walk() {
  return &velocity_random_walk_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcceleratorPara::mutable_velocity_random_walk() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.AcceleratorPara.velocity_random_walk)
  return _internal_mutable_velocity_random_walk();
}

// repeated double bias_stability = 3;
inline int AcceleratorPara::_internal_bias_stability_size() const {
  return bias_stability_.size();
}
inline int AcceleratorPara::bias_stability_size() const {
  return _internal_bias_stability_size();
}
inline void AcceleratorPara::clear_bias_stability() {
  bias_stability_.Clear();
}
inline double AcceleratorPara::_internal_bias_stability(int index) const {
  return bias_stability_.Get(index);
}
inline double AcceleratorPara::bias_stability(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.AcceleratorPara.bias_stability)
  return _internal_bias_stability(index);
}
inline void AcceleratorPara::set_bias_stability(int index, double value) {
  bias_stability_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.AcceleratorPara.bias_stability)
}
inline void AcceleratorPara::_internal_add_bias_stability(double value) {
  bias_stability_.Add(value);
}
inline void AcceleratorPara::add_bias_stability(double value) {
  _internal_add_bias_stability(value);
  // @@protoc_insertion_point(field_add:civ.civloc.AcceleratorPara.bias_stability)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcceleratorPara::_internal_bias_stability() const {
  return bias_stability_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcceleratorPara::bias_stability() const {
  // @@protoc_insertion_point(field_list:civ.civloc.AcceleratorPara.bias_stability)
  return _internal_bias_stability();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcceleratorPara::_internal_mutable_bias_stability() {
  return &bias_stability_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcceleratorPara::mutable_bias_stability() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.AcceleratorPara.bias_stability)
  return _internal_mutable_bias_stability();
}

// required double related_time_s = 4;
inline bool AcceleratorPara::_internal_has_related_time_s() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AcceleratorPara::has_related_time_s() const {
  return _internal_has_related_time_s();
}
inline void AcceleratorPara::clear_related_time_s() {
  related_time_s_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double AcceleratorPara::_internal_related_time_s() const {
  return related_time_s_;
}
inline double AcceleratorPara::related_time_s() const {
  // @@protoc_insertion_point(field_get:civ.civloc.AcceleratorPara.related_time_s)
  return _internal_related_time_s();
}
inline void AcceleratorPara::_internal_set_related_time_s(double value) {
  _has_bits_[0] |= 0x00000001u;
  related_time_s_ = value;
}
inline void AcceleratorPara::set_related_time_s(double value) {
  _internal_set_related_time_s(value);
  // @@protoc_insertion_point(field_set:civ.civloc.AcceleratorPara.related_time_s)
}

// repeated double output_noise = 5;
inline int AcceleratorPara::_internal_output_noise_size() const {
  return output_noise_.size();
}
inline int AcceleratorPara::output_noise_size() const {
  return _internal_output_noise_size();
}
inline void AcceleratorPara::clear_output_noise() {
  output_noise_.Clear();
}
inline double AcceleratorPara::_internal_output_noise(int index) const {
  return output_noise_.Get(index);
}
inline double AcceleratorPara::output_noise(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.AcceleratorPara.output_noise)
  return _internal_output_noise(index);
}
inline void AcceleratorPara::set_output_noise(int index, double value) {
  output_noise_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.AcceleratorPara.output_noise)
}
inline void AcceleratorPara::_internal_add_output_noise(double value) {
  output_noise_.Add(value);
}
inline void AcceleratorPara::add_output_noise(double value) {
  _internal_add_output_noise(value);
  // @@protoc_insertion_point(field_add:civ.civloc.AcceleratorPara.output_noise)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcceleratorPara::_internal_output_noise() const {
  return output_noise_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AcceleratorPara::output_noise() const {
  // @@protoc_insertion_point(field_list:civ.civloc.AcceleratorPara.output_noise)
  return _internal_output_noise();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcceleratorPara::_internal_mutable_output_noise() {
  return &output_noise_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AcceleratorPara::mutable_output_noise() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.AcceleratorPara.output_noise)
  return _internal_mutable_output_noise();
}

// -------------------------------------------------------------------

// GyroscopePara

// repeated double skew = 1;
inline int GyroscopePara::_internal_skew_size() const {
  return skew_.size();
}
inline int GyroscopePara::skew_size() const {
  return _internal_skew_size();
}
inline void GyroscopePara::clear_skew() {
  skew_.Clear();
}
inline double GyroscopePara::_internal_skew(int index) const {
  return skew_.Get(index);
}
inline double GyroscopePara::skew(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.GyroscopePara.skew)
  return _internal_skew(index);
}
inline void GyroscopePara::set_skew(int index, double value) {
  skew_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.GyroscopePara.skew)
}
inline void GyroscopePara::_internal_add_skew(double value) {
  skew_.Add(value);
}
inline void GyroscopePara::add_skew(double value) {
  _internal_add_skew(value);
  // @@protoc_insertion_point(field_add:civ.civloc.GyroscopePara.skew)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GyroscopePara::_internal_skew() const {
  return skew_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GyroscopePara::skew() const {
  // @@protoc_insertion_point(field_list:civ.civloc.GyroscopePara.skew)
  return _internal_skew();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GyroscopePara::_internal_mutable_skew() {
  return &skew_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GyroscopePara::mutable_skew() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.GyroscopePara.skew)
  return _internal_mutable_skew();
}

// repeated double angle_random_walk = 2;
inline int GyroscopePara::_internal_angle_random_walk_size() const {
  return angle_random_walk_.size();
}
inline int GyroscopePara::angle_random_walk_size() const {
  return _internal_angle_random_walk_size();
}
inline void GyroscopePara::clear_angle_random_walk() {
  angle_random_walk_.Clear();
}
inline double GyroscopePara::_internal_angle_random_walk(int index) const {
  return angle_random_walk_.Get(index);
}
inline double GyroscopePara::angle_random_walk(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.GyroscopePara.angle_random_walk)
  return _internal_angle_random_walk(index);
}
inline void GyroscopePara::set_angle_random_walk(int index, double value) {
  angle_random_walk_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.GyroscopePara.angle_random_walk)
}
inline void GyroscopePara::_internal_add_angle_random_walk(double value) {
  angle_random_walk_.Add(value);
}
inline void GyroscopePara::add_angle_random_walk(double value) {
  _internal_add_angle_random_walk(value);
  // @@protoc_insertion_point(field_add:civ.civloc.GyroscopePara.angle_random_walk)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GyroscopePara::_internal_angle_random_walk() const {
  return angle_random_walk_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GyroscopePara::angle_random_walk() const {
  // @@protoc_insertion_point(field_list:civ.civloc.GyroscopePara.angle_random_walk)
  return _internal_angle_random_walk();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GyroscopePara::_internal_mutable_angle_random_walk() {
  return &angle_random_walk_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GyroscopePara::mutable_angle_random_walk() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.GyroscopePara.angle_random_walk)
  return _internal_mutable_angle_random_walk();
}

// repeated double bias_stability = 3;
inline int GyroscopePara::_internal_bias_stability_size() const {
  return bias_stability_.size();
}
inline int GyroscopePara::bias_stability_size() const {
  return _internal_bias_stability_size();
}
inline void GyroscopePara::clear_bias_stability() {
  bias_stability_.Clear();
}
inline double GyroscopePara::_internal_bias_stability(int index) const {
  return bias_stability_.Get(index);
}
inline double GyroscopePara::bias_stability(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.GyroscopePara.bias_stability)
  return _internal_bias_stability(index);
}
inline void GyroscopePara::set_bias_stability(int index, double value) {
  bias_stability_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.GyroscopePara.bias_stability)
}
inline void GyroscopePara::_internal_add_bias_stability(double value) {
  bias_stability_.Add(value);
}
inline void GyroscopePara::add_bias_stability(double value) {
  _internal_add_bias_stability(value);
  // @@protoc_insertion_point(field_add:civ.civloc.GyroscopePara.bias_stability)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GyroscopePara::_internal_bias_stability() const {
  return bias_stability_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GyroscopePara::bias_stability() const {
  // @@protoc_insertion_point(field_list:civ.civloc.GyroscopePara.bias_stability)
  return _internal_bias_stability();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GyroscopePara::_internal_mutable_bias_stability() {
  return &bias_stability_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GyroscopePara::mutable_bias_stability() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.GyroscopePara.bias_stability)
  return _internal_mutable_bias_stability();
}

// required double related_time_s = 4;
inline bool GyroscopePara::_internal_has_related_time_s() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GyroscopePara::has_related_time_s() const {
  return _internal_has_related_time_s();
}
inline void GyroscopePara::clear_related_time_s() {
  related_time_s_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double GyroscopePara::_internal_related_time_s() const {
  return related_time_s_;
}
inline double GyroscopePara::related_time_s() const {
  // @@protoc_insertion_point(field_get:civ.civloc.GyroscopePara.related_time_s)
  return _internal_related_time_s();
}
inline void GyroscopePara::_internal_set_related_time_s(double value) {
  _has_bits_[0] |= 0x00000001u;
  related_time_s_ = value;
}
inline void GyroscopePara::set_related_time_s(double value) {
  _internal_set_related_time_s(value);
  // @@protoc_insertion_point(field_set:civ.civloc.GyroscopePara.related_time_s)
}

// repeated double output_noise = 5;
inline int GyroscopePara::_internal_output_noise_size() const {
  return output_noise_.size();
}
inline int GyroscopePara::output_noise_size() const {
  return _internal_output_noise_size();
}
inline void GyroscopePara::clear_output_noise() {
  output_noise_.Clear();
}
inline double GyroscopePara::_internal_output_noise(int index) const {
  return output_noise_.Get(index);
}
inline double GyroscopePara::output_noise(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.GyroscopePara.output_noise)
  return _internal_output_noise(index);
}
inline void GyroscopePara::set_output_noise(int index, double value) {
  output_noise_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.GyroscopePara.output_noise)
}
inline void GyroscopePara::_internal_add_output_noise(double value) {
  output_noise_.Add(value);
}
inline void GyroscopePara::add_output_noise(double value) {
  _internal_add_output_noise(value);
  // @@protoc_insertion_point(field_add:civ.civloc.GyroscopePara.output_noise)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GyroscopePara::_internal_output_noise() const {
  return output_noise_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GyroscopePara::output_noise() const {
  // @@protoc_insertion_point(field_list:civ.civloc.GyroscopePara.output_noise)
  return _internal_output_noise();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GyroscopePara::_internal_mutable_output_noise() {
  return &output_noise_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GyroscopePara::mutable_output_noise() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.GyroscopePara.output_noise)
  return _internal_mutable_output_noise();
}

// -------------------------------------------------------------------

// ImuPara

// required string name = 1;
inline bool ImuPara::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImuPara::has_name() const {
  return _internal_has_name();
}
inline void ImuPara::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImuPara::name() const {
  // @@protoc_insertion_point(field_get:civ.civloc.ImuPara.name)
  return _internal_name();
}
inline void ImuPara::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:civ.civloc.ImuPara.name)
}
inline std::string* ImuPara::mutable_name() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.ImuPara.name)
  return _internal_mutable_name();
}
inline const std::string& ImuPara::_internal_name() const {
  return name_.Get();
}
inline void ImuPara::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ImuPara::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.ImuPara.name)
}
inline void ImuPara::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.ImuPara.name)
}
inline void ImuPara::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.ImuPara.name)
}
inline std::string* ImuPara::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ImuPara::release_name() {
  // @@protoc_insertion_point(field_release:civ.civloc.ImuPara.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImuPara::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.ImuPara.name)
}

// required int32 rate_hz = 2;
inline bool ImuPara::_internal_has_rate_hz() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ImuPara::has_rate_hz() const {
  return _internal_has_rate_hz();
}
inline void ImuPara::clear_rate_hz() {
  rate_hz_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImuPara::_internal_rate_hz() const {
  return rate_hz_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImuPara::rate_hz() const {
  // @@protoc_insertion_point(field_get:civ.civloc.ImuPara.rate_hz)
  return _internal_rate_hz();
}
inline void ImuPara::_internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  rate_hz_ = value;
}
inline void ImuPara::set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rate_hz(value);
  // @@protoc_insertion_point(field_set:civ.civloc.ImuPara.rate_hz)
}

// required .civ.civloc.AcceleratorPara acc = 3;
inline bool ImuPara::_internal_has_acc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || acc_ != nullptr);
  return value;
}
inline bool ImuPara::has_acc() const {
  return _internal_has_acc();
}
inline void ImuPara::clear_acc() {
  if (acc_ != nullptr) acc_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::civ::civloc::AcceleratorPara& ImuPara::_internal_acc() const {
  const ::civ::civloc::AcceleratorPara* p = acc_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::AcceleratorPara&>(
      ::civ::civloc::_AcceleratorPara_default_instance_);
}
inline const ::civ::civloc::AcceleratorPara& ImuPara::acc() const {
  // @@protoc_insertion_point(field_get:civ.civloc.ImuPara.acc)
  return _internal_acc();
}
inline void ImuPara::unsafe_arena_set_allocated_acc(
    ::civ::civloc::AcceleratorPara* acc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc_);
  }
  acc_ = acc;
  if (acc) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.ImuPara.acc)
}
inline ::civ::civloc::AcceleratorPara* ImuPara::release_acc() {
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::AcceleratorPara* temp = acc_;
  acc_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::AcceleratorPara* ImuPara::unsafe_arena_release_acc() {
  // @@protoc_insertion_point(field_release:civ.civloc.ImuPara.acc)
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::AcceleratorPara* temp = acc_;
  acc_ = nullptr;
  return temp;
}
inline ::civ::civloc::AcceleratorPara* ImuPara::_internal_mutable_acc() {
  _has_bits_[0] |= 0x00000002u;
  if (acc_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::AcceleratorPara>(GetArena());
    acc_ = p;
  }
  return acc_;
}
inline ::civ::civloc::AcceleratorPara* ImuPara::mutable_acc() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.ImuPara.acc)
  return _internal_mutable_acc();
}
inline void ImuPara::set_allocated_acc(::civ::civloc::AcceleratorPara* acc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete acc_;
  }
  if (acc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(acc);
    if (message_arena != submessage_arena) {
      acc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  acc_ = acc;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.ImuPara.acc)
}

// required .civ.civloc.GyroscopePara gyr = 4;
inline bool ImuPara::_internal_has_gyr() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || gyr_ != nullptr);
  return value;
}
inline bool ImuPara::has_gyr() const {
  return _internal_has_gyr();
}
inline void ImuPara::clear_gyr() {
  if (gyr_ != nullptr) gyr_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::civ::civloc::GyroscopePara& ImuPara::_internal_gyr() const {
  const ::civ::civloc::GyroscopePara* p = gyr_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::GyroscopePara&>(
      ::civ::civloc::_GyroscopePara_default_instance_);
}
inline const ::civ::civloc::GyroscopePara& ImuPara::gyr() const {
  // @@protoc_insertion_point(field_get:civ.civloc.ImuPara.gyr)
  return _internal_gyr();
}
inline void ImuPara::unsafe_arena_set_allocated_gyr(
    ::civ::civloc::GyroscopePara* gyr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gyr_);
  }
  gyr_ = gyr;
  if (gyr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.ImuPara.gyr)
}
inline ::civ::civloc::GyroscopePara* ImuPara::release_gyr() {
  _has_bits_[0] &= ~0x00000004u;
  ::civ::civloc::GyroscopePara* temp = gyr_;
  gyr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::GyroscopePara* ImuPara::unsafe_arena_release_gyr() {
  // @@protoc_insertion_point(field_release:civ.civloc.ImuPara.gyr)
  _has_bits_[0] &= ~0x00000004u;
  ::civ::civloc::GyroscopePara* temp = gyr_;
  gyr_ = nullptr;
  return temp;
}
inline ::civ::civloc::GyroscopePara* ImuPara::_internal_mutable_gyr() {
  _has_bits_[0] |= 0x00000004u;
  if (gyr_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::GyroscopePara>(GetArena());
    gyr_ = p;
  }
  return gyr_;
}
inline ::civ::civloc::GyroscopePara* ImuPara::mutable_gyr() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.ImuPara.gyr)
  return _internal_mutable_gyr();
}
inline void ImuPara::set_allocated_gyr(::civ::civloc::GyroscopePara* gyr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gyr_;
  }
  if (gyr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gyr);
    if (message_arena != submessage_arena) {
      gyr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gyr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gyr_ = gyr;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.ImuPara.gyr)
}

// repeated double rot_gyr_acc = 5;
inline int ImuPara::_internal_rot_gyr_acc_size() const {
  return rot_gyr_acc_.size();
}
inline int ImuPara::rot_gyr_acc_size() const {
  return _internal_rot_gyr_acc_size();
}
inline void ImuPara::clear_rot_gyr_acc() {
  rot_gyr_acc_.Clear();
}
inline double ImuPara::_internal_rot_gyr_acc(int index) const {
  return rot_gyr_acc_.Get(index);
}
inline double ImuPara::rot_gyr_acc(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.ImuPara.rot_gyr_acc)
  return _internal_rot_gyr_acc(index);
}
inline void ImuPara::set_rot_gyr_acc(int index, double value) {
  rot_gyr_acc_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.ImuPara.rot_gyr_acc)
}
inline void ImuPara::_internal_add_rot_gyr_acc(double value) {
  rot_gyr_acc_.Add(value);
}
inline void ImuPara::add_rot_gyr_acc(double value) {
  _internal_add_rot_gyr_acc(value);
  // @@protoc_insertion_point(field_add:civ.civloc.ImuPara.rot_gyr_acc)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ImuPara::_internal_rot_gyr_acc() const {
  return rot_gyr_acc_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ImuPara::rot_gyr_acc() const {
  // @@protoc_insertion_point(field_list:civ.civloc.ImuPara.rot_gyr_acc)
  return _internal_rot_gyr_acc();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ImuPara::_internal_mutable_rot_gyr_acc() {
  return &rot_gyr_acc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ImuPara::mutable_rot_gyr_acc() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.ImuPara.rot_gyr_acc)
  return _internal_mutable_rot_gyr_acc();
}

// required .civ.civloc.Extrinsic ex_para = 6;
inline bool ImuPara::_internal_has_ex_para() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || ex_para_ != nullptr);
  return value;
}
inline bool ImuPara::has_ex_para() const {
  return _internal_has_ex_para();
}
inline void ImuPara::clear_ex_para() {
  if (ex_para_ != nullptr) ex_para_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::civ::civloc::Extrinsic& ImuPara::_internal_ex_para() const {
  const ::civ::civloc::Extrinsic* p = ex_para_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::Extrinsic&>(
      ::civ::civloc::_Extrinsic_default_instance_);
}
inline const ::civ::civloc::Extrinsic& ImuPara::ex_para() const {
  // @@protoc_insertion_point(field_get:civ.civloc.ImuPara.ex_para)
  return _internal_ex_para();
}
inline void ImuPara::unsafe_arena_set_allocated_ex_para(
    ::civ::civloc::Extrinsic* ex_para) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ex_para_);
  }
  ex_para_ = ex_para;
  if (ex_para) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.ImuPara.ex_para)
}
inline ::civ::civloc::Extrinsic* ImuPara::release_ex_para() {
  _has_bits_[0] &= ~0x00000008u;
  ::civ::civloc::Extrinsic* temp = ex_para_;
  ex_para_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::Extrinsic* ImuPara::unsafe_arena_release_ex_para() {
  // @@protoc_insertion_point(field_release:civ.civloc.ImuPara.ex_para)
  _has_bits_[0] &= ~0x00000008u;
  ::civ::civloc::Extrinsic* temp = ex_para_;
  ex_para_ = nullptr;
  return temp;
}
inline ::civ::civloc::Extrinsic* ImuPara::_internal_mutable_ex_para() {
  _has_bits_[0] |= 0x00000008u;
  if (ex_para_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::Extrinsic>(GetArena());
    ex_para_ = p;
  }
  return ex_para_;
}
inline ::civ::civloc::Extrinsic* ImuPara::mutable_ex_para() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.ImuPara.ex_para)
  return _internal_mutable_ex_para();
}
inline void ImuPara::set_allocated_ex_para(::civ::civloc::Extrinsic* ex_para) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ex_para_;
  }
  if (ex_para) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ex_para);
    if (message_arena != submessage_arena) {
      ex_para = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ex_para, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ex_para_ = ex_para;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.ImuPara.ex_para)
}

// -------------------------------------------------------------------

// GnssPara

// required string name = 1;
inline bool GnssPara::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GnssPara::has_name() const {
  return _internal_has_name();
}
inline void GnssPara::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GnssPara::name() const {
  // @@protoc_insertion_point(field_get:civ.civloc.GnssPara.name)
  return _internal_name();
}
inline void GnssPara::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:civ.civloc.GnssPara.name)
}
inline std::string* GnssPara::mutable_name() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.GnssPara.name)
  return _internal_mutable_name();
}
inline const std::string& GnssPara::_internal_name() const {
  return name_.Get();
}
inline void GnssPara::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GnssPara::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.GnssPara.name)
}
inline void GnssPara::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.GnssPara.name)
}
inline void GnssPara::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.GnssPara.name)
}
inline std::string* GnssPara::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GnssPara::release_name() {
  // @@protoc_insertion_point(field_release:civ.civloc.GnssPara.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GnssPara::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.GnssPara.name)
}

// required int32 rate_hz = 2;
inline bool GnssPara::_internal_has_rate_hz() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GnssPara::has_rate_hz() const {
  return _internal_has_rate_hz();
}
inline void GnssPara::clear_rate_hz() {
  rate_hz_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GnssPara::_internal_rate_hz() const {
  return rate_hz_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GnssPara::rate_hz() const {
  // @@protoc_insertion_point(field_get:civ.civloc.GnssPara.rate_hz)
  return _internal_rate_hz();
}
inline void GnssPara::_internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  rate_hz_ = value;
}
inline void GnssPara::set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rate_hz(value);
  // @@protoc_insertion_point(field_set:civ.civloc.GnssPara.rate_hz)
}

// required bool with_differential_information = 3;
inline bool GnssPara::_internal_has_with_differential_information() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GnssPara::has_with_differential_information() const {
  return _internal_has_with_differential_information();
}
inline void GnssPara::clear_with_differential_information() {
  with_differential_information_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool GnssPara::_internal_with_differential_information() const {
  return with_differential_information_;
}
inline bool GnssPara::with_differential_information() const {
  // @@protoc_insertion_point(field_get:civ.civloc.GnssPara.with_differential_information)
  return _internal_with_differential_information();
}
inline void GnssPara::_internal_set_with_differential_information(bool value) {
  _has_bits_[0] |= 0x00000008u;
  with_differential_information_ = value;
}
inline void GnssPara::set_with_differential_information(bool value) {
  _internal_set_with_differential_information(value);
  // @@protoc_insertion_point(field_set:civ.civloc.GnssPara.with_differential_information)
}

// required .civ.civloc.Extrinsic ex_para = 4;
inline bool GnssPara::_internal_has_ex_para() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || ex_para_ != nullptr);
  return value;
}
inline bool GnssPara::has_ex_para() const {
  return _internal_has_ex_para();
}
inline void GnssPara::clear_ex_para() {
  if (ex_para_ != nullptr) ex_para_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::civ::civloc::Extrinsic& GnssPara::_internal_ex_para() const {
  const ::civ::civloc::Extrinsic* p = ex_para_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::Extrinsic&>(
      ::civ::civloc::_Extrinsic_default_instance_);
}
inline const ::civ::civloc::Extrinsic& GnssPara::ex_para() const {
  // @@protoc_insertion_point(field_get:civ.civloc.GnssPara.ex_para)
  return _internal_ex_para();
}
inline void GnssPara::unsafe_arena_set_allocated_ex_para(
    ::civ::civloc::Extrinsic* ex_para) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ex_para_);
  }
  ex_para_ = ex_para;
  if (ex_para) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.GnssPara.ex_para)
}
inline ::civ::civloc::Extrinsic* GnssPara::release_ex_para() {
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::Extrinsic* temp = ex_para_;
  ex_para_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::Extrinsic* GnssPara::unsafe_arena_release_ex_para() {
  // @@protoc_insertion_point(field_release:civ.civloc.GnssPara.ex_para)
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::Extrinsic* temp = ex_para_;
  ex_para_ = nullptr;
  return temp;
}
inline ::civ::civloc::Extrinsic* GnssPara::_internal_mutable_ex_para() {
  _has_bits_[0] |= 0x00000002u;
  if (ex_para_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::Extrinsic>(GetArena());
    ex_para_ = p;
  }
  return ex_para_;
}
inline ::civ::civloc::Extrinsic* GnssPara::mutable_ex_para() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.GnssPara.ex_para)
  return _internal_mutable_ex_para();
}
inline void GnssPara::set_allocated_ex_para(::civ::civloc::Extrinsic* ex_para) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ex_para_;
  }
  if (ex_para) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ex_para);
    if (message_arena != submessage_arena) {
      ex_para = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ex_para, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ex_para_ = ex_para;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.GnssPara.ex_para)
}

// -------------------------------------------------------------------

// CameraPara

// required string name = 1;
inline bool CameraPara::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CameraPara::has_name() const {
  return _internal_has_name();
}
inline void CameraPara::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CameraPara::name() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CameraPara.name)
  return _internal_name();
}
inline void CameraPara::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:civ.civloc.CameraPara.name)
}
inline std::string* CameraPara::mutable_name() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CameraPara.name)
  return _internal_mutable_name();
}
inline const std::string& CameraPara::_internal_name() const {
  return name_.Get();
}
inline void CameraPara::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CameraPara::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.CameraPara.name)
}
inline void CameraPara::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.CameraPara.name)
}
inline void CameraPara::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.CameraPara.name)
}
inline std::string* CameraPara::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CameraPara::release_name() {
  // @@protoc_insertion_point(field_release:civ.civloc.CameraPara.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CameraPara::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CameraPara.name)
}

// required int32 rate_hz = 2;
inline bool CameraPara::_internal_has_rate_hz() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CameraPara::has_rate_hz() const {
  return _internal_has_rate_hz();
}
inline void CameraPara::clear_rate_hz() {
  rate_hz_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CameraPara::_internal_rate_hz() const {
  return rate_hz_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CameraPara::rate_hz() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CameraPara.rate_hz)
  return _internal_rate_hz();
}
inline void CameraPara::_internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  rate_hz_ = value;
}
inline void CameraPara::set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rate_hz(value);
  // @@protoc_insertion_point(field_set:civ.civloc.CameraPara.rate_hz)
}

// repeated double resolution = 3;
inline int CameraPara::_internal_resolution_size() const {
  return resolution_.size();
}
inline int CameraPara::resolution_size() const {
  return _internal_resolution_size();
}
inline void CameraPara::clear_resolution() {
  resolution_.Clear();
}
inline double CameraPara::_internal_resolution(int index) const {
  return resolution_.Get(index);
}
inline double CameraPara::resolution(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.CameraPara.resolution)
  return _internal_resolution(index);
}
inline void CameraPara::set_resolution(int index, double value) {
  resolution_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.CameraPara.resolution)
}
inline void CameraPara::_internal_add_resolution(double value) {
  resolution_.Add(value);
}
inline void CameraPara::add_resolution(double value) {
  _internal_add_resolution(value);
  // @@protoc_insertion_point(field_add:civ.civloc.CameraPara.resolution)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraPara::_internal_resolution() const {
  return resolution_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraPara::resolution() const {
  // @@protoc_insertion_point(field_list:civ.civloc.CameraPara.resolution)
  return _internal_resolution();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraPara::_internal_mutable_resolution() {
  return &resolution_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraPara::mutable_resolution() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.CameraPara.resolution)
  return _internal_mutable_resolution();
}

// repeated double K = 5;
inline int CameraPara::_internal_k_size() const {
  return k_.size();
}
inline int CameraPara::k_size() const {
  return _internal_k_size();
}
inline void CameraPara::clear_k() {
  k_.Clear();
}
inline double CameraPara::_internal_k(int index) const {
  return k_.Get(index);
}
inline double CameraPara::k(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.CameraPara.K)
  return _internal_k(index);
}
inline void CameraPara::set_k(int index, double value) {
  k_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.CameraPara.K)
}
inline void CameraPara::_internal_add_k(double value) {
  k_.Add(value);
}
inline void CameraPara::add_k(double value) {
  _internal_add_k(value);
  // @@protoc_insertion_point(field_add:civ.civloc.CameraPara.K)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraPara::_internal_k() const {
  return k_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraPara::k() const {
  // @@protoc_insertion_point(field_list:civ.civloc.CameraPara.K)
  return _internal_k();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraPara::_internal_mutable_k() {
  return &k_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraPara::mutable_k() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.CameraPara.K)
  return _internal_mutable_k();
}

// required .civ.civloc.CameraPara.ProjectionModel projection_model = 6 [default = Pinhole];
inline bool CameraPara::_internal_has_projection_model() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CameraPara::has_projection_model() const {
  return _internal_has_projection_model();
}
inline void CameraPara::clear_projection_model() {
  projection_model_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::civ::civloc::CameraPara_ProjectionModel CameraPara::_internal_projection_model() const {
  return static_cast< ::civ::civloc::CameraPara_ProjectionModel >(projection_model_);
}
inline ::civ::civloc::CameraPara_ProjectionModel CameraPara::projection_model() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CameraPara.projection_model)
  return _internal_projection_model();
}
inline void CameraPara::_internal_set_projection_model(::civ::civloc::CameraPara_ProjectionModel value) {
  assert(::civ::civloc::CameraPara_ProjectionModel_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  projection_model_ = value;
}
inline void CameraPara::set_projection_model(::civ::civloc::CameraPara_ProjectionModel value) {
  _internal_set_projection_model(value);
  // @@protoc_insertion_point(field_set:civ.civloc.CameraPara.projection_model)
}

// required .civ.civloc.CameraPara.DistortionModel distortion_model = 7 [default = Radtan];
inline bool CameraPara::_internal_has_distortion_model() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CameraPara::has_distortion_model() const {
  return _internal_has_distortion_model();
}
inline void CameraPara::clear_distortion_model() {
  distortion_model_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::civ::civloc::CameraPara_DistortionModel CameraPara::_internal_distortion_model() const {
  return static_cast< ::civ::civloc::CameraPara_DistortionModel >(distortion_model_);
}
inline ::civ::civloc::CameraPara_DistortionModel CameraPara::distortion_model() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CameraPara.distortion_model)
  return _internal_distortion_model();
}
inline void CameraPara::_internal_set_distortion_model(::civ::civloc::CameraPara_DistortionModel value) {
  assert(::civ::civloc::CameraPara_DistortionModel_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  distortion_model_ = value;
}
inline void CameraPara::set_distortion_model(::civ::civloc::CameraPara_DistortionModel value) {
  _internal_set_distortion_model(value);
  // @@protoc_insertion_point(field_set:civ.civloc.CameraPara.distortion_model)
}

// repeated double distortion_coff_ = 8;
inline int CameraPara::_internal_distortion_coff__size() const {
  return distortion_coff__.size();
}
inline int CameraPara::distortion_coff__size() const {
  return _internal_distortion_coff__size();
}
inline void CameraPara::clear_distortion_coff_() {
  distortion_coff__.Clear();
}
inline double CameraPara::_internal_distortion_coff_(int index) const {
  return distortion_coff__.Get(index);
}
inline double CameraPara::distortion_coff_(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.CameraPara.distortion_coff_)
  return _internal_distortion_coff_(index);
}
inline void CameraPara::set_distortion_coff_(int index, double value) {
  distortion_coff__.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.CameraPara.distortion_coff_)
}
inline void CameraPara::_internal_add_distortion_coff_(double value) {
  distortion_coff__.Add(value);
}
inline void CameraPara::add_distortion_coff_(double value) {
  _internal_add_distortion_coff_(value);
  // @@protoc_insertion_point(field_add:civ.civloc.CameraPara.distortion_coff_)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraPara::_internal_distortion_coff_() const {
  return distortion_coff__;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraPara::distortion_coff_() const {
  // @@protoc_insertion_point(field_list:civ.civloc.CameraPara.distortion_coff_)
  return _internal_distortion_coff_();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraPara::_internal_mutable_distortion_coff_() {
  return &distortion_coff__;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraPara::mutable_distortion_coff_() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.CameraPara.distortion_coff_)
  return _internal_mutable_distortion_coff_();
}

// required .civ.civloc.Extrinsic ex_para = 10;
inline bool CameraPara::_internal_has_ex_para() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || ex_para_ != nullptr);
  return value;
}
inline bool CameraPara::has_ex_para() const {
  return _internal_has_ex_para();
}
inline void CameraPara::clear_ex_para() {
  if (ex_para_ != nullptr) ex_para_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::civ::civloc::Extrinsic& CameraPara::_internal_ex_para() const {
  const ::civ::civloc::Extrinsic* p = ex_para_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::Extrinsic&>(
      ::civ::civloc::_Extrinsic_default_instance_);
}
inline const ::civ::civloc::Extrinsic& CameraPara::ex_para() const {
  // @@protoc_insertion_point(field_get:civ.civloc.CameraPara.ex_para)
  return _internal_ex_para();
}
inline void CameraPara::unsafe_arena_set_allocated_ex_para(
    ::civ::civloc::Extrinsic* ex_para) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ex_para_);
  }
  ex_para_ = ex_para;
  if (ex_para) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.CameraPara.ex_para)
}
inline ::civ::civloc::Extrinsic* CameraPara::release_ex_para() {
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::Extrinsic* temp = ex_para_;
  ex_para_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::Extrinsic* CameraPara::unsafe_arena_release_ex_para() {
  // @@protoc_insertion_point(field_release:civ.civloc.CameraPara.ex_para)
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::Extrinsic* temp = ex_para_;
  ex_para_ = nullptr;
  return temp;
}
inline ::civ::civloc::Extrinsic* CameraPara::_internal_mutable_ex_para() {
  _has_bits_[0] |= 0x00000002u;
  if (ex_para_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::Extrinsic>(GetArena());
    ex_para_ = p;
  }
  return ex_para_;
}
inline ::civ::civloc::Extrinsic* CameraPara::mutable_ex_para() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.CameraPara.ex_para)
  return _internal_mutable_ex_para();
}
inline void CameraPara::set_allocated_ex_para(::civ::civloc::Extrinsic* ex_para) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ex_para_;
  }
  if (ex_para) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ex_para);
    if (message_arena != submessage_arena) {
      ex_para = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ex_para, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ex_para_ = ex_para;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.CameraPara.ex_para)
}

// -------------------------------------------------------------------

// PerceptionPara

// required string name = 1;
inline bool PerceptionPara::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PerceptionPara::has_name() const {
  return _internal_has_name();
}
inline void PerceptionPara::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PerceptionPara::name() const {
  // @@protoc_insertion_point(field_get:civ.civloc.PerceptionPara.name)
  return _internal_name();
}
inline void PerceptionPara::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:civ.civloc.PerceptionPara.name)
}
inline std::string* PerceptionPara::mutable_name() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.PerceptionPara.name)
  return _internal_mutable_name();
}
inline const std::string& PerceptionPara::_internal_name() const {
  return name_.Get();
}
inline void PerceptionPara::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PerceptionPara::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.PerceptionPara.name)
}
inline void PerceptionPara::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.PerceptionPara.name)
}
inline void PerceptionPara::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.PerceptionPara.name)
}
inline std::string* PerceptionPara::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PerceptionPara::release_name() {
  // @@protoc_insertion_point(field_release:civ.civloc.PerceptionPara.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PerceptionPara::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.PerceptionPara.name)
}

// required .civ.civloc.PerceptionPara.Type type = 2 [default = BEV_XY];
inline bool PerceptionPara::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PerceptionPara::has_type() const {
  return _internal_has_type();
}
inline void PerceptionPara::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::civ::civloc::PerceptionPara_Type PerceptionPara::_internal_type() const {
  return static_cast< ::civ::civloc::PerceptionPara_Type >(type_);
}
inline ::civ::civloc::PerceptionPara_Type PerceptionPara::type() const {
  // @@protoc_insertion_point(field_get:civ.civloc.PerceptionPara.type)
  return _internal_type();
}
inline void PerceptionPara::_internal_set_type(::civ::civloc::PerceptionPara_Type value) {
  assert(::civ::civloc::PerceptionPara_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void PerceptionPara::set_type(::civ::civloc::PerceptionPara_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:civ.civloc.PerceptionPara.type)
}

// required .civ.civloc.CameraPara cam_para = 5;
inline bool PerceptionPara::_internal_has_cam_para() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || cam_para_ != nullptr);
  return value;
}
inline bool PerceptionPara::has_cam_para() const {
  return _internal_has_cam_para();
}
inline void PerceptionPara::clear_cam_para() {
  if (cam_para_ != nullptr) cam_para_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::civ::civloc::CameraPara& PerceptionPara::_internal_cam_para() const {
  const ::civ::civloc::CameraPara* p = cam_para_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::CameraPara&>(
      ::civ::civloc::_CameraPara_default_instance_);
}
inline const ::civ::civloc::CameraPara& PerceptionPara::cam_para() const {
  // @@protoc_insertion_point(field_get:civ.civloc.PerceptionPara.cam_para)
  return _internal_cam_para();
}
inline void PerceptionPara::unsafe_arena_set_allocated_cam_para(
    ::civ::civloc::CameraPara* cam_para) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cam_para_);
  }
  cam_para_ = cam_para;
  if (cam_para) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.PerceptionPara.cam_para)
}
inline ::civ::civloc::CameraPara* PerceptionPara::release_cam_para() {
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::CameraPara* temp = cam_para_;
  cam_para_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::CameraPara* PerceptionPara::unsafe_arena_release_cam_para() {
  // @@protoc_insertion_point(field_release:civ.civloc.PerceptionPara.cam_para)
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::CameraPara* temp = cam_para_;
  cam_para_ = nullptr;
  return temp;
}
inline ::civ::civloc::CameraPara* PerceptionPara::_internal_mutable_cam_para() {
  _has_bits_[0] |= 0x00000002u;
  if (cam_para_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::CameraPara>(GetArena());
    cam_para_ = p;
  }
  return cam_para_;
}
inline ::civ::civloc::CameraPara* PerceptionPara::mutable_cam_para() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.PerceptionPara.cam_para)
  return _internal_mutable_cam_para();
}
inline void PerceptionPara::set_allocated_cam_para(::civ::civloc::CameraPara* cam_para) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cam_para_;
  }
  if (cam_para) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cam_para);
    if (message_arena != submessage_arena) {
      cam_para = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cam_para, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cam_para_ = cam_para;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.PerceptionPara.cam_para)
}

// -------------------------------------------------------------------

// WheelOdoPara

// required string name = 1;
inline bool WheelOdoPara::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WheelOdoPara::has_name() const {
  return _internal_has_name();
}
inline void WheelOdoPara::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WheelOdoPara::name() const {
  // @@protoc_insertion_point(field_get:civ.civloc.WheelOdoPara.name)
  return _internal_name();
}
inline void WheelOdoPara::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:civ.civloc.WheelOdoPara.name)
}
inline std::string* WheelOdoPara::mutable_name() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.WheelOdoPara.name)
  return _internal_mutable_name();
}
inline const std::string& WheelOdoPara::_internal_name() const {
  return name_.Get();
}
inline void WheelOdoPara::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void WheelOdoPara::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.WheelOdoPara.name)
}
inline void WheelOdoPara::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.WheelOdoPara.name)
}
inline void WheelOdoPara::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.WheelOdoPara.name)
}
inline std::string* WheelOdoPara::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* WheelOdoPara::release_name() {
  // @@protoc_insertion_point(field_release:civ.civloc.WheelOdoPara.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void WheelOdoPara::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.WheelOdoPara.name)
}

// required int32 rate_hz = 2;
inline bool WheelOdoPara::_internal_has_rate_hz() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool WheelOdoPara::has_rate_hz() const {
  return _internal_has_rate_hz();
}
inline void WheelOdoPara::clear_rate_hz() {
  rate_hz_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WheelOdoPara::_internal_rate_hz() const {
  return rate_hz_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WheelOdoPara::rate_hz() const {
  // @@protoc_insertion_point(field_get:civ.civloc.WheelOdoPara.rate_hz)
  return _internal_rate_hz();
}
inline void WheelOdoPara::_internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  rate_hz_ = value;
}
inline void WheelOdoPara::set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rate_hz(value);
  // @@protoc_insertion_point(field_set:civ.civloc.WheelOdoPara.rate_hz)
}

// required double w = 3;
inline bool WheelOdoPara::_internal_has_w() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WheelOdoPara::has_w() const {
  return _internal_has_w();
}
inline void WheelOdoPara::clear_w() {
  w_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double WheelOdoPara::_internal_w() const {
  return w_;
}
inline double WheelOdoPara::w() const {
  // @@protoc_insertion_point(field_get:civ.civloc.WheelOdoPara.w)
  return _internal_w();
}
inline void WheelOdoPara::_internal_set_w(double value) {
  _has_bits_[0] |= 0x00000002u;
  w_ = value;
}
inline void WheelOdoPara::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:civ.civloc.WheelOdoPara.w)
}

// required double l1 = 4;
inline bool WheelOdoPara::_internal_has_l1() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WheelOdoPara::has_l1() const {
  return _internal_has_l1();
}
inline void WheelOdoPara::clear_l1() {
  l1_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double WheelOdoPara::_internal_l1() const {
  return l1_;
}
inline double WheelOdoPara::l1() const {
  // @@protoc_insertion_point(field_get:civ.civloc.WheelOdoPara.l1)
  return _internal_l1();
}
inline void WheelOdoPara::_internal_set_l1(double value) {
  _has_bits_[0] |= 0x00000004u;
  l1_ = value;
}
inline void WheelOdoPara::set_l1(double value) {
  _internal_set_l1(value);
  // @@protoc_insertion_point(field_set:civ.civloc.WheelOdoPara.l1)
}

// required double l2 = 5;
inline bool WheelOdoPara::_internal_has_l2() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WheelOdoPara::has_l2() const {
  return _internal_has_l2();
}
inline void WheelOdoPara::clear_l2() {
  l2_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double WheelOdoPara::_internal_l2() const {
  return l2_;
}
inline double WheelOdoPara::l2() const {
  // @@protoc_insertion_point(field_get:civ.civloc.WheelOdoPara.l2)
  return _internal_l2();
}
inline void WheelOdoPara::_internal_set_l2(double value) {
  _has_bits_[0] |= 0x00000008u;
  l2_ = value;
}
inline void WheelOdoPara::set_l2(double value) {
  _internal_set_l2(value);
  // @@protoc_insertion_point(field_set:civ.civloc.WheelOdoPara.l2)
}

// repeated double ko = 6;
inline int WheelOdoPara::_internal_ko_size() const {
  return ko_.size();
}
inline int WheelOdoPara::ko_size() const {
  return _internal_ko_size();
}
inline void WheelOdoPara::clear_ko() {
  ko_.Clear();
}
inline double WheelOdoPara::_internal_ko(int index) const {
  return ko_.Get(index);
}
inline double WheelOdoPara::ko(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.WheelOdoPara.ko)
  return _internal_ko(index);
}
inline void WheelOdoPara::set_ko(int index, double value) {
  ko_.Set(index, value);
  // @@protoc_insertion_point(field_set:civ.civloc.WheelOdoPara.ko)
}
inline void WheelOdoPara::_internal_add_ko(double value) {
  ko_.Add(value);
}
inline void WheelOdoPara::add_ko(double value) {
  _internal_add_ko(value);
  // @@protoc_insertion_point(field_add:civ.civloc.WheelOdoPara.ko)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
WheelOdoPara::_internal_ko() const {
  return ko_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
WheelOdoPara::ko() const {
  // @@protoc_insertion_point(field_list:civ.civloc.WheelOdoPara.ko)
  return _internal_ko();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
WheelOdoPara::_internal_mutable_ko() {
  return &ko_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
WheelOdoPara::mutable_ko() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.WheelOdoPara.ko)
  return _internal_mutable_ko();
}

// -------------------------------------------------------------------

// LidarPara

// required string name = 1;
inline bool LidarPara::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LidarPara::has_name() const {
  return _internal_has_name();
}
inline void LidarPara::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LidarPara::name() const {
  // @@protoc_insertion_point(field_get:civ.civloc.LidarPara.name)
  return _internal_name();
}
inline void LidarPara::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:civ.civloc.LidarPara.name)
}
inline std::string* LidarPara::mutable_name() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.LidarPara.name)
  return _internal_mutable_name();
}
inline const std::string& LidarPara::_internal_name() const {
  return name_.Get();
}
inline void LidarPara::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LidarPara::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.LidarPara.name)
}
inline void LidarPara::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.LidarPara.name)
}
inline void LidarPara::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.LidarPara.name)
}
inline std::string* LidarPara::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LidarPara::release_name() {
  // @@protoc_insertion_point(field_release:civ.civloc.LidarPara.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LidarPara::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.LidarPara.name)
}

// required int32 rate_hz = 2;
inline bool LidarPara::_internal_has_rate_hz() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LidarPara::has_rate_hz() const {
  return _internal_has_rate_hz();
}
inline void LidarPara::clear_rate_hz() {
  rate_hz_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LidarPara::_internal_rate_hz() const {
  return rate_hz_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LidarPara::rate_hz() const {
  // @@protoc_insertion_point(field_get:civ.civloc.LidarPara.rate_hz)
  return _internal_rate_hz();
}
inline void LidarPara::_internal_set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  rate_hz_ = value;
}
inline void LidarPara::set_rate_hz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rate_hz(value);
  // @@protoc_insertion_point(field_set:civ.civloc.LidarPara.rate_hz)
}

// required .civ.civloc.Extrinsic ex_para = 3;
inline bool LidarPara::_internal_has_ex_para() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || ex_para_ != nullptr);
  return value;
}
inline bool LidarPara::has_ex_para() const {
  return _internal_has_ex_para();
}
inline void LidarPara::clear_ex_para() {
  if (ex_para_ != nullptr) ex_para_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::civ::civloc::Extrinsic& LidarPara::_internal_ex_para() const {
  const ::civ::civloc::Extrinsic* p = ex_para_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::Extrinsic&>(
      ::civ::civloc::_Extrinsic_default_instance_);
}
inline const ::civ::civloc::Extrinsic& LidarPara::ex_para() const {
  // @@protoc_insertion_point(field_get:civ.civloc.LidarPara.ex_para)
  return _internal_ex_para();
}
inline void LidarPara::unsafe_arena_set_allocated_ex_para(
    ::civ::civloc::Extrinsic* ex_para) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ex_para_);
  }
  ex_para_ = ex_para;
  if (ex_para) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.LidarPara.ex_para)
}
inline ::civ::civloc::Extrinsic* LidarPara::release_ex_para() {
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::Extrinsic* temp = ex_para_;
  ex_para_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::Extrinsic* LidarPara::unsafe_arena_release_ex_para() {
  // @@protoc_insertion_point(field_release:civ.civloc.LidarPara.ex_para)
  _has_bits_[0] &= ~0x00000002u;
  ::civ::civloc::Extrinsic* temp = ex_para_;
  ex_para_ = nullptr;
  return temp;
}
inline ::civ::civloc::Extrinsic* LidarPara::_internal_mutable_ex_para() {
  _has_bits_[0] |= 0x00000002u;
  if (ex_para_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::Extrinsic>(GetArena());
    ex_para_ = p;
  }
  return ex_para_;
}
inline ::civ::civloc::Extrinsic* LidarPara::mutable_ex_para() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.LidarPara.ex_para)
  return _internal_mutable_ex_para();
}
inline void LidarPara::set_allocated_ex_para(::civ::civloc::Extrinsic* ex_para) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ex_para_;
  }
  if (ex_para) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ex_para);
    if (message_arena != submessage_arena) {
      ex_para = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ex_para, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ex_para_ = ex_para;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.LidarPara.ex_para)
}

// -------------------------------------------------------------------

// SensorsSetting

// required string version = 1 [default = "1.0.0"];
inline bool SensorsSetting::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorsSetting::has_version() const {
  return _internal_has_version();
}
inline void SensorsSetting::clear_version() {
  version_.ClearToDefault(::civ::civloc::SensorsSetting::_i_give_permission_to_break_this_code_default_version_, GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SensorsSetting::version() const {
  // @@protoc_insertion_point(field_get:civ.civloc.SensorsSetting.version)
  if (version_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_version_.get();
  return _internal_version();
}
inline void SensorsSetting::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:civ.civloc.SensorsSetting.version)
}
inline std::string* SensorsSetting::mutable_version() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.SensorsSetting.version)
  return _internal_mutable_version();
}
inline const std::string& SensorsSetting::_internal_version() const {
  return version_.Get();
}
inline void SensorsSetting::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void SensorsSetting::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.SensorsSetting.version)
}
inline void SensorsSetting::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.SensorsSetting.version)
}
inline void SensorsSetting::set_version(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.SensorsSetting.version)
}
inline std::string* SensorsSetting::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  return version_.Mutable(::civ::civloc::SensorsSetting::_i_give_permission_to_break_this_code_default_version_, GetArena());
}
inline std::string* SensorsSetting::release_version() {
  // @@protoc_insertion_point(field_release:civ.civloc.SensorsSetting.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return version_.ReleaseNonDefault(nullptr, GetArena());
}
inline void SensorsSetting::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.SetAllocated(nullptr, version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.SensorsSetting.version)
}

// required string vehicle_name = 2;
inline bool SensorsSetting::_internal_has_vehicle_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorsSetting::has_vehicle_name() const {
  return _internal_has_vehicle_name();
}
inline void SensorsSetting::clear_vehicle_name() {
  vehicle_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SensorsSetting::vehicle_name() const {
  // @@protoc_insertion_point(field_get:civ.civloc.SensorsSetting.vehicle_name)
  return _internal_vehicle_name();
}
inline void SensorsSetting::set_vehicle_name(const std::string& value) {
  _internal_set_vehicle_name(value);
  // @@protoc_insertion_point(field_set:civ.civloc.SensorsSetting.vehicle_name)
}
inline std::string* SensorsSetting::mutable_vehicle_name() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.SensorsSetting.vehicle_name)
  return _internal_mutable_vehicle_name();
}
inline const std::string& SensorsSetting::_internal_vehicle_name() const {
  return vehicle_name_.Get();
}
inline void SensorsSetting::_internal_set_vehicle_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  vehicle_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SensorsSetting::set_vehicle_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  vehicle_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:civ.civloc.SensorsSetting.vehicle_name)
}
inline void SensorsSetting::set_vehicle_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  vehicle_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:civ.civloc.SensorsSetting.vehicle_name)
}
inline void SensorsSetting::set_vehicle_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  vehicle_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:civ.civloc.SensorsSetting.vehicle_name)
}
inline std::string* SensorsSetting::_internal_mutable_vehicle_name() {
  _has_bits_[0] |= 0x00000002u;
  return vehicle_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SensorsSetting::release_vehicle_name() {
  // @@protoc_insertion_point(field_release:civ.civloc.SensorsSetting.vehicle_name)
  if (!_internal_has_vehicle_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return vehicle_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SensorsSetting::set_allocated_vehicle_name(std::string* vehicle_name) {
  if (vehicle_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  vehicle_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vehicle_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.SensorsSetting.vehicle_name)
}

// repeated .civ.civloc.ImuPara imu = 3;
inline int SensorsSetting::_internal_imu_size() const {
  return imu_.size();
}
inline int SensorsSetting::imu_size() const {
  return _internal_imu_size();
}
inline void SensorsSetting::clear_imu() {
  imu_.Clear();
}
inline ::civ::civloc::ImuPara* SensorsSetting::mutable_imu(int index) {
  // @@protoc_insertion_point(field_mutable:civ.civloc.SensorsSetting.imu)
  return imu_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::ImuPara >*
SensorsSetting::mutable_imu() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.SensorsSetting.imu)
  return &imu_;
}
inline const ::civ::civloc::ImuPara& SensorsSetting::_internal_imu(int index) const {
  return imu_.Get(index);
}
inline const ::civ::civloc::ImuPara& SensorsSetting::imu(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.SensorsSetting.imu)
  return _internal_imu(index);
}
inline ::civ::civloc::ImuPara* SensorsSetting::_internal_add_imu() {
  return imu_.Add();
}
inline ::civ::civloc::ImuPara* SensorsSetting::add_imu() {
  // @@protoc_insertion_point(field_add:civ.civloc.SensorsSetting.imu)
  return _internal_add_imu();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::ImuPara >&
SensorsSetting::imu() const {
  // @@protoc_insertion_point(field_list:civ.civloc.SensorsSetting.imu)
  return imu_;
}

// repeated .civ.civloc.GnssPara gnss = 4;
inline int SensorsSetting::_internal_gnss_size() const {
  return gnss_.size();
}
inline int SensorsSetting::gnss_size() const {
  return _internal_gnss_size();
}
inline void SensorsSetting::clear_gnss() {
  gnss_.Clear();
}
inline ::civ::civloc::GnssPara* SensorsSetting::mutable_gnss(int index) {
  // @@protoc_insertion_point(field_mutable:civ.civloc.SensorsSetting.gnss)
  return gnss_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::GnssPara >*
SensorsSetting::mutable_gnss() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.SensorsSetting.gnss)
  return &gnss_;
}
inline const ::civ::civloc::GnssPara& SensorsSetting::_internal_gnss(int index) const {
  return gnss_.Get(index);
}
inline const ::civ::civloc::GnssPara& SensorsSetting::gnss(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.SensorsSetting.gnss)
  return _internal_gnss(index);
}
inline ::civ::civloc::GnssPara* SensorsSetting::_internal_add_gnss() {
  return gnss_.Add();
}
inline ::civ::civloc::GnssPara* SensorsSetting::add_gnss() {
  // @@protoc_insertion_point(field_add:civ.civloc.SensorsSetting.gnss)
  return _internal_add_gnss();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::GnssPara >&
SensorsSetting::gnss() const {
  // @@protoc_insertion_point(field_list:civ.civloc.SensorsSetting.gnss)
  return gnss_;
}

// repeated .civ.civloc.PerceptionPara perc = 5;
inline int SensorsSetting::_internal_perc_size() const {
  return perc_.size();
}
inline int SensorsSetting::perc_size() const {
  return _internal_perc_size();
}
inline void SensorsSetting::clear_perc() {
  perc_.Clear();
}
inline ::civ::civloc::PerceptionPara* SensorsSetting::mutable_perc(int index) {
  // @@protoc_insertion_point(field_mutable:civ.civloc.SensorsSetting.perc)
  return perc_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::PerceptionPara >*
SensorsSetting::mutable_perc() {
  // @@protoc_insertion_point(field_mutable_list:civ.civloc.SensorsSetting.perc)
  return &perc_;
}
inline const ::civ::civloc::PerceptionPara& SensorsSetting::_internal_perc(int index) const {
  return perc_.Get(index);
}
inline const ::civ::civloc::PerceptionPara& SensorsSetting::perc(int index) const {
  // @@protoc_insertion_point(field_get:civ.civloc.SensorsSetting.perc)
  return _internal_perc(index);
}
inline ::civ::civloc::PerceptionPara* SensorsSetting::_internal_add_perc() {
  return perc_.Add();
}
inline ::civ::civloc::PerceptionPara* SensorsSetting::add_perc() {
  // @@protoc_insertion_point(field_add:civ.civloc.SensorsSetting.perc)
  return _internal_add_perc();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::civ::civloc::PerceptionPara >&
SensorsSetting::perc() const {
  // @@protoc_insertion_point(field_list:civ.civloc.SensorsSetting.perc)
  return perc_;
}

// optional .civ.civloc.WheelOdoPara wheel = 6;
inline bool SensorsSetting::_internal_has_wheel() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || wheel_ != nullptr);
  return value;
}
inline bool SensorsSetting::has_wheel() const {
  return _internal_has_wheel();
}
inline void SensorsSetting::clear_wheel() {
  if (wheel_ != nullptr) wheel_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::civ::civloc::WheelOdoPara& SensorsSetting::_internal_wheel() const {
  const ::civ::civloc::WheelOdoPara* p = wheel_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::WheelOdoPara&>(
      ::civ::civloc::_WheelOdoPara_default_instance_);
}
inline const ::civ::civloc::WheelOdoPara& SensorsSetting::wheel() const {
  // @@protoc_insertion_point(field_get:civ.civloc.SensorsSetting.wheel)
  return _internal_wheel();
}
inline void SensorsSetting::unsafe_arena_set_allocated_wheel(
    ::civ::civloc::WheelOdoPara* wheel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wheel_);
  }
  wheel_ = wheel;
  if (wheel) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.SensorsSetting.wheel)
}
inline ::civ::civloc::WheelOdoPara* SensorsSetting::release_wheel() {
  _has_bits_[0] &= ~0x00000004u;
  ::civ::civloc::WheelOdoPara* temp = wheel_;
  wheel_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::WheelOdoPara* SensorsSetting::unsafe_arena_release_wheel() {
  // @@protoc_insertion_point(field_release:civ.civloc.SensorsSetting.wheel)
  _has_bits_[0] &= ~0x00000004u;
  ::civ::civloc::WheelOdoPara* temp = wheel_;
  wheel_ = nullptr;
  return temp;
}
inline ::civ::civloc::WheelOdoPara* SensorsSetting::_internal_mutable_wheel() {
  _has_bits_[0] |= 0x00000004u;
  if (wheel_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::WheelOdoPara>(GetArena());
    wheel_ = p;
  }
  return wheel_;
}
inline ::civ::civloc::WheelOdoPara* SensorsSetting::mutable_wheel() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.SensorsSetting.wheel)
  return _internal_mutable_wheel();
}
inline void SensorsSetting::set_allocated_wheel(::civ::civloc::WheelOdoPara* wheel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete wheel_;
  }
  if (wheel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(wheel);
    if (message_arena != submessage_arena) {
      wheel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wheel, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  wheel_ = wheel;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.SensorsSetting.wheel)
}

// optional .civ.civloc.LidarPara lidar = 7;
inline bool SensorsSetting::_internal_has_lidar() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || lidar_ != nullptr);
  return value;
}
inline bool SensorsSetting::has_lidar() const {
  return _internal_has_lidar();
}
inline void SensorsSetting::clear_lidar() {
  if (lidar_ != nullptr) lidar_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::civ::civloc::LidarPara& SensorsSetting::_internal_lidar() const {
  const ::civ::civloc::LidarPara* p = lidar_;
  return p != nullptr ? *p : reinterpret_cast<const ::civ::civloc::LidarPara&>(
      ::civ::civloc::_LidarPara_default_instance_);
}
inline const ::civ::civloc::LidarPara& SensorsSetting::lidar() const {
  // @@protoc_insertion_point(field_get:civ.civloc.SensorsSetting.lidar)
  return _internal_lidar();
}
inline void SensorsSetting::unsafe_arena_set_allocated_lidar(
    ::civ::civloc::LidarPara* lidar) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lidar_);
  }
  lidar_ = lidar;
  if (lidar) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:civ.civloc.SensorsSetting.lidar)
}
inline ::civ::civloc::LidarPara* SensorsSetting::release_lidar() {
  _has_bits_[0] &= ~0x00000008u;
  ::civ::civloc::LidarPara* temp = lidar_;
  lidar_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::civ::civloc::LidarPara* SensorsSetting::unsafe_arena_release_lidar() {
  // @@protoc_insertion_point(field_release:civ.civloc.SensorsSetting.lidar)
  _has_bits_[0] &= ~0x00000008u;
  ::civ::civloc::LidarPara* temp = lidar_;
  lidar_ = nullptr;
  return temp;
}
inline ::civ::civloc::LidarPara* SensorsSetting::_internal_mutable_lidar() {
  _has_bits_[0] |= 0x00000008u;
  if (lidar_ == nullptr) {
    auto* p = CreateMaybeMessage<::civ::civloc::LidarPara>(GetArena());
    lidar_ = p;
  }
  return lidar_;
}
inline ::civ::civloc::LidarPara* SensorsSetting::mutable_lidar() {
  // @@protoc_insertion_point(field_mutable:civ.civloc.SensorsSetting.lidar)
  return _internal_mutable_lidar();
}
inline void SensorsSetting::set_allocated_lidar(::civ::civloc::LidarPara* lidar) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lidar_;
  }
  if (lidar) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lidar);
    if (message_arena != submessage_arena) {
      lidar = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lidar, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  lidar_ = lidar;
  // @@protoc_insertion_point(field_set_allocated:civ.civloc.SensorsSetting.lidar)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace civloc
}  // namespace civ

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::civ::civloc::CameraPara_ProjectionModel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::civloc::CameraPara_ProjectionModel>() {
  return ::civ::civloc::CameraPara_ProjectionModel_descriptor();
}
template <> struct is_proto_enum< ::civ::civloc::CameraPara_DistortionModel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::civloc::CameraPara_DistortionModel>() {
  return ::civ::civloc::CameraPara_DistortionModel_descriptor();
}
template <> struct is_proto_enum< ::civ::civloc::PerceptionPara_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::civ::civloc::PerceptionPara_Type>() {
  return ::civ::civloc::PerceptionPara_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_civloc_2fproto_2fsensors_5fsetting_2eproto
